#!/bin/sh

top="${0%/*}/.."
export PATH="${top}/bin:$PATH"

top_srcdir=src
if ! [ -d $top_srcdir ] ; then
    echo "${0##*/}: error, the (handcoded) source directory $top_srcdir is missing"
    exit 1
fi 1>&2
top_objsrcdir=obj/src
if ! [ -d $top_objsrcdir ] ; then
    echo "${0##*/}: error, the (generated) source directory $top_objsrcdir is missing"
    exit 1
fi 1>&2

obj_testsdir=obj/tests
if ! [ -d $obj_testsdir ] && ! mkdir -p "$obj_testsdir" ; then
    echo "${0##*/}: error, the derived C++ directory $obj_testsdir is missing (and cannot be created)"
    exit 1
fi 1>&2

self_testdir=$obj_testsdir/"t99.self/run.$(date +%s).$$"
if ! mkdir -p $self_testdir ; then
    echo "${0##*/}: error, could not make the output directory $self_testdir"
    exit 1
fi 1>&2
rm -f ${self_testdir%/*}/LATEST
ln -s ${self_testdir##*/} ${self_testdir%/*}/LATEST

declare sourcefile1_list="${self_testdir?}/sources1.list"
declare sourcefile2_list="${self_testdir?}/sources2.list"

function run_make_on_stdin() {
    # If we are run recursively from a build system, then  ignore the uber make
    # WATCHOUT - ENSURE that the make prattle does not get in the output stream
    #
    # bad ------------------------------\ (here)
    #                                   |
    #                                   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    # remonstrate --no-insert-namespace make[3]: Entering directory `/build/scold/xscold' -I/build/scold...etc...
    #
    # All extraneous prattle must be suppresed, we need to parse the output
    #   1. make's indigenous prattle occurs on stderr
    #   2. our V=1 prattle via $(info...) that occurs on stdout
    #   3. our uncontrolled prattle via $(info...) that occurs on stdout
    #   4. ???
    #
    (
        # Get rid of any remaining chatter that we can think of ...
        set -o pipefail
        V=0 MAKEFLAGS= make -s -f - 2>/dev/null | sed -n -e '/^DATA: / s/DATA: //p'
    )
}

{
    #
    # WATCHOUT - when make is recursively run through make (e.g. in 'make check')
    # then the output here is different ... make knows it's recursive and prattles differently.
    #
    # WATCHOUT - SEARCHPATH_ETERNAL_MODULES becomes deprecated in hypogeal-twilight >= 0.45.0-0.devel
    # WATCHOUT - and the baleful-ballad of Makefile.am just begins to account for that here in 0.20.0-0.devel
    # WATCHOUT - the successors are  ${PACKAGE_CPPFLAGS_SET[@]} ${AND_CHECK_CPPFLAGS_SET[@]}
    declare -a SEARCHPATH_EXTERNAL_MODULES
    SEARCHPATH_EXTERNAL_MODULES=( $( ( echo 'external-searchpath: ; @echo DATA: $(SEARCHPATH_EXTERNAL_MODULES)' ; cat Makefile ) | run_make_on_stdin ) )
    if ((0 != $?)); then
        echo "${0##*/}: error, could not acquire the SEARCHPATH_EXTERNAL_MODULES"
        exit 1
    fi 1>&2
    if ((0 == ${#SEARCHPATH_EXTERNAL_MODULES[@]})); then
        echo "${0##*/}: error, the SEARCHPATH_EXTERNAL_MODULES is empty. Inexplicably.  This cannot be right."
        exit 1
    fi 1>&2
}

declare -a PACKAGE_CPPFLAGS_SET
PACKAGE_CPPFLAGS_SET=( $( ( echo 'external-searchpath: ; @echo DATA: $(PACKAGE_CPPFLAGS_SET)' ; cat Makefile ) | run_make_on_stdin ) )
if ((0 != $?)); then
    echo "${0##*/}: error, could not acquire the PACKAGE_CPPFLAGS_SET"
    exit 1
fi 1>&2
if ((0 == ${#PACKAGE_CPPFLAGS_SET[@]})); then
    echo "${0##*/}: error, the PACKAGE_CPPFLAGS_SET is empty. Inexplicably.  This cannot be right."
    exit 1
fi 1>&2

declare -a AND_CHECK_CPPFLAGS_SET
AND_CHECK_CPPFLAGS_SET=( $( ( echo 'external-searchpath: ; @echo DATA: $(AND_CHECK_CPPFLAGS_SET)' ; cat Makefile ) | run_make_on_stdin ) )
if ((0 != $?)); then
    echo "${0##*/}: error, could not acquire the AND_CHECK_CPPFLAGS_SET"
    exit 1
fi 1>&2
if ((0 == ${#AND_CHECK_CPPFLAGS_SET[@]})); then
    echo "${0##*/}: warning, the AND_CHECK_CPPFLAGS_SET is empty. This is plausible, but you should check it just in case."
fi 1>&2

declare -a CXX_SOURCES
CXX_SOURCES=( $( ( echo 'actual-sources: ; @echo DATA: $(SOURCES)' ; cat Makefile ) | run_make_on_stdin | tee "$sourcefile1_list" ) )
if ((0 != $?)); then
    echo "${0##*/}: error, could not acquire the SOURCES"
    exit 1
fi 1>&2
if ((0 == ${#CXX_SOURCES[@]})); then
    echo "${0##*/}: error, the SOURCES are empty. Inexplicably.  This cannot be right."
    exit 1
fi 1>&2

declare CC
CC=( $( ( echo 'actual-CC: ; @echo DATA: $(CC)' ; cat Makefile ) | run_make_on_stdin ) )
if ((0 != $?)); then
    echo "${0##*/}: error, could not acquire the CC"
    exit 1
fi 1>&2
if [ -z "${CC}" ]; then
    echo "${0##*/}: error, the CC is empty. Inexplicably.  This cannot be right."
    exit 1
fi 1>&2

declare CXX
CXX=( $( ( echo 'actual-CXX: ; @echo DATA: $(CXX)' ; cat Makefile ) | run_make_on_stdin ) )
if ((0 != $?)); then
    echo "${0##*/}: error, could not acquire the CXX"
    exit 1
fi 1>&2
if [ -z "${CXX}" ]; then
    echo "${0##*/}: error, the CXX is empty. Inexplicably.  This cannot be right."
    exit 1
fi 1>&2

declare -a SCOLD_SOURCES
for cpp in ${CXX_SOURCES[@]}; do
    case "${cpp##*/}" in
    ( c.main.cpp ) 
        continue # we don't want these ... just drop them
        ;;
    ( CONFIG.cpp )
        # DO NOT
        #    pre=${cpp#obj/}
        # because CONFIG.cpp is found in the obj directory as it is automatically generated)
        pre=${cpp%.cpp}
        scold=$pre.xcpp
        ;;
    ( * )
        # These files are hand-coded and exist in $(srcdir)
        pre=${cpp#obj/}
        pre=${pre%.cpp}
        scold=$pre.xcpp
        ;;
    esac
    SCOLD_SOURCES=( "${SCOLD_SOURCES[@]}" "$scold" )
done

objdir=$self_testdir/src
modulesdir=$self_testdir/modules
if ! mkdir $objdir $modulesdir ; then
    echo "${0##*/}: error, could not make the output directories $objdir $modulesdir"
    exit 1
fi 1>&2

cat <<EOF
top_srcdir=$top_srcdir
top_objsrcdir=$top_objsrcdir
objdir=$objdir
modulesdir=$modulesdir
---
EOF

# WATCHOUT - this must match the settings in Makefile.am
# [[FIXTHIS]] can we grok these from the ../Makefile.am somehow?
# [[FIXTHIS]] this will begin to fail with true C++20 and true use of -std=c++2b -fconcepts-ts -fmodules-ts -fcoroutines-ts
declare -a GXX_OPTIONS=( -std=gnu++1z -fconcepts )

function failing() {
    local e=$?
    if [ -n "$1" ] ; then
        echo "at $1"
    fi
    echo "${0##*/}[$$] failing with exit $e"
    exit $e
}
trap failing ERR

(
    if false; then
        find $top_srcdir -name '*.xcpp'
    else
        for scold in "${SCOLD_SOURCES[@]}"; do
            echo "$scold"
        done
    fi
) | sort | tee "${sourcefile2_list}" | while read file_xcpp; do
    if [ -z "$file_xcpp" ] ; then
        # The final record terminator will start a new "empty" record that has no terminator
        # e.g.
        #     filename8\n
        #     filename9\n <------------------ empty final record with no newline
        continue
    fi
    # don't go directly to the $logfile as that directory does not exist yet, and we want remonstrate to mkdir it for us
    filebase=${file_xcpp%.xcpp}
    # DO NOT
    #     filebase=${filebase%/namespace}
    # we want the namespace part of the filename
    basebase=${filebase##*/}

    declare DC_OPTIONS
    # match the DC options supplied in Makefile.am
    case $file_xcpp in
    ( */autotools/autoconf/Config/scold/CONFIG.xcpp )
        DC_OPTIONS=( --no-insert-namespace )
        srcdir=$top_objsrcdir
        ;;
    ( * )
        DC_OPTIONS=( )
        srcdir=$top_srcdir
        ;;
    esac

    # remove the $srcdir prefix
    # add the $objdir prefix instead
    modbase=${filebase#$srcdir/}
    # replace slashes with dots to get the module name
    module=${modbase//\//.}

    logfile="$objdir/${modbase}.log"
    tmplog="$objdir/t99.${basebase}.$$.log"
    file_cpp="$objdir/${modbase}.cpp"
    file_o="$objdir/${modbase}.o"
    file_ii="$objdir/${modbase}.ii"
    dcfile="$objdir/${modbase}.dc.sh"
    gxxfile="$objdir/${modbase}.gxx.sh"
    cppfile="$objdir/${modbase}.cpp.sh"
    gdbfile="$objdir/${modbase}.gdb"

    mkdir -p "${logfile%/*}" || failing

    # WATCHOUT -- see the $srcdir ... if not correct then the module name is guessed incorrectly from $file_xcpp
    # This occurs at least at:
    #     obj.src.autotools.autoconf.Config.scold.CONFIG
    cat > $gdbfile <<__EOFGDB__
set args ${DC_OPTIONS[@]} ${PACKAGE_CPPFLAGS_SET[@]} ${AND_CHECK_CPPFLAGS_SET[@]} ${SEARCHPATH_EXTERNAL_MODULES[@]} --verbose --debug --make-directories --modulesdir=$modulesdir --objdir=$objdir --srcdir=$srcdir $file_xcpp
__EOFGDB__
    cat > $dcfile <<__EOFDC__ && chmod a+x "$dcfile"
#!/bin/sh
echo "generating <$module>"
echo srcdir=$srcdir
echo modulesdir=$modulesdir
echo objdir=$objdir
echo xcpp=$file_xcpp
echo -n "generating <$module> "
remonstrate ${DC_OPTIONS[@]} ${PACKAGE_CPPFLAGS_SET[@]} ${AND_CHECK_CPPFLAGS_SET[@]} ${SEARCHPATH_EXTERNAL_MODULES[@]} --verbose --debug --make-directories --modulesdir=$modulesdir --objdir=$objdir --srcdir=$srcdir $file_xcpp >& $tmplog
e=\$?
mv -f $tmplog $logfile
echo "exit \$e $logfile"
exit \$e
__EOFDC__
    cat > "$cppfile" <<__EOFCPP__ && chmod a+x "$cppfile"
#!/bin/sh
${CXX:-g++} -E ${GXX_OPTIONS[@]} -I${modulesdir} ${PACKAGE_CPPFLAGS_SET[@]} ${AND_CHECK_CPPFLAGS_SET[@]} ${SEARCHPATH_EXTERNAL_MODULES[@]} -o $file_ii $file_cpp
__EOFCPP__
    cat > "$gxxfile" <<__EOFGXX__ && chmod a+x "$gxxfile"
#!/bin/sh
${CXX:-g++} -c ${GXX_OPTIONS[@]} -I${modulesdir} ${PACKAGE_CPPFLAGS_SET[@]} ${AND_CHECK_CPPFLAGS_SET[@]} ${SEARCHPATH_EXTERNAL_MODULES[@]} -o $file_o $file_cpp
__EOFGXX__
done

echo "Having finished script generation, moving on to disaggregation..."
find $self_testdir -name '*.dc.sh' | sort | while read dcfile; do
    echo "compiling: $dcfile" 
    "$dcfile" || failing "$dcfile"
done

echo "Having finished disaggregation, moving on to compilation..."
find $self_testdir -name '*.gxx.sh' | sort | while read gxxfile; do
    echo "compiling: $gxxfile" 
    "$gxxfile" || failing "$gxxfile"
done

echo "OK (done with all tests)"
