// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace search {
      class Modules;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::search::Modules : public cppunit::test::Fixture {
public:
  auto test_constructor_initializer_list() -> void;
  auto test_constructor_pathvector_copy() -> void;
  auto test_constructor_pathvector_move() -> void;
  auto test_constructor_move() -> void;
  auto test_assignment_move() -> void;
  auto test_operator_call_string() -> void;
  auto test_operator_call_Module() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.search.Modules

auto tests::unit::search::Modules::test_constructor_initializer_list() -> void {
  ::scold::search::Modules search{"/usr/include"}; // <--------------- test this
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT(ok(searched));
}

auto tests::unit::search::Modules::test_constructor_pathvector_copy() -> void {
  std::vector<std::string> pv{"/usr/include"};
  ::scold::search::Modules search(pv); // <--------------- test this
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT(ok(searched));
}

auto tests::unit::search::Modules::test_constructor_pathvector_move() -> void {
  std::vector<std::string> pv{"/usr/include"};
  ::scold::search::Modules search(std::move(pv)); // <--------------- test this
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT(ok(searched));
}

#import std.move
auto tests::unit::search::Modules::test_constructor_move() -> void {
  ::scold::search::Modules search{"/usr/include"};
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT_MESSAGE("first: expect success",  ok(searched));
  {
    ::scold::search::Modules research(std::move(search)); // <----------- test this, the move constructor
    auto researched = research("sys/types.h");
    auto searched = search("sys/types.h"); // <--------------- this should fail because of the move
    CPPUNIT_ASSERT(ok(researched));
    CPPUNIT_ASSERT_MESSAGE("second: expect failure (emptied)", !ok(searched));
  }
}

#import format.q
#import std.cerr
#import std.move
auto tests::unit::search::Modules::test_assignment_move() -> void {
  using format::q;
  ::scold::search::Modules search{"/usr/include"};
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT_MESSAGE("first: expect success", ok(searched));
  {
    ::scold::search::Modules research{"/tmp"};
    research = std::move(search); // <----------- test this, the move-assignment opreator
    auto researched = research("sys/types.h");
    std::cerr << "second: researched ";
   if (ok(researched)) {
      std::cerr << q(directory(researched)) << '\n';
   } else {
      std::cerr << "(empty)\n";
    }
    CPPUNIT_ASSERT(ok(researched));
    CPPUNIT_ASSERT_EQUAL(std::string("/usr/include"), directory(researched));
    auto searched = search("sys/types.h"); // <--------------- this should fail because of the move
    std::cerr << "second: searched ";
    if (ok(searched)) {
      std::cerr << q(directory(searched)) << '\n';
    } else {
      std::cerr << "(empty)\n";
    }
    CPPUNIT_ASSERT(ok(researched));
    CPPUNIT_ASSERT_MESSAGE("second: expect failure (emptied)", !ok(searched));
  }
}

auto tests::unit::search::Modules::test_operator_call_string() -> void {
  ::scold::search::Modules search{"/usr/include"};
  auto searched = search("sys/types.h"); // <--------------- test this
  CPPUNIT_ASSERT(ok(searched));
}

auto tests::unit::search::Modules::test_operator_call_Module() -> void {
  ::scold::search::Modules search{"/usr/include"};
  ::scold::Module specimen{"apple", "banana", "cherry"};
  auto searched = search(specimen); // <----------- test this (it should fail)
  CPPUNIT_ASSERT(!ok(searched));
}

auto tests::unit::search::Modules::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Modules");
  s << call("constructor-initializer_list", &Modules::test_constructor_initializer_list)
    << call("constructor-pathvector-move", &Modules::test_constructor_pathvector_move)
    << call("constructor-pathvector-copy", &Modules::test_constructor_pathvector_copy)
    << call("constructor-move", &Modules::test_constructor_move)
    << call("assignment-move", &Modules::test_assignment_move)
    << call("operator_call_string", &Modules::test_operator_call_string)
    << call("operator_call_Modules", &Modules::test_operator_call_Module)
    ;
  return finalize(s);
}
#endiv
