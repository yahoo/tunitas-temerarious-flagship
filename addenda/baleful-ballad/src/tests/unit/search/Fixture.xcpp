// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace search {
      class Fixture;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::search::Fixture : public cppunit::test::Fixture {
public:
  auto test_Module_usage() -> void;
  auto test_Submodule_usage() -> void;
  auto test_Herein_usage() -> void;
  auto test_Build_usage() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.Module
#import scold.Submodule

#import scold.search.Modules
auto tests::unit::search::Fixture::test_Module_usage() -> void {
  ::scold::search::Modules search{"/usr/include"};
  // searching for include files is fine too
  auto searched = search("sys/types.h");
  CPPUNIT_ASSERT(ok(searched));
}

#import format.q
#import std.cerr
#import sys.posix.exists
#import scold.search.Submodules
auto tests::unit::search::Fixture::test_Submodule_usage() -> void {
  using sm = ::scold::Submodule;
  // These are expected to be submodules of baleful-ballad
  ::scold::search::Submodules search{sm("external/module-c-string"), sm("external/module-sqlite")};
  // searching for include files is fine too
  ::scold::Module some_module{"c", "argv"};
  auto searched = search(some_module);
  if (ok(searched)) {
    std::cerr << "Submodule " << format::q(value(searched).directory) << '\n';
  }
  bool nevermind = false;
  auto does_exist = sys::posix::exists("external/module-c-string/obj/modules/c.argv");
  auto is_ok = ok(searched);
  auto xcpp_exists = sys::posix::exists("external/module-c-string/src/c/argv.xcpp");
  if (!does_exist) {
    if (is_ok) {
      if (xcpp_exists) {
        //
        // WATCHOUT - search(some_module) returns true if the disaggregated modules are not yet disaggregatedd
        //            BUT the source code is visible in the submodule tree
        //
        // To wit:
        //     missing:   external/module-c-string/obj/modules/c.argv
        //     found:     external/module-c-string/src/c/argv.xcpp
        //     return     external/module-c-string/obj/modules <---------- is this the wrong answer when external/module-c-string is never built?
        //                                                                 arguably, this is the wrong answer when external/module-s-string is not built.
        //
        // Either it exists or it doesn't ...
        // ... and it won't exist if the submodules have not been elaborated; e.g. in a mock build chroot
        nevermind = true;
      }
    }
  }
  if ( !nevermind ) {
    CPPUNIT_ASSERT_EQUAL(does_exist, is_ok);
  }
}

#import scold.search.Herein
#import sys.posix.exists
auto tests::unit::search::Fixture::test_Herein_usage() -> void {
  // search::Herein means the module is built "herein" ... with the "obj/modules" being implicit
  ::scold::search::Herein search(".");
  ::scold::Module some_module{"scold", "filenames", "Filenames"};
  auto searched = search(some_module);
  // does it exist?
  CPPUNIT_ASSERT(sys::posix::exists("obj/modules/scold.filenames.Filenames"));
  {
    // for fun and for consistency
    CPPUNIT_ASSERT(sys::posix::exists("src/scold/filenames/Filenames.xcpp"));
    CPPUNIT_ASSERT(sys::posix::exists("obj/src/scold/filenames/Filenames.cpp"));
  }
  // is it found?
  CPPUNIT_ASSERT(ok(searched));
}

#import scold.search.Build
auto tests::unit::search::Fixture::test_Build_usage() -> void {
  ::scold::search::Build search(".", {"external/module-c-string"}, {"/usr/include"});
  ::scold::Module some_module{"tests", "unit", "search", "Fixture"}; // this is this!
  auto searched = search(some_module);
  CPPUNIT_ASSERT(sys::posix::exists("src/tests/unit/search/Fixture.xcpp"));
  CPPUNIT_ASSERT(ok(searched));
}

#import tests.unit.search.Build
#import tests.unit.search.Herein
#import tests.unit.search.Modules
#import tests.unit.search.Submodules
#import tests.unit.search.cache.Fixture
auto tests::unit::search::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("search");
  s << call("Module-usage", &Fixture::test_Module_usage)
    << call("Submodule-usage", &Fixture::test_Submodule_usage)
    << call("Herein-usage", &Fixture::test_Herein_usage)
    << call("Build-usage", &Fixture::test_Build_usage)
    << add<Modules>()
    << add<Submodules>()
    << add<Herein>()
    << add<Build>()
    << add<cache::Fixture>()
    ;
  return finalize(s);
}
#endiv
