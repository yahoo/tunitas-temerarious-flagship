// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace plural {
      class Fixture;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::plural::Fixture : public cppunit::test::Fixture {
public:
  auto test_function() -> void;
  auto test_operator_insert() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.pluralize

#import std.string
auto tests::unit::plural::Fixture::test_function() -> void {
  using s = std::string;
  auto p0 = ::scold::pluralize(0, "error");
  CPPUNIT_ASSERT(0 == p0.value);
  CPPUNIT_ASSERT_EQUAL(s("errors"), p0.noun);
  auto p1 = ::scold::pluralize(1, "error");
  CPPUNIT_ASSERT(1 == p1.value);
  CPPUNIT_ASSERT_EQUAL(s("error"), p1.noun);
  auto p2 = ::scold::pluralize(2, "error");
  CPPUNIT_ASSERT(2 == p2.value);
  CPPUNIT_ASSERT_EQUAL(s("errors"), p2.noun);
}

#import std.string
#import std.ostringstream
auto tests::unit::plural::Fixture::test_operator_insert() -> void {
  using noun_type = ::scold::detail::plural::Noun<int, ::scold::detail::plural::AddS>;
  noun_type zero(0, "error");
  noun_type one(1, "error");
  noun_type two(2, "error");
  std::ostringstream buf;
  buf << zero << '\n' << one << '\n' << two << '\n';
  std::string actual = buf.str();
  std::string expected = "0 errors\n1 error\n2 errors\n"; 
  CPPUNIT_ASSERT_EQUAL(expected, actual);
}

auto tests::unit::plural::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("plural");
  s << call("function", &Fixture::test_function)
    << call("operator<<", &Fixture::test_operator_insert)
    ;
  return finalize(s);
}
#endiv
