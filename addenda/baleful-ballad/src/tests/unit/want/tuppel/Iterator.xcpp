// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace want {
      namespace tuppel {
        class Iterator;
      }
    }
  }
}
#endiv
#divert <hpp>
#import std.map
#import std.set
class tests::unit::want::tuppel::Iterator : public cppunit::test::Fixture {
public:
  auto test_constructor_default() -> void;
  auto test_operator_preincr() -> void;  // operator++()
  auto test_operator_postincr() -> void; // operator++(int)
  auto test_operator_star() -> void;
  auto test_operator_eq() -> void;
  auto test_operator_ne() -> void;
  auto test_loop() -> void;

  static auto suite() -> cppunit::Test *;

  using map_type = std::map<int, char>;
  using set_type = std::set<char>;
};
#endiv
#divert <cpp>
#import want.tuppel.Iterator
#import want.tuppel.Ganger
#import std.get
#import std.move

auto tests::unit::want::tuppel::Iterator::test_constructor_default() -> void {
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i; // <---- prove there is a default constructor available
  // yup, it constructed
  CPPUNIT_ASSERT(true);
}

auto tests::unit::want::tuppel::Iterator::test_operator_preincr() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  ::want::tuppel::Ganger<map_type, set_type> g(m, s);
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> e = g.end();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i = g.begin();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> j = i;
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> k = ++i;
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> l = ++i;
  CPPUNIT_ASSERT(1 == std::get<0>(*j).first);
  CPPUNIT_ASSERT('a' == std::get<0>(*j).second);
  CPPUNIT_ASSERT('m' == std::get<1>(*j));
  CPPUNIT_ASSERT(2 == std::get<0>(*k).first);
  CPPUNIT_ASSERT('b' == std::get<0>(*k).second);
  CPPUNIT_ASSERT('n' == std::get<1>(*k));
  CPPUNIT_ASSERT(e == i);
  CPPUNIT_ASSERT(e == l);
}

auto tests::unit::want::tuppel::Iterator::test_operator_postincr() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  ::want::tuppel::Ganger<map_type, set_type> g(m, s);
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> e = g.end();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i = g.begin();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> j = i++;
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> k = i++;
  CPPUNIT_ASSERT(1 == std::get<0>(*j).first);
  CPPUNIT_ASSERT('a' == std::get<0>(*j).second);
  CPPUNIT_ASSERT('m' == std::get<1>(*j));
  CPPUNIT_ASSERT(2 == std::get<0>(*k).first);
  CPPUNIT_ASSERT('b' == std::get<0>(*k).second);
  CPPUNIT_ASSERT('n' == std::get<1>(*k));
  CPPUNIT_ASSERT(e == i);
}

auto tests::unit::want::tuppel::Iterator::test_operator_star() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  ::want::tuppel::Ganger<map_type, set_type> g(m, s);
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i = g.begin();
  int i1_first_first = std::get<0>(*i).first;
  char i1_first_second = std::get<0>(*i).second;
  char i1_second = std::get<1>(*i);
  CPPUNIT_ASSERT(1 == i1_first_first);
  CPPUNIT_ASSERT('a' == i1_first_second);
  CPPUNIT_ASSERT('m' == i1_second);
  i++;
  int i2_first_first = std::get<0>(*i).first;
  char i2_first_second = std::get<0>(*i).second;
  char i2_second = std::get<1>(*i);
  CPPUNIT_ASSERT(2 == i2_first_first);
  CPPUNIT_ASSERT('b' == i2_first_second);
  CPPUNIT_ASSERT('n' == i2_second);
}

auto tests::unit::want::tuppel::Iterator::test_operator_eq() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  ::want::tuppel::Ganger<map_type, set_type> g(m, s);
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> e = g.end();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i = g.begin();
  CPPUNIT_ASSERT( ! (i == e) );
  i++;
  CPPUNIT_ASSERT( ! (i == e) );
  i++;
  CPPUNIT_ASSERT(   (i == e) );
}

auto tests::unit::want::tuppel::Iterator::test_operator_ne() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  ::want::tuppel::Ganger<map_type, set_type> g(m, s);
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> e = g.end();
  ::want::tuppel::Iterator<map_type::iterator, set_type::iterator> i = g.begin();
  CPPUNIT_ASSERT( (i != e) );
  i++;
  CPPUNIT_ASSERT( (i != e) );
  i++;
  CPPUNIT_ASSERT(!(i != e) );
}

auto tests::unit::want::tuppel::Iterator::test_loop() -> void {
  map_type m{{1,'a'},{2,'b'}};
  set_type s{'m', 'n'};
  using ganger_type = ::want::tuppel::Ganger<map_type, set_type>;
  ganger_type g(m, s);
  int summation11 = 0;
  int summation12 = 0;
  int summation2 = 0;
  unsigned count = 0;
  for (ganger_type::iterator i(g.begin()), e(g.end()); e != i; ++i) {
    count++;
    std::cerr << "test_loop sees " << std::get<0>(*i).first << ' ' << std::get<0>(*i).second << ' ' << std::get<1>(*i) << '\n';
    summation11 += std::get<0>(*i).first;
    summation12 += std::get<0>(*i).second;
    summation2 += std::get<1>(*i);
  }
  CPPUNIT_ASSERT(2 == count);
  int const expected11 = 3;
  int const expected12 = (int)('a') + (int)('b');
  int const expected2 = (int)('m') + (int)('n');
  CPPUNIT_ASSERT(expected11 == summation11);
  CPPUNIT_ASSERT(expected12 == summation12);
  CPPUNIT_ASSERT(expected2 == summation2);
}

auto tests::unit::want::tuppel::Iterator::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Iterator");
  s << call("constructor-default", &Iterator::test_constructor_default)
    << call("operator++(int)", &Iterator::test_operator_postincr)
    << call("operator++()", &Iterator::test_operator_preincr)
    << call("operator*", &Iterator::test_operator_star)
    << call("operator==", &Iterator::test_operator_eq)
    << call("operator!=", &Iterator::test_operator_ne)
    << call("loop", &Iterator::test_loop)
    ;
  return finalize(s);
}
#endiv
