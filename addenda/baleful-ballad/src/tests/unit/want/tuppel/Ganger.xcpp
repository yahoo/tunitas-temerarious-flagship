// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace want {
      namespace tuppel {
        class Ganger;
      }
    }
  }
}
#endiv
#divert <hpp>
#import std.list
#import std.set
#import std.string
#import std.vector
class tests::unit::want::tuppel::Ganger : public cppunit::test::Fixture {
public:
  auto setUp() -> void override final;
  auto tearDown() -> void override final;

  using list_type = std::list<std::string>;
  using vector_type = std::vector<std::string>;
  using set_type = std::set<std::string>;

  list_type empty_ls;
  vector_type empty_vs;
  set_type empty_ss;

  list_type full_ls;
  vector_type full_vs;
  set_type full_ss;

  list_type overfull_ls;
  vector_type overfull_vs;
  set_type overfull_ss;

  auto test_constructor() -> void;
  auto test_begin_muting() -> void;
  auto test_end_muting() -> void;
  auto test_begin_end_const_muting() -> void;
  auto test_begin_consty() -> void;
  auto test_end_consty() -> void;
  auto test_usage() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import want.tuppel.Ganger

auto tests::unit::want::tuppel::Ganger::setUp() -> void {
  empty_ls.clear();
  empty_vs.clear();
  empty_ss.clear();
  full_ls = list_type{"apple"};
  full_vs = vector_type{"banana"};
  full_ss = set_type{"cherry"};
  overfull_ls = list_type{"apple", "apple+"};
  overfull_vs = vector_type{"banana", "banana+"};
  overfull_ss = set_type{"cherry", "cherry+"};
}

auto tests::unit::want::tuppel::Ganger::tearDown() -> void {
  empty_ls.clear();
  empty_vs.clear();
  empty_ss.clear();
  full_ls.clear();
  full_vs.clear();
  full_ss.clear();
  overfull_ls.clear();
  overfull_vs.clear();
  overfull_ss.clear();
}

#import std.move
auto tests::unit::want::tuppel::Ganger::test_constructor() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> g(empty_ls, empty_vs, empty_ss); // <--------- test this
  // yup, it constructed
  CPPUNIT_ASSERT(true);
}

auto tests::unit::want::tuppel::Ganger::test_begin_muting() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> g(full_ls, full_vs, full_ss);
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::iterator i = g.begin(); // <--------- test this
  auto r = *i;
  CPPUNIT_ASSERT("apple" == std::get<0>(r));
  CPPUNIT_ASSERT("banana" == std::get<1>(r));
  CPPUNIT_ASSERT("cherry" == std::get<2>(r));
}

auto tests::unit::want::tuppel::Ganger::test_end_muting() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> g(full_ls, full_vs, full_ss);
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::iterator i = g.begin();
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::iterator e = g.end(); // <--------- test this
  CPPUNIT_ASSERT(e != i);
  auto r = *i;
  CPPUNIT_ASSERT("apple" == std::get<0>(*i));
  CPPUNIT_ASSERT("banana" == std::get<1>(*i));
}

auto tests::unit::want::tuppel::Ganger::test_begin_end_const_muting() -> void {
  // show that consty begin/end work
  // show that muting begin/end work
  vector_type vs{"apple"};
  set_type ss{"banana"};
  using ganger_type = ::want::tuppel::Ganger<vector_type, set_type>;
  ganger_type mg(vs, ss);
  auto mgb = mg.begin();
  auto mge = mg.end();
  CPPUNIT_ASSERT(mgb != mge);
  mgb++;
  CPPUNIT_ASSERT(mgb == mge);
  ganger_type const cg(vs, ss);
  auto cgb = cg.begin();
  auto cge = cg.end();
  CPPUNIT_ASSERT(cgb != cge);
  cgb++;
  CPPUNIT_ASSERT(cgb == cge);
}

auto tests::unit::want::tuppel::Ganger::test_begin_consty() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> const g(full_ls, full_vs, full_ss); // <----- consty
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::const_iterator i = g.begin(); // <---------------- test this
  auto r = *i;
  CPPUNIT_ASSERT("apple" == std::get<0>(*i));
  CPPUNIT_ASSERT("banana" == std::get<1>(*i));
}

auto tests::unit::want::tuppel::Ganger::test_end_consty() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> const g(full_ls, full_vs, full_ss); // <----- consty
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::const_iterator i = g.begin();
  ::want::tuppel::Ganger<list_type, vector_type, set_type>::const_iterator e = g.end(); // <------------------ test this
  CPPUNIT_ASSERT(e != i);
  auto r = *i;
  CPPUNIT_ASSERT("apple" == std::get<0>(*i));
  CPPUNIT_ASSERT("banana" == std::get<1>(*i));
}

#import std.ostringstream
auto tests::unit::want::tuppel::Ganger::test_usage() -> void {
  ::want::tuppel::Ganger<list_type, vector_type, set_type> const g(overfull_ls, overfull_vs, overfull_ss);
  std::ostringstream buf;
  for (auto vs : g) {
    buf << "(1)-" << std::get<0>(vs) << "(2)-" << std::get<1>(vs) << "(3)-" << std::get<2>(vs) << '\n';
  }
  std::string const actual = buf.str();
  std::string const expected = ("(1)-apple(2)-banana(3)-cherry\n"
                                "(1)-apple+(2)-banana+(3)-cherry+\n");
  std::cerr << "expected=qq!" << expected << "!\n"
            << "actual  =qq!" << actual << "!\n";
  CPPUNIT_ASSERT(expected == actual);
}

auto tests::unit::want::tuppel::Ganger::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Ganger");
  s << call("constructor", &Ganger::test_constructor)
    << call("begin-muting", &Ganger::test_begin_muting)
    << call("end-muting", &Ganger::test_end_muting)
    << call("begin-end/consty-muting", &Ganger::test_begin_end_const_muting)
    << call("begin-consty", &Ganger::test_begin_consty)
    << call("end-consty", &Ganger::test_end_consty)
    << call("usage", &Ganger::test_usage)
    ;
  return finalize(s);
}
#endiv
