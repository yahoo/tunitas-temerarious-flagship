// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace want {
      namespace doppel {
        class Fixture;
      }
    }
  }
}
#endiv
#divert <hpp>
#import std.set
#import std.string
#import std.vector
class tests::unit::want::doppel::Fixture : public cppunit::test::Fixture {
public:
  using set_type = std::set<std::string>;
  using vector_type = std::vector<int>;

  auto test_doppelgang_muting() -> void;
  auto test_doppelgang_consty() -> void;
  auto test_doppelgang_muting_consty() -> void;
  auto test_doppelgang_consty_muting() -> void;

  static auto suite() -> cppunit::Test *;
protected:
  template<typename CONTAINER1, typename CONTAINER2> static auto same_test_consty_and_muting(CONTAINER1 &, CONTAINER2 &) -> void;
};
#endiv
#divert <tpp>
#import want.doppelgang
#import std.ostringstream
template<typename CONTAINER1, typename CONTAINER2> auto tests::unit::want::doppel::Fixture::same_test_consty_and_muting(CONTAINER1 &container1, CONTAINER2 &container2) -> void {
  std::ostringstream buf;
  for (auto si : ::want::doppelgang(container1, container2)) {
    buf << si.first << '=' << si.second << '\n';
  }
  std::string const actual = buf.str();
  std::string const expected = "apple=1\nbanana=2\ncherry=3\n";
  CPPUNIT_ASSERT(actual == expected);
}
#endiv
#divert <cpp>

auto tests::unit::want::doppel::Fixture::test_doppelgang_muting() -> void {
  set_type container1{"apple", "banana", "cherry"};
  vector_type container2{1, 2, 3};
  same_test_consty_and_muting(container1, container2);
}

auto tests::unit::want::doppel::Fixture::test_doppelgang_consty() -> void {
  set_type const container1{"apple", "banana", "cherry"}; // <------------ same test but 'const'
  vector_type const container2{1, 2, 3}; // <------------------------------------ same test but 'const'
  same_test_consty_and_muting(container1, container2);
}

auto tests::unit::want::doppel::Fixture::test_doppelgang_consty_muting() -> void {
  set_type const container1{"apple", "banana", "cherry"}; // <------------ same test but 'const'
  vector_type container2{1, 2, 3}; // <------------------------------------------ same test but 'muting' (non-const)
  same_test_consty_and_muting(container1, container2);
}

auto tests::unit::want::doppel::Fixture::test_doppelgang_muting_consty() -> void {
  set_type container1{"apple", "banana", "cherry"}; // <------------------ same test but 'muting' (non-const)
  vector_type const container2{1, 2, 3}; // <------------------------------------ same test but 'const'
  same_test_consty_and_muting(container1, container2);
}

#import tests.unit.want.doppel.Combine
#import tests.unit.want.doppel.Ganger
#import tests.unit.want.doppel.Iterator
#import tests.unit.want.doppel.Traits
auto tests::unit::want::doppel::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("doppel");
  s << call("doppelgang-muting", &Fixture::test_doppelgang_muting)
    << call("doppelgang-consty", &Fixture::test_doppelgang_consty)
    << call("doppelgang-consty-muting", &Fixture::test_doppelgang_consty_muting)
    << call("doppelgang-muting-consty", &Fixture::test_doppelgang_muting_consty)
    << add<Combine>()
    << add<Ganger>()
    << add<Iterator>()
    << add<Traits>()
    ;
  return finalize(s);
}
#endiv
