// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace want {
      namespace doppel {
        class Ganger;
      }
    }
  }
}
#endiv
#divert <hpp>
#import std.set
#import std.string
#import std.vector
class tests::unit::want::doppel::Ganger : public cppunit::test::Fixture {
public:
  auto test_constructor() -> void;
  auto test_begin_muting() -> void;
  auto test_end_muting() -> void;
  auto test_begin_end_const_muting() -> void;
  auto test_consty() -> void;
  auto test_usage() -> void;

  static auto suite() -> cppunit::Test *;

  using vector_type = std::vector<std::string>;
  using set_type = std::set<std::string>;
};
#endiv
#divert <cpp>
#import want.doppel.Ganger
#import std.move

auto tests::unit::want::doppel::Ganger::test_constructor() -> void {
  vector_type vs;
  set_type ss;
  ::want::doppel::Ganger<vector_type, set_type> g(vs, ss); // <--------- test this
  // yup, it constructed
  CPPUNIT_ASSERT(true);
}

auto tests::unit::want::doppel::Ganger::test_begin_muting() -> void {
  vector_type vs{"apple"};
  set_type ss{"banana"};
  ::want::doppel::Ganger<vector_type, set_type> g(vs, ss);
  ::want::doppel::Ganger<vector_type, set_type>::iterator i = g.begin(); // <--------- test this
  auto r = *i;
  CPPUNIT_ASSERT("apple" == (*i).first);
  CPPUNIT_ASSERT("banana" == (*i).second);
}

auto tests::unit::want::doppel::Ganger::test_end_muting() -> void {
  vector_type vs{"apple"};
  set_type ss{"banana"};
  ::want::doppel::Ganger<vector_type, set_type> g(vs, ss);
  ::want::doppel::Ganger<vector_type, set_type>::iterator i = g.begin();
  ::want::doppel::Ganger<vector_type, set_type>::iterator e = g.end(); // <--------- test this
  CPPUNIT_ASSERT(i != e);
  auto r = *i;
  CPPUNIT_ASSERT("apple" == (*i).first);
  CPPUNIT_ASSERT("banana" == (*i).second);
}

auto tests::unit::want::doppel::Ganger::test_begin_end_const_muting() -> void {
  // show that consty begin/end work
  // show that muting begin/end work
  vector_type vs{"apple"};
  set_type ss{"banana"};
  using ganger_type = ::want::doppel::Ganger<vector_type, set_type>;
  ganger_type mg(vs, ss);
  auto mgb = mg.begin();
  auto mge = mg.end();
  CPPUNIT_ASSERT(mgb != mge);
  mgb++;
  CPPUNIT_ASSERT(mgb == mge);
  ganger_type const cg(vs, ss);
  auto cgb = cg.begin();
  auto cge = cg.end();
  CPPUNIT_ASSERT(cgb != cge);
  cgb++;
  CPPUNIT_ASSERT(cgb == cge);
}

#import want.doppelgang
auto tests::unit::want::doppel::Ganger::test_consty() -> void {
  vector_type const vs{"apple"}; // <------------------- consty
  set_type const ss{"banana"}; // <--------------------- consty
  bool test_something = false;
  for (auto dg : ::want::doppelgang(vs, ss)) {
    test_something = true;
    CPPUNIT_ASSERT("apple" == dg.first);
    CPPUNIT_ASSERT("banana" == dg.second);
  }
  CPPUNIT_ASSERT(test_something);
}

#import std.ostringstream
auto tests::unit::want::doppel::Ganger::test_usage() -> void {
  vector_type vs{"apple", "banana"};
  set_type ss{"here", "there"};
  ::want::doppel::Ganger<vector_type, set_type> g(vs, ss); // <----- muting
  std::ostringstream buf;
  for (auto vs : g) {
    buf << vs.first << '=' << vs.second << '\n';
    CPPUNIT_ASSERT(("apple" == vs.first && "here" == vs.second)
                   ||
                   ("banana" == vs.first && "there" == vs.second));
  }
  std::string const actual = buf.str();
  std::string const expected = "apple=here\nbanana=there\n";
  CPPUNIT_ASSERT(expected == actual);
}

auto tests::unit::want::doppel::Ganger::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Ganger");
  s << call("constructor", &Ganger::test_constructor)
    << call("begin-muting", &Ganger::test_begin_muting)
    << call("end-muting", &Ganger::test_end_muting)
    << call("begin-end/consty-muting", &Ganger::test_begin_end_const_muting)
    << call("consty", &Ganger::test_consty)
    << call("usage", &Ganger::test_usage)
    ;
  return finalize(s);
}
#endiv
