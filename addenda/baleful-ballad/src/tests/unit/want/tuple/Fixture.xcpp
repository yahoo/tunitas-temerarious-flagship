// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace want {
      namespace tuple {
        class Fixture;
      }
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::want::tuple::Fixture : public cppunit::test::Fixture {
public:
  auto test_tuple_cat() -> void;
  auto test_tuple_cons1N() -> void;
  auto test_tuple_consN1() -> void;
  auto test_tuple_rest() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import std.move
#import std.tuple
#import std.tuple_cat
auto tests::unit::want::tuple::Fixture::test_tuple_cat() -> void {
  // this is in the standard library ... so test it is specious
  {
    auto r = std::tuple_cat(std::tuple<int>(1), std::tuple<char>('a'), std::tuple<std::string>("puzzle"));
    std::tuple<int, char, std::string> t;
    t = r;
    CPPUNIT_ASSERT(t == r);
  } {
    auto a = std::tuple<int>(1);
    auto b = std::tuple<char>('a');
    auto c = std::tuple<std::string>("puzzle");
    auto r = std::tuple_cat(a, b, c);
    std::tuple<int, char, std::string> t;
    t = r;
    CPPUNIT_ASSERT(t == r);
  } {
    auto a = std::make_tuple(1);
    auto b = std::make_tuple('a');
    auto c = std::make_tuple((std::string)("puzzle"));
    auto r = std::tuple_cat(a, b, c);
    std::tuple<int, char, std::string> t;
    t = r;
    CPPUNIT_ASSERT(t == r);
  }
}

#import std.tuple
#import want.tuple_cons
auto tests::unit::want::tuple::Fixture::test_tuple_cons1N() -> void {
  auto r = ::want::tuple_cons(1, std::tuple<char, std::string>('a', std::string("puzzle")));
  std::tuple<int, char, std::string> t(1, 'a', "puzzle");
  t = r;
  CPPUNIT_ASSERT(t == r);
}

#import std.tuple
#import want.tuple_cons
auto tests::unit::want::tuple::Fixture::test_tuple_consN1() -> void {
  auto r = ::want::tuple_cons(std::tuple<int, char>(1, 'a'), std::string("puzzle"));
  std::tuple<int, char, std::string> t(1, 'a', "puzzle");
  t = r;
  CPPUNIT_ASSERT(t == r);
}

#import std.make_tuple
#import std.get
#import want.tuple_rest
auto tests::unit::want::tuple::Fixture::test_tuple_rest() -> void {
  auto r = std::make_tuple(1, 'a', std::string("puzzle"));
  auto first = std::get<0>(r);
  CPPUNIT_ASSERT(1 == first);
  CPPUNIT_ASSERT(1 == std::get<0>(r));
  CPPUNIT_ASSERT('a' == std::get<1>(r));
  CPPUNIT_ASSERT("puzzle" == std::get<2>(r));
  {
    // debug the testing itself (WATCHOUT -- std::move modifies r
    auto r = std::make_tuple(1, 'a', std::string("puzzle"));
    { auto resc = ::want::tuple_rest(r); 
      CPPUNIT_ASSERT('a' == std::get<0>(resc)); }
    { auto resm = ::want::tuple_rest(std::move(r));
      CPPUNIT_ASSERT('a' == std::get<0>(resm));
      CPPUNIT_ASSERT("puzzle" == std::get<1>(resm)); }
  }
  auto rest = ::want::tuple_rest(r); // <---- fails
  CPPUNIT_ASSERT('a' == std::get<0>(rest));
  CPPUNIT_ASSERT("puzzle" == std::get<1>(rest));
  std::tuple<char, std::string> const expected = std::make_tuple('a', std::string("puzzle"));
  std::tuple<char, std::string> const actual = rest;
  CPPUNIT_ASSERT(expected == actual);
}

#import tests.unit.want.tuple.Rest
#import tests.unit.want.tuple.Rebuilder
auto tests::unit::want::tuple::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("tuple");
  s << call("tuple_cat", &Fixture::test_tuple_cat)
    << call("tuple_cons1N", &Fixture::test_tuple_cons1N)
    << call("tuple_consN1", &Fixture::test_tuple_consN1)
    << call("tuple_rest", &Fixture::test_tuple_rest)
    << add<Rest>()
    << add<Rebuilder>()
    ;
  return finalize(s);
}
#endiv
