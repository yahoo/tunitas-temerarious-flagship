// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace filenames {
      class Fixture;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::filenames::Fixture : public cppunit::test::Fixture {
public:
  auto test_constructor_default() -> void;
  auto test_constructor_1arg_butempty() -> void;
  auto test_constructor_1arg_andfull() -> void;
  auto test_constructor_3arg_empty_empty() -> void;
  auto test_constructor_3arg_empty_full() -> void;
  auto test_constructor_3arg_full_empty() -> void;
  auto test_constructor_3arg_full_full() -> void;
  auto test_ispure() -> void;
  auto test_relativize() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.Phase
#import scold.Suffix
#import scold.Filenames
auto tests::unit::filenames::Fixture::test_constructor_default() -> void {
  ::scold::Filenames f;
  CPPUNIT_ASSERT(f[::scold::Phase::FPP].empty());
  CPPUNIT_ASSERT(f[::scold::Phase::HPP].empty());
  CPPUNIT_ASSERT(f[::scold::Phase::IPP].empty());
  CPPUNIT_ASSERT(f[::scold::Phase::TPP].empty());
  CPPUNIT_ASSERT(f[::scold::Phase::CPP].empty());
  CPPUNIT_ASSERT(f[::scold::Suffix::XCPP].empty());
  CPPUNIT_ASSERT(f[::scold::Suffix::MK].empty());
  CPPUNIT_ASSERT(f[::scold::Suffix::O].empty());
  CPPUNIT_ASSERT(f[::scold::Suffix::LO].empty());
}

#import scold.Module
#import scold.Filenames
auto tests::unit::filenames::Fixture::test_constructor_1arg_butempty() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, ""); // <---------- test this (empty)
  CPPUNIT_ASSERT_EQUAL(std::string("fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.lo"), f[::scold::Suffix::LO]);
}

auto tests::unit::filenames::Fixture::test_constructor_1arg_andfull() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, "/tmp"); // <---------- test this (non-empty)
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/apple/Banana.lo"), f[::scold::Suffix::LO]);
}

#import scold.Module
#import scold.Filenames
auto tests::unit::filenames::Fixture::test_constructor_3arg_empty_empty() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, "", "", "");
  CPPUNIT_ASSERT_EQUAL(std::string("fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.lo"), f[::scold::Suffix::LO]);
}

auto tests::unit::filenames::Fixture::test_constructor_3arg_empty_full() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, "", "", "/usr/src");
  CPPUNIT_ASSERT_EQUAL(std::string("fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/usr/src/apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.lo"), f[::scold::Suffix::LO]);
}

auto tests::unit::filenames::Fixture::test_constructor_3arg_full_empty() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, "/tmp/decl", "/tmp/def", "");
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.lo"), f[::scold::Suffix::LO]);
}

auto tests::unit::filenames::Fixture::test_constructor_3arg_full_full() -> void {
  ::scold::Module m{"apple", "Banana"};
  ::scold::Filenames f;
  f.define(m, "/tmp/decl", "/tmp/def", "/usr/src");
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/fpp/apple.Banana"), f[::scold::Phase::FPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/hpp/apple.Banana"), f[::scold::Phase::HPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/ipp/apple.Banana"), f[::scold::Phase::IPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/decl/apple.Banana"), f[::scold::Phase::TPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.cpp"), f[::scold::Phase::CPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/usr/src/apple/Banana.xcpp"), f[::scold::Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.mk"), f[::scold::Suffix::MK]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.o"), f[::scold::Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(std::string("/tmp/def/apple/Banana.lo"), f[::scold::Suffix::LO]);
}

#import ish.shell.dirname
#import scold.Filenames
#import scold.ispure
#import scold.to
#import std.string
#import sys.posix.mkdirp
#import sys.posix.touch
#import tests.unit.Cleanup
auto tests::unit::filenames::Fixture::test_ispure() -> void {
  using ish::shell::dirname;
  using sys::posix::mkdirp;
  using sys::posix::touch;
  // Need to make a filesystem object to allow force the 'namespace.xcpp' filename
  std::string srcdir = "/tmp/t99.filenames";
  Cleanup<RMDIR> cleanup_srcdir(srcdir);
  {
    ::scold::Module m{"top", "pure"};
    std::string puredir = srcdir + "/top" + "/pure";
    Cleanup<RMDIR> cleanup_top(dirname(puredir));
    Cleanup<RMDIR> cleanup_pure(puredir);
    std::string file_xcpp = puredir + "/namespace.xcpp";
    Cleanup<UNLINK> cleanup_file(file_xcpp);
    CPPUNIT_ASSERT(ok(mkdirp(puredir, 0777)));
    CPPUNIT_ASSERT(ok(touch(file_xcpp, 0666)));
    ::scold::Filenames f = ::scold::to<::scold::Filenames>(m, srcdir);
    auto is = ispure(f); 
    CPPUNIT_ASSERT(is); // <----------------- test this (is pure)
  } {
    ::scold::Module m{"top", "Impure"};
    std::string puredir = srcdir + "/top";
    Cleanup<RMDIR> cleanup_top(dirname(puredir));
    Cleanup<RMDIR> cleanup_pure(puredir);
    std::string file_xcpp = puredir + "/Impure.xcpp";
    Cleanup<UNLINK> cleanup_file(file_xcpp);
    CPPUNIT_ASSERT(ok(mkdirp(puredir, 0777)));
    CPPUNIT_ASSERT(ok(touch(file_xcpp, 0666)));
    ::scold::Filenames f = ::scold::to<::scold::Filenames>(m, srcdir);
    auto is = ispure(f);
    CPPUNIT_ASSERT(!is); // <----------------- test this (not pure)
  }
}

#import scold.Suffix
#import scold.Filenames
#import scold.filenames.relativize
#import scold.to
auto tests::unit::filenames::Fixture::test_relativize() -> void {
  using ::scold::Suffix;
  ::scold::Module module{"apple", "banana", "cherry"};
  std::string modulesdir = "obj/modules";
  std::string objdir = "obj/src";
  std::string srcdir = "src";
  ::scold::Filenames specimen = ::scold::to<::scold::Filenames>(module, modulesdir, objdir, srcdir);
  using s = std::string;
  CPPUNIT_ASSERT_EQUAL(s("obj/modules/fpp/apple.banana.cherry"), specimen[Suffix::FPP]);
  CPPUNIT_ASSERT_EQUAL(s("obj/modules/hpp/apple.banana.cherry"), specimen[Suffix::HPP]);
  CPPUNIT_ASSERT_EQUAL(s("obj/modules/ipp/apple.banana.cherry"), specimen[Suffix::IPP]);
  CPPUNIT_ASSERT_EQUAL(s("obj/modules/apple.banana.cherry"), specimen[Suffix::TPP]);
  CPPUNIT_ASSERT_EQUAL(s("obj/src/apple/banana/cherry.cpp"), specimen[Suffix::CPP]);
  CPPUNIT_ASSERT_EQUAL(s("src/apple/banana/cherry.xcpp"), specimen[Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(s("obj/src/apple/banana/cherry.o"), specimen[Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(s("obj/src/apple/banana/cherry.lo"), specimen[Suffix::LO]);
  CPPUNIT_ASSERT_EQUAL(s("obj/src/apple/banana/cherry.mk"), specimen[Suffix::MK]);
  ::scold::Filenames relspecimen = relativize(specimen, modulesdir, objdir, srcdir);
  CPPUNIT_ASSERT_EQUAL(s("fpp/apple.banana.cherry"), relspecimen[Suffix::FPP]);
  CPPUNIT_ASSERT_EQUAL(s("hpp/apple.banana.cherry"), relspecimen[Suffix::HPP]);
  CPPUNIT_ASSERT_EQUAL(s("ipp/apple.banana.cherry"), relspecimen[Suffix::IPP]);
  CPPUNIT_ASSERT_EQUAL(s("apple.banana.cherry"), relspecimen[Suffix::TPP]);
  CPPUNIT_ASSERT_EQUAL(s("apple/banana/cherry.cpp"), relspecimen[Suffix::CPP]);
  CPPUNIT_ASSERT_EQUAL(s("apple/banana/cherry.xcpp"), relspecimen[Suffix::XCPP]);
  CPPUNIT_ASSERT_EQUAL(s("apple/banana/cherry.o"), relspecimen[Suffix::O]);
  CPPUNIT_ASSERT_EQUAL(s("apple/banana/cherry.lo"), relspecimen[Suffix::LO]);
  CPPUNIT_ASSERT_EQUAL(s("apple/banana/cherry.mk"), relspecimen[Suffix::MK]);
}

auto tests::unit::filenames::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Filenames");
  s << call("constructor-default", &Fixture::test_constructor_default)
    << call("constructor-1arg-butempty", &Fixture::test_constructor_1arg_butempty)
    << call("constructor-1arg-andfull", &Fixture::test_constructor_1arg_andfull)
    << call("constructor-3arg-empty-empty", &Fixture::test_constructor_3arg_empty_empty)
    << call("constructor-3arg-empty-full", &Fixture::test_constructor_3arg_empty_full)
    << call("constructor-3arg-full-empty", &Fixture::test_constructor_3arg_full_empty)
    << call("constructor-3arg-full-full", &Fixture::test_constructor_3arg_full_full)
    << call("ispure", &Fixture::test_ispure)
    << call("relativize", &Fixture::test_relativize)
    ;
  return finalize(s);
}
#endiv
