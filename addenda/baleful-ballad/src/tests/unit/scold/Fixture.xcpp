// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace scold {
      class Fixture;
    }
  }
}
#endiv
#divert <hpp>
#import tests.unit.processor.Contextualization
class tests::unit::scold::Fixture : public cppunit::test::Fixture, processor::Contextualization {
public:
  auto test_Director() -> void;
  auto test_Files() -> void;
  auto test_Quitting() -> void;
  auto test_ispure() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.Accruals.IMPORT
#import scold.Accruals.ENTAIL
#import scold.Director
#import scold.Stream
#import scold.line.Item
auto tests::unit::scold::Fixture::test_Director() -> void {
  using namespace ::scold;
  Director d(cfg, ctx, build_search);
  // it constructed (good)
  line::Item l(45, "int i;");
  auto p = d(l);
  Stream out;
  Accruals<IMPORT> im;
  Accruals<ENTAIL> en;
  ::scold::Accruals<::scold::DEPEND> ds("file.o", "$(modulesdir)", "$(objdir)", "$(srcdir)", "$(DC-COMPILE)", ::scold::Regeneration::TWO_STEP);
  p(Phase::HPP, out, im, en, ds);
}

#import scold.Files
#import scold.Filenames
#import scold.Streams
#import scold.Phase
#import sys.posix.access
#import sys.posix.OK
#import sys.posix.mkdirp
#import slurp.file.read
auto tests::unit::scold::Fixture::test_Files() -> void {
  using namespace sys::posix;
  using sys::posix::mkdirp;
  using sys::posix::access;
  ::scold::Files files;
  ::scold::Module const module{"tests", "unit", "scold", "t99_test_Files"};
  ::scold::Filenames names;
  names.define(module, "t99"); // put the file right here in our unit testing
  CPPUNIT_ASSERT(ok(mkdirp("t99", 0777)));
  CPPUNIT_ASSERT(ok(mkdirp("t99/fpp", 0777)));
  CPPUNIT_ASSERT(ok(mkdirp("t99/hpp", 0777)));
  CPPUNIT_ASSERT(ok(mkdirp("t99/ipp", 0777)));
  CPPUNIT_ASSERT(ok(mkdirp("t99/tests/unit/scold", 0777)));
  // WATCHOUT - if 'trunc' isn't mentioned then the contents are whatever was in the file before.
  files.open(names, std::ios::out | std::ios::trunc);
  // are they all open?
  CPPUNIT_ASSERT(files.is_open());
  // did the files get created?
  CPPUNIT_ASSERT(ok(access(names[::scold::Phase::FPP], sys::posix::OK::EXISTS)));
  CPPUNIT_ASSERT(ok(access(names[::scold::Phase::HPP], sys::posix::OK::EXISTS)));
  CPPUNIT_ASSERT(ok(access(names[::scold::Phase::IPP], sys::posix::OK::EXISTS)));
  CPPUNIT_ASSERT(ok(access(names[::scold::Phase::TPP], sys::posix::OK::EXISTS)));
  CPPUNIT_ASSERT(ok(access(names[::scold::Phase::CPP], sys::posix::OK::EXISTS)));
  ::scold::Streams info;
  using line = ::scold::line::Item;
  info[::scold::Phase::FPP] << line(1, "the fpp stanza");
  info[::scold::Phase::HPP] << line(1, "the hpp stanza");
  info[::scold::Phase::IPP] << line(1, "the ipp stanza");
  info[::scold::Phase::TPP] << line(1, "the tpp stanza");
  info[::scold::Phase::CPP] << line(1, "the cpp stanza");
  // write something
  files << info;
  files.close();
}

#import std.exception
#import std.string
#import scold.exception.Quitting
auto tests::unit::scold::Fixture::test_Quitting() -> void {
  try {
    throw ::scold::exception::Quitting("that was bad");
  } catch (std::exception const &e) {
    std::string const expected = "that was bad";
    std::string const actual = e.what();
    CPPUNIT_ASSERT(expected == actual);
  }
}

#import scold.ispure
auto tests::unit::scold::Fixture::test_ispure() -> void {
  CPPUNIT_ASSERT(!::scold::ispure("./Class.xcpp"));
  CPPUNIT_ASSERT(!::scold::ispure("Class.xcpp"));
  CPPUNIT_ASSERT(::scold::ispure("./namespace.xcpp"));
  CPPUNIT_ASSERT(::scold::ispure("namespace.xcpp"));
}

#import tests.unit.scold.Director
#import tests.unit.scold.Files
auto tests::unit::scold::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("scold");
  s << call("show-Director", &Fixture::test_Director)
    << call("show-Files", &Fixture::test_Files)
    << call("Quitting", &Fixture::test_Quitting)
    << call("ispure", &Fixture::test_ispure)
    << add<Director>()
    << add<Files>()
    ;
  return finalize(s);
}
#endiv
