// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace fragment {
      class Fixture;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::fragment::Fixture : public cppunit::test::Fixture {
public:
  // make
  auto test_declare() -> void;
  auto test_depend() -> void;
  auto test_script_rm() -> void;

  // preproc
  auto test_entail() -> void;
  auto test_forward() -> void;
  auto test_import() -> void;
  auto test_include() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.fragment.workbench
#import scold.Module
#import std.move
#import std.string

#import scold.fragment.make.declare
auto tests::unit::fragment::Fixture::test_declare() -> void {
  //
  // Just test one variant...
  // The rest of the variants and overloads are tested in Declare::suite()
  //
  using ::scold::fragment::workbench;
  std::string lhs_objdir = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto lhs_value = workbench() * lhs_subpath;
  auto actual = ::scold::fragment::make::declare(lhs_objdir, std::move(lhs_value));
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import scold.fragment.make.depend
auto tests::unit::fragment::Fixture::test_depend() -> void {
  //
  // Just test one variant...
  // The rest of the variants and overloads are tested in Depend::suite()
  //
  using ::scold::fragment::workbench;
  std::string lhs_objdir = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto lhs_value = workbench() * lhs_subpath;
  std::string rhs_objdir = "$(rhs_objdir)";
  std::string rhs_subpath = "rhs_subpath";
  auto rhs_value = workbench() * rhs_subpath;
  auto actual = ::scold::fragment::make::depend(lhs_objdir, std::move(lhs_value), rhs_objdir, std::move(rhs_value));
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath : $(rhs_objdir)/rhs_subpath");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import scold.fragment.make.script_rm
auto tests::unit::fragment::Fixture::test_script_rm() -> void {
  std::string qualifier = "src";
  std::string file1 = "apple.o";
  std::string file2 = "banana.o";
  std::string file3 = "cherry.o";
  auto actual = ::scold::fragment::make::script_rm(qualifier, file1, file2, file3); // <----------- test this
  auto expected = ::scold::line::Item(R"expected(	rm -f src/apple.o src/banana.o src/cherry.o)expected");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import scold.fragment.preproc.entail
auto tests::unit::fragment::Fixture::test_entail() -> void {
  ::scold::Module specimen{"apple", "banana", "cherry", "dog"};
  auto actual = ::scold::fragment::preproc::entail(specimen); // <----------- test this
  auto expected = ::scold::line::Item(R"expected(#entail apple.banana.cherry.dog)expected");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual)); 
}

#import scold.fragment.preproc.forward
auto tests::unit::fragment::Fixture::test_forward() -> void {
  ::scold::Module specimen{"apple", "banana", "cherry", "dog"};
  auto actual = ::scold::fragment::preproc::forward(specimen); // <----------- test this
  auto expected = ::scold::line::Item(R"expected(#forward apple.banana.cherry.dog)expected");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import scold.fragment.preproc.import
auto tests::unit::fragment::Fixture::test_import() -> void {
  ::scold::Module specimen{"apple", "banana", "cherry", "dog"};
  auto actual = ::scold::fragment::preproc::import(specimen); // <----------- test this
  auto expected = ::scold::line::Item(R"expected(#import apple.banana.cherry.dog)expected");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import scold.fragment.preproc.include
auto tests::unit::fragment::Fixture::test_include() -> void {
  //
  // Just test one variant...
  // The rest of the variants and overloads are tested in Depend::suite()
  //
  std::string specimen = "apple.banana.cherry.dog";
  auto actual = ::scold::fragment::preproc::include(specimen); // <----------- test this
  auto expected = ::scold::line::Item(R"expected(#include <apple.banana.cherry.dog>)expected");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

#import tests.unit.fragment.Declare
#import tests.unit.fragment.Depend
#import tests.unit.fragment.Script_Rm
#import tests.unit.fragment.Include
#import tests.unit.fragment.Forward
#import tests.unit.fragment.Entail
#import tests.unit.fragment.Import
auto tests::unit::fragment::Fixture::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("fragment");
  s << call("declare-all", &Fixture::test_declare)
    << call("depend-all", &Fixture::test_depend)
    << call("script-rm", &Fixture::test_script_rm)
    << call("entail-some", &Fixture::test_entail)
    << call("forward-some", &Fixture::test_forward)
    << call("import-some", &Fixture::test_import)
    << call("include-some", &Fixture::test_include)
    << add<Declare>()
    << add<Depend>()
    << add<Script_Rm>()
    << add<Include>()
    << add<Forward>()
    << add<Entail>()
    << add<Import>()
    ;
  return finalize(s);
}
#endiv
