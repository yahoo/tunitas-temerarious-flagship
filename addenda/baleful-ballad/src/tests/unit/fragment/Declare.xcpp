// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace fragment {
      class Declare;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::fragment::Declare : public cppunit::test::Fixture {
public:
  auto test_declare_string() -> void;
  auto test_declare_string_string() -> void;
  auto test_declare_string_Value() -> void;

  auto test_declare_string_colon() -> void;
  auto test_declare_string_string_colon() -> void;
  auto test_declare_string_Value_colon() -> void;

  auto test_declare_string_colon_colon() -> void;
  auto test_declare_string_string_colon_colon() -> void;
  auto test_declare_string_Value_colon_colon() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.fragment.workbench
#import scold.fragment.make.declare
#import std.move
#import std.string

auto tests::unit::fragment::Declare::test_declare_string() -> void {
  std::string lhs_value = "$(lhs_objdir)/lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_string() -> void {
  std::string lhs_value = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value, lhs_subpath);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_Value() -> void {
  using scold::fragment::workbench;
  std::string lhs_objdir = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto lhs_value = workbench() * lhs_subpath;
  auto actual = ::scold::fragment::make::declare(lhs_objdir, std::move(lhs_value));
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_colon() -> void {
  std::string lhs_value = "$(lhs_objdir)/lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value, ::scold::fragment::make::Rule::COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_string_colon() -> void {
  std::string lhs_value = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value, lhs_subpath, ::scold::fragment::make::Rule::COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_Value_colon() -> void {
  using scold::fragment::workbench;
  std::string lhs_objdir = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto lhs_value = workbench() * lhs_subpath;
  auto actual = ::scold::fragment::make::declare(lhs_objdir, std::move(lhs_value), ::scold::fragment::make::Rule::COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath :");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_colon_colon() -> void {
  std::string lhs_value = "$(lhs_objdir)/lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value, ::scold::fragment::make::Rule::COLON_COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath ::");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_string_colon_colon() -> void {
  std::string lhs_value = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto actual = ::scold::fragment::make::declare(lhs_value, lhs_subpath, ::scold::fragment::make::Rule::COLON_COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath ::");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::test_declare_string_Value_colon_colon() -> void {
  using scold::fragment::workbench;
  std::string lhs_objdir = "$(lhs_objdir)";
  std::string lhs_subpath = "lhs_subpath";
  auto lhs_value = workbench() * lhs_subpath;
  auto actual = ::scold::fragment::make::declare(lhs_objdir, std::move(lhs_value), ::scold::fragment::make::Rule::COLON_COLON);
  auto expected = ::scold::line::Item("$(lhs_objdir)/lhs_subpath ::");
  CPPUNIT_ASSERT_EQUAL(value(expected), value(actual));
}

auto tests::unit::fragment::Declare::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("declare");
  s << call("string", &Declare::test_declare_string)
    << call("string_string", &Declare::test_declare_string_string)
    << call("string-Value", &Declare::test_declare_string_Value)

    << call("string-:", &Declare::test_declare_string_colon)
    << call("string_string-:", &Declare::test_declare_string_string_colon)
    << call("string-Value-:", &Declare::test_declare_string_Value_colon)

    << call("string-::", &Declare::test_declare_string_colon_colon)
    << call("string_string-::", &Declare::test_declare_string_string_colon_colon)
    << call("string-Value-::", &Declare::test_declare_string_Value_colon_colon)
    ;
  return finalize(s);
}
#endiv
