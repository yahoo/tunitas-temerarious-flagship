// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests::unit::version { class String; }
#endiv
#divert <hpp>
class tests::unit::version::String : public cppunit::test::Fixture {
public:
  auto test_constructor() -> void;
  auto test_size() -> void;
  auto test_operator_insert() -> void;
  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.version.String
#import nonstd.regex.Pattern
#import nonstd.regex.match
namespace tests::unit::version {
  auto String::test_constructor() -> void {
    using Subject = ::scold::version::String;
    auto subject = Subject{};
    CPPUNIT_ASSERT(sizeof (subject)); // yes it constructed
  }
  auto String::test_size() -> void {
    using Subject = ::scold::version::String;
    auto subject = Subject{};
    CPPUNIT_ASSERT_EQUAL(3lu, subject.size());
    // Must be greater than v0.0.0
    auto all_three_digits_are_zero = (0 == subject.at(0) &&
                                      0 == subject.at(1) &&
                                      0 == subject.at(2));
    CPPUNIT_ASSERT( !all_three_digits_are_zero );
  }
  auto String::test_operator_insert() -> void {
      using Subject = ::scold::version::String;
      auto const syntax = []() {
                            std::ostringstream buf;
                            buf << Subject{}; // <----------------- test this
                            return buf.str();
                          }();
    nonstd::regex::Pattern expected{R"regex(^v\d+\.\d+\.\d+$)regex"};
    auto matched = nonstd::regex::match(syntax, expected);
    CPPUNIT_ASSERT(matched);
  }
}
auto tests::unit::version::String::suite() -> cppunit::Test * {
  using namespace ::rigging::suite;
  Stream series("version");
  series << call("constructor", &String::test_constructor)
         << call("size", &String::test_size)
         << call("operator<<", &String::test_operator_insert)
    ;
  return finalize(series);
}
#endiv
