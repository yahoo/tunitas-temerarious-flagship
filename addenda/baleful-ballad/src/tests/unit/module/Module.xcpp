// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace module {
      class Module;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::module::Module : public cppunit::test::Fixture {
public:
  auto test_constructor() -> void;
  auto test_operator_eq() -> void;
  auto test_operator_ne() -> void;
  auto test_operator_insert() -> void;
  auto test_operator_extract() -> void;
  auto test_to_1arg() -> void;
  auto test_to_2arg() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.module.Module
auto tests::unit::module::Module::test_constructor() -> void {
  ::scold::module::Module m;
  // Yup, it constructs.
  CPPUNIT_ASSERT(m.empty());
}

auto tests::unit::module::Module::test_operator_eq() -> void {
  ::scold::module::Module m, n;
  CPPUNIT_ASSERT(m == n);
  ::scold::module::Module mm{"com", "example", "code", "Class"};
  ::scold::module::Module nn{"com", "example", "rude", "Class"};
  ::scold::module::Module oo{"org", "sample", "hope", "springs", "eternal," "Class"};
  CPPUNIT_ASSERT(mm == mm);
  CPPUNIT_ASSERT( !(mm == nn) );
  CPPUNIT_ASSERT( !(nn == oo) );
}

auto tests::unit::module::Module::test_operator_ne() -> void {
  ::scold::module::Module m, n;
  CPPUNIT_ASSERT( ! (m != n) );
  ::scold::module::Module mm{"com", "example", "code", "Class"};
  ::scold::module::Module nn{"com", "example", "rude", "Class"};
  CPPUNIT_ASSERT(mm != nn);
  CPPUNIT_ASSERT(m != nn);
  CPPUNIT_ASSERT(mm != n);
}

#import std.ostringstream
#import std.string
auto tests::unit::module::Module::test_operator_insert() -> void {
  ::scold::module::Module m{"apple", "banana", "cherry", "Dog"};
  std::ostringstream buf;
  buf << m;
  std::string const expected = "apple.banana.cherry.Dog";
  std::string const actual = buf.str();
  CPPUNIT_ASSERT(expected == actual);
}

#import std.istringstream
#import std.string
auto tests::unit::module::Module::test_operator_extract() -> void {
  std::string const specimen = "apple.banana.cherry.Dog";
  std::istringstream ibuf(specimen);
  std::string actual;
  if (ibuf >> actual) {
    CPPUNIT_ASSERT(specimen == actual); 
  } else {
    CPPUNIT_ASSERT(false);
  }
}

#import scold.Module
#import scold.to
auto tests::unit::module::Module::test_to_1arg() -> void {
  std::string const filename = "apple/banana/cherry/Dog.cpp";
  ::scold::module::Module m = ::scold::to<::scold::module::Module>(filename); // <------------------------------ test this
  std::ostringstream buf;
  buf << m;
  std::string const expected = "apple.banana.cherry.Dog";
  std::string const actual = buf.str();
  CPPUNIT_ASSERT(expected == actual);
}

auto tests::unit::module::Module::test_to_2arg() -> void {
  std::string const filename = "/views/git/working/area/apple/banana/cherry/Dog.cpp";
  ::scold::module::Module m = ::scold::to<::scold::module::Module>(filename, "/views/git/working/area"); // <----- test this
  std::ostringstream buf;
  buf << m;
  std::string const expected = "apple.banana.cherry.Dog";
  std::string const actual = buf.str();
  CPPUNIT_ASSERT(expected == actual);
}

auto tests::unit::module::Module::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Module");
  s << call("constructor", &Module::test_constructor)
    << call("operator==", &Module::test_operator_eq)
    << call("operator!=", &Module::test_operator_ne)
    << call("operator<<", &Module::test_operator_insert)
    << call("operator>>", &Module::test_operator_extract)
    << call("to-1arg", &Module::test_to_1arg)
    << call("to-2arg", &Module::test_to_2arg)
    ;
  return finalize(s);
}
#endiv
