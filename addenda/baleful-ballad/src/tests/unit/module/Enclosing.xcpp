// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace module {
      class Enclosing;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::module::Enclosing : public cppunit::test::Fixture {
public:
  auto test_Result() -> void;
  auto test_send() -> void;
  auto test_recv() -> void;
  auto test_global() -> void;
  auto test_value_reference() -> void;
  auto test_value_move() -> void;
  auto test_function_copy() -> void;
  auto test_function_move() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.module.enclosing

auto tests::unit::module::Enclosing::test_Result() -> void {
  using s = std::string;
  using m = ::scold::module::Module;
  {
    ::scold::module::detail::enclosing::Result r;
    // Whee! it constructs
    CPPUNIT_ASSERT(true);
  } {
    auto adl = ::scold::module::detail::enclosing::ADL();
    scold::Module mod{"thing"};
    ::scold::module::detail::enclosing::Result r(adl, true, mod);
    CPPUNIT_ASSERT(global(r));
    CPPUNIT_ASSERT_EQUAL(m{"thing"}, value(r));
  } {
    auto adl = ::scold::module::detail::enclosing::ADL();
    scold::Module mod{"internet", "of", "thingies"};
    ::scold::module::detail::enclosing::Result r(adl, false, mod);
    CPPUNIT_ASSERT(!global(r));
    CPPUNIT_ASSERT(3 == value(r).size());
    CPPUNIT_ASSERT_EQUAL(s("internet"), value(r)[0]);
    CPPUNIT_ASSERT_EQUAL(s("of"), value(r)[1]);
    CPPUNIT_ASSERT_EQUAL(s("thingies"), value(r)[2]);
  }
}

#import mvr.send
#import mvr.recv
auto tests::unit::module::Enclosing::test_send() -> void {
  auto adl = ::scold::module::detail::enclosing::ADL();
  ::scold::Module mod{"internet", "of", "thingies"};
  ::scold::module::detail::enclosing::Result r0(adl, false, mod);
  {
    ::scold::module::detail::enclosing::Result rr;
    mvr::recv(rr) = mvr::send(r0);// <--------- test this
    CPPUNIT_ASSERT_EQUAL(std::get<0>(rr), adl);
    CPPUNIT_ASSERT_EQUAL(std::get<1>(rr), false);
    CPPUNIT_ASSERT_EQUAL(std::get<2>(rr), mod);
  }
}

auto tests::unit::module::Enclosing::test_recv() -> void {
  // tested above in test_send()
  CPPUNIT_ASSERT(true);
}

auto tests::unit::module::Enclosing::test_global() -> void {
  auto adl = ::scold::module::detail::enclosing::ADL();
  ::scold::Module mod{"internet", "of", "thingies"};
  ::scold::module::detail::enclosing::Result r0(adl, false, mod);
  CPPUNIT_ASSERT(!global(r0)); // <---- test this
  ::scold::module::detail::enclosing::Result r1(adl, true, mod);
  CPPUNIT_ASSERT(global(r1)); // <---- test this
}

auto tests::unit::module::Enclosing::test_value_reference() -> void {
  using s = std::string;
  auto adl = ::scold::module::detail::enclosing::ADL();
  ::scold::Module mod{"internet", "of", "thingies"};
  ::scold::module::detail::enclosing::Result r(adl, false, mod);
  CPPUNIT_ASSERT(!global(r));
  CPPUNIT_ASSERT(3 == value(r).size());
  CPPUNIT_ASSERT_EQUAL(s("internet"), value(r)[0]);
  CPPUNIT_ASSERT_EQUAL(s("of"), value(r)[1]);
  CPPUNIT_ASSERT_EQUAL(s("thingies"), value(r)[2]);
  ::scold::Module const &remod = value(r); // <------------ test this
  CPPUNIT_ASSERT(3 == remod.size());
  CPPUNIT_ASSERT_EQUAL(s("internet"), remod[0]);
  CPPUNIT_ASSERT_EQUAL(s("of"), remod[1]);
  CPPUNIT_ASSERT_EQUAL(s("thingies"), remod[2]);
}

auto tests::unit::module::Enclosing::test_value_move() -> void {
  using s = std::string;
  auto adl = ::scold::module::detail::enclosing::ADL();
  ::scold::Module mod{"internet", "of", "thingies"};
  ::scold::module::detail::enclosing::Result r(adl, false, mod);
  CPPUNIT_ASSERT(!global(r));
  CPPUNIT_ASSERT(3 == value(r).size());
  CPPUNIT_ASSERT_EQUAL(s("internet"), value(r)[0]);
  CPPUNIT_ASSERT_EQUAL(s("of"), value(r)[1]);
  CPPUNIT_ASSERT_EQUAL(s("thingies"), value(r)[2]);
  ::scold::Module remod = value(std::move(r)); // <------------ test this
  CPPUNIT_ASSERT(3 == remod.size());
  CPPUNIT_ASSERT_EQUAL(s("internet"), remod[0]);
  CPPUNIT_ASSERT_EQUAL(s("of"), remod[1]);
  CPPUNIT_ASSERT_EQUAL(s("thingies"), remod[2]);
}

auto tests::unit::module::Enclosing::test_function_copy() -> void {
  using std::string;
  std::string srcdir = "./src";
  {
    ::scold::module::Module empty;
    auto e = enclosing(empty, srcdir);
    CPPUNIT_ASSERT(global(e));
    CPPUNIT_ASSERT(value(e).empty());
  } {
    ::scold::module::Module one{"one"};
    auto e = enclosing(one, srcdir);
    CPPUNIT_ASSERT(global(e));
    CPPUNIT_ASSERT(value(e).empty());
  } {
    ::scold::module::Module two{"one", "two"};
    auto e = enclosing(two, srcdir);
    CPPUNIT_ASSERT(1 == value(e).size());
    using s = std::string;
    CPPUNIT_ASSERT(!global(e));
    CPPUNIT_ASSERT_EQUAL(s("one"), value(e)[0]);
  } {
    ::scold::module::Module three{"one", "two", "three"};
    auto e = enclosing(three, srcdir);
    CPPUNIT_ASSERT(2 == value(e).size());
    using s = std::string;
    CPPUNIT_ASSERT(!global(e));
    CPPUNIT_ASSERT_EQUAL(s("one"), value(e)[0]);
    CPPUNIT_ASSERT_EQUAL(s("two"), value(e)[1]);
  }
}

auto tests::unit::module::Enclosing::test_function_move() -> void {
   std::string srcdir = "./src";
  ::scold::module::Module four{"one", "two", "three", "four"};
  auto e = enclosing(std::move(four), srcdir);
  CPPUNIT_ASSERT(3 == value(e).size());
  using s = std::string;
  CPPUNIT_ASSERT_EQUAL(s("one"), value(e)[0]);
  CPPUNIT_ASSERT_EQUAL(s("two"), value(e)[1]);
  CPPUNIT_ASSERT_EQUAL(s("three"), value(e)[2]);
}

auto tests::unit::module::Enclosing::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("enclosing");
  s << call("Result", &Enclosing::test_Result)
    << call("send", &Enclosing::test_send)
    << call("recv", &Enclosing::test_recv)
    << call("global", &Enclosing::test_global)
    << call("value-reference", &Enclosing::test_value_reference)
    << call("value-move", &Enclosing::test_value_move)
    << call("function-copy", &Enclosing::test_function_copy)
    << call("function-move", &Enclosing::test_function_move)
    ;
  return finalize(s);
}
#endiv
