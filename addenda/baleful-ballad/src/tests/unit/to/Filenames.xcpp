// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace to {
      class Filenames;
    }
  }
}
#endiv
#divert <hpp>
#import scold.Filenames
#import scold.Phase
#import scold.Suffix
class tests::unit::to::Filenames : public cppunit::test::Fixture {
public:
  auto test_1arg_Module() -> void;
  auto test_1arg_string() -> void;
  auto test_2arg_Module() -> void;
  auto test_2arg_string() -> void;
  auto test_3arg_Module() -> void;
  auto test_3arg_string() -> void;

  static auto suite() -> cppunit::Test *;
  using S = ::scold::Suffix;
  using P = ::scold::Phase;
protected:
  static auto dump(::scold::Filenames const &, char const *function, char const *file, int line) -> void;
};
#endiv
#divert <cpp>
#import scold.Filenames
#import scold.Module
#import scold.Phase
#import scold.phase.sequence
#import scold.Suffix
#import scold.to
#import std.cout
#import std.cerr

auto tests::unit::to::Filenames::dump(::scold::Filenames const &f, char const *function, char const *file, int line) -> void {
  std::cerr << function << ' ' << file << ':' << line;
  for (auto p : ::scold::phase::sequence()) {
    std::cerr << "\n" << p << '=' << f[p];
  }
  std::cerr << "\n" << S::XCPP << '=' << f[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_1arg_Module() -> void {
  using ss = std::string;
  ::scold::Module const module{"apple", "banana", "cherry"};
  auto r = ::scold::to<::scold::Filenames>(module);
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("fpp/apple.banana.cherry"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("hpp/apple.banana.cherry"), r[P::HPP]);
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("ipp/apple.banana.cherry"), r[P::IPP]);
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("apple.banana.cherry"), r[P::TPP]);
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("apple/banana/cherry.cpp"), r[P::CPP]);
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("apple/banana/cherry.xcpp"), r[S::XCPP]);
  CPPUNIT_ASSERT_EQUAL(ss("apple/banana/cherry.mk"), r[S::MK]);
  CPPUNIT_ASSERT_EQUAL(ss("apple/banana/cherry.o"), r[S::O]);
  CPPUNIT_ASSERT_EQUAL(ss("apple/banana/cherry.lo"), r[S::LO]);
  std::cout << "1arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_1arg_string() -> void {
  using ss = std::string;
  ss xcpp("system/subsystem/package/Class.xcpp");
  auto r = ::scold::to<::scold::Filenames>(xcpp);
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("fpp/system.subsystem.package.Class"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("system/subsystem/package/Class.xcpp"), r[S::XCPP]);
  std::cout << "1arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_2arg_Module() -> void {
  using ss = std::string;
  ::scold::Module const module{"apple", "banana", "cherry"};
  auto r = ::scold::to<::scold::Filenames>(module, "/home/work");
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/home/work/fpp/apple.banana.cherry"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/home/work/apple/banana/cherry.xcpp"), r[S::XCPP]);
  std::cout << "2arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_2arg_string() -> void {
  using ss = std::string;
  ::std::string const xcpp("system/subsystem/package/Class.xcpp");
  auto r = ::scold::to<::scold::Filenames>(xcpp, "/views/work/goodness");
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/views/work/goodness/fpp/system.subsystem.package.Class"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/views/work/goodness/system/subsystem/package/Class.xcpp"), r[S::XCPP]);
  std::cout << "2arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_3arg_Module() -> void {
  using ss = std::string;
  ::scold::Module const module{"apple", "banana", "cherry"};
  auto r = ::scold::to<::scold::Filenames>(module, "/var/tmp/modules", "/var/tmp/obj", "/src/work/home/self");
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/var/tmp/modules/fpp/apple.banana.cherry"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/src/work/home/self/apple/banana/cherry.xcpp"), r[S::XCPP]);
  std::cout << "3arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::test_3arg_string() -> void {
  using ss = std::string;
  ::std::string const xcpp("system/subsystem/package/Class.xcpp");
  auto r = ::scold::to<::scold::Filenames>(xcpp, "/temporary/work/modules", "/temporary/work/obj", "/permanent/source");
  dump(r, __FUNCTION__, __FILE__, __LINE__);
  CPPUNIT_ASSERT_EQUAL(ss("/temporary/work/modules/fpp/system.subsystem.package.Class"), r[P::FPP]);
  CPPUNIT_ASSERT(!r[P::FPP].empty());
  CPPUNIT_ASSERT(!r[P::HPP].empty());
  CPPUNIT_ASSERT(!r[P::IPP].empty());
  CPPUNIT_ASSERT(!r[P::TPP].empty());
  CPPUNIT_ASSERT(!r[P::CPP].empty());
  CPPUNIT_ASSERT(!r[S::XCPP].empty());
  CPPUNIT_ASSERT_EQUAL(ss("/permanent/source/system/subsystem/package/Class.xcpp"), r[S::XCPP]);
  std::cout << "3arg r=" << r[S::XCPP] << '\n';
}

auto tests::unit::to::Filenames::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("to<Filename>");
  s << call("1-arg Module", &Filenames::test_1arg_Module)
    << call("1-arg string", &Filenames::test_1arg_string)
    << call("2-arg Module", &Filenames::test_2arg_Module)
    << call("2-arg string", &Filenames::test_2arg_string)
    << call("3-arg Module", &Filenames::test_3arg_Module)
    << call("3-arg string", &Filenames::test_3arg_string)
    ;
  return finalize(s);
}
#endiv
