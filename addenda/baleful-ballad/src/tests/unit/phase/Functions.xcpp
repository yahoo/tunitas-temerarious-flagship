// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace phase {
      class Functions;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::phase::Functions : public cppunit::test::Fixture {
public:
  auto test_declaration() -> void;
  auto test_succ() -> void;
  auto test_pred() -> void;
  auto test_lt() -> void;
  auto test_le() -> void;
  auto test_gt() -> void;
  auto test_ge() -> void;
  auto test_eq() -> void;
  auto test_ne() -> void;
  auto test_min() -> void;
  auto test_max() -> void;
  auto test_operator_insert() -> void;
  auto test_operator_extract_good() -> void;
  auto test_operator_extract_fail() -> void;
  auto test_operator_extract_throwing() -> void;
  auto test_operator_mul_string_Phase() -> void;
  auto test_operator_mul_Module_Phase() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.Phase
auto tests::unit::phase::Functions::test_declaration() -> void {
  ::scold::phase::Phase p;
  p = ::scold::phase::Phase::BEG;
  p = ::scold::phase::Phase::FPP;
  CPPUNIT_ASSERT(::scold::phase::Phase::FPP == p);
}

auto tests::unit::phase::Functions::test_succ() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::succ;
  CPPUNIT_ASSERT(p::FPP == succ(p::BEG));
  CPPUNIT_ASSERT(p::HPP == succ(p::FPP));
  CPPUNIT_ASSERT(p::IPP == succ(p::HPP));
  CPPUNIT_ASSERT(p::TPP == succ(p::IPP));
  CPPUNIT_ASSERT(p::CPP == succ(p::TPP));
  CPPUNIT_ASSERT(p::END == succ(p::CPP));
}

auto tests::unit::phase::Functions::test_pred() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::pred;
  CPPUNIT_ASSERT(p::BEG == pred(p::FPP));
  CPPUNIT_ASSERT(p::FPP == pred(p::HPP));
  CPPUNIT_ASSERT(p::HPP == pred(p::IPP));
  CPPUNIT_ASSERT(p::IPP == pred(p::TPP));
  CPPUNIT_ASSERT(p::TPP == pred(p::CPP));
  CPPUNIT_ASSERT(p::CPP == pred(p::END));
}

auto tests::unit::phase::Functions::test_lt() -> void {
  using p = ::scold::Phase;
  using ::scold::phase::lt;
  CPPUNIT_ASSERT(lt(p::BEG, p::FPP));
  CPPUNIT_ASSERT(lt(p::FPP, p::HPP));
  CPPUNIT_ASSERT(lt(p::HPP, p::IPP));
  CPPUNIT_ASSERT(lt(p::IPP, p::TPP));
  CPPUNIT_ASSERT(lt(p::TPP, p::CPP));
  CPPUNIT_ASSERT(lt(p::CPP, p::END));

  CPPUNIT_ASSERT(!lt(p::BEG, p::BEG));
  CPPUNIT_ASSERT(!lt(p::FPP, p::FPP));
  CPPUNIT_ASSERT(!lt(p::HPP, p::HPP));
  CPPUNIT_ASSERT(!lt(p::IPP, p::IPP));
  CPPUNIT_ASSERT(!lt(p::TPP, p::TPP));
  CPPUNIT_ASSERT(!lt(p::CPP, p::CPP));

  CPPUNIT_ASSERT(!lt(p::FPP, p::BEG));
  CPPUNIT_ASSERT(!lt(p::HPP, p::FPP));
  CPPUNIT_ASSERT(!lt(p::IPP, p::HPP));
  CPPUNIT_ASSERT(!lt(p::TPP, p::IPP));
  CPPUNIT_ASSERT(!lt(p::CPP, p::TPP));
  CPPUNIT_ASSERT(!lt(p::END, p::CPP));
}

auto tests::unit::phase::Functions::test_le() -> void {
  using p = ::scold::Phase;
  using ::scold::phase::le;
  CPPUNIT_ASSERT(le(p::BEG, p::FPP));
  CPPUNIT_ASSERT(le(p::FPP, p::HPP));
  CPPUNIT_ASSERT(le(p::HPP, p::IPP));
  CPPUNIT_ASSERT(le(p::IPP, p::TPP));
  CPPUNIT_ASSERT(le(p::TPP, p::CPP));
  CPPUNIT_ASSERT(le(p::CPP, p::END));

  CPPUNIT_ASSERT(le(p::BEG, p::BEG));
  CPPUNIT_ASSERT(le(p::FPP, p::FPP));
  CPPUNIT_ASSERT(le(p::HPP, p::HPP));
  CPPUNIT_ASSERT(le(p::IPP, p::IPP));
  CPPUNIT_ASSERT(le(p::TPP, p::TPP));
  CPPUNIT_ASSERT(le(p::CPP, p::CPP));

  CPPUNIT_ASSERT(!le(p::FPP, p::BEG));
  CPPUNIT_ASSERT(!le(p::HPP, p::FPP));
  CPPUNIT_ASSERT(!le(p::IPP, p::HPP));
  CPPUNIT_ASSERT(!le(p::TPP, p::IPP));
  CPPUNIT_ASSERT(!le(p::CPP, p::TPP));
  CPPUNIT_ASSERT(!le(p::END, p::CPP));
}

auto tests::unit::phase::Functions::test_gt() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::gt;
  CPPUNIT_ASSERT(gt(p::FPP, p::BEG));
  CPPUNIT_ASSERT(gt(p::HPP, p::FPP));
  CPPUNIT_ASSERT(gt(p::IPP, p::HPP));
  CPPUNIT_ASSERT(gt(p::TPP, p::IPP));
  CPPUNIT_ASSERT(gt(p::CPP, p::TPP));
  CPPUNIT_ASSERT(gt(p::END, p::CPP));

  CPPUNIT_ASSERT(!gt(p::BEG, p::BEG));
  CPPUNIT_ASSERT(!gt(p::FPP, p::FPP));
  CPPUNIT_ASSERT(!gt(p::HPP, p::HPP));
  CPPUNIT_ASSERT(!gt(p::IPP, p::IPP));
  CPPUNIT_ASSERT(!gt(p::TPP, p::TPP));
  CPPUNIT_ASSERT(!gt(p::CPP, p::CPP));

  CPPUNIT_ASSERT(!gt(p::BEG, p::FPP));
  CPPUNIT_ASSERT(!gt(p::FPP, p::HPP));
  CPPUNIT_ASSERT(!gt(p::HPP, p::IPP));
  CPPUNIT_ASSERT(!gt(p::IPP, p::TPP));
  CPPUNIT_ASSERT(!gt(p::TPP, p::CPP));
  CPPUNIT_ASSERT(!gt(p::CPP, p::END));
}

auto tests::unit::phase::Functions::test_ge() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::ge;
  CPPUNIT_ASSERT(ge(p::FPP, p::BEG));
  CPPUNIT_ASSERT(ge(p::HPP, p::FPP));
  CPPUNIT_ASSERT(ge(p::IPP, p::HPP));
  CPPUNIT_ASSERT(ge(p::TPP, p::IPP));
  CPPUNIT_ASSERT(ge(p::CPP, p::TPP));
  CPPUNIT_ASSERT(ge(p::END, p::CPP));

  CPPUNIT_ASSERT(ge(p::BEG, p::BEG));
  CPPUNIT_ASSERT(ge(p::FPP, p::FPP));
  CPPUNIT_ASSERT(ge(p::HPP, p::HPP));
  CPPUNIT_ASSERT(ge(p::IPP, p::IPP));
  CPPUNIT_ASSERT(ge(p::TPP, p::TPP));
  CPPUNIT_ASSERT(ge(p::CPP, p::CPP));

  CPPUNIT_ASSERT(!ge(p::BEG, p::FPP));
  CPPUNIT_ASSERT(!ge(p::FPP, p::HPP));
  CPPUNIT_ASSERT(!ge(p::HPP, p::IPP));
  CPPUNIT_ASSERT(!ge(p::IPP, p::TPP));
  CPPUNIT_ASSERT(!ge(p::TPP, p::CPP));
  CPPUNIT_ASSERT(!ge(p::CPP, p::END));
}

auto tests::unit::phase::Functions::test_eq() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::eq;
  CPPUNIT_ASSERT(eq(p::BEG, p::BEG));
  CPPUNIT_ASSERT(eq(p::FPP, p::FPP));
  CPPUNIT_ASSERT(eq(p::HPP, p::HPP));
  CPPUNIT_ASSERT(eq(p::IPP, p::IPP));
  CPPUNIT_ASSERT(eq(p::TPP, p::TPP));
  CPPUNIT_ASSERT(eq(p::CPP, p::CPP));

  CPPUNIT_ASSERT(!eq(p::BEG, p::FPP));
  CPPUNIT_ASSERT(!eq(p::FPP, p::HPP));
  CPPUNIT_ASSERT(!eq(p::HPP, p::IPP));
  CPPUNIT_ASSERT(!eq(p::IPP, p::TPP));
  CPPUNIT_ASSERT(!eq(p::TPP, p::CPP));
  CPPUNIT_ASSERT(!eq(p::CPP, p::END));
}

auto tests::unit::phase::Functions::test_ne() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::ne;
  CPPUNIT_ASSERT(!ne(p::BEG, p::BEG));
  CPPUNIT_ASSERT(!ne(p::FPP, p::FPP));
  CPPUNIT_ASSERT(!ne(p::HPP, p::HPP));
  CPPUNIT_ASSERT(!ne(p::IPP, p::IPP));
  CPPUNIT_ASSERT(!ne(p::TPP, p::TPP));
  CPPUNIT_ASSERT(!ne(p::CPP, p::CPP));

  CPPUNIT_ASSERT(ne(p::BEG, p::FPP));
  CPPUNIT_ASSERT(ne(p::FPP, p::HPP));
  CPPUNIT_ASSERT(ne(p::HPP, p::IPP));
  CPPUNIT_ASSERT(ne(p::IPP, p::TPP));
  CPPUNIT_ASSERT(ne(p::TPP, p::CPP));
  CPPUNIT_ASSERT(ne(p::CPP, p::END));
}

auto tests::unit::phase::Functions::test_min() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::min;
  CPPUNIT_ASSERT(p::BEG == max(p::BEG, p::BEG));
  CPPUNIT_ASSERT(p::FPP == min(p::FPP, p::FPP));
  CPPUNIT_ASSERT(p::HPP == min(p::HPP, p::HPP));
  CPPUNIT_ASSERT(p::IPP == min(p::IPP, p::IPP));
  CPPUNIT_ASSERT(p::TPP == min(p::TPP, p::TPP));
  CPPUNIT_ASSERT(p::CPP == min(p::CPP, p::CPP));

  CPPUNIT_ASSERT(p::BEG == min(p::BEG, p::FPP));
  CPPUNIT_ASSERT(p::FPP == min(p::FPP, p::HPP));
  CPPUNIT_ASSERT(p::HPP == min(p::HPP, p::IPP));
  CPPUNIT_ASSERT(p::IPP == min(p::IPP, p::TPP));
  CPPUNIT_ASSERT(p::TPP == min(p::TPP, p::CPP));
  CPPUNIT_ASSERT(p::CPP == min(p::CPP, p::END));
}

auto tests::unit::phase::Functions::test_max() -> void {
  using p = ::scold::phase::Phase;
  using ::scold::phase::max;
  CPPUNIT_ASSERT(p::BEG == max(p::BEG, p::BEG));
  CPPUNIT_ASSERT(p::FPP == max(p::FPP, p::FPP));
  CPPUNIT_ASSERT(p::HPP == max(p::HPP, p::HPP));
  CPPUNIT_ASSERT(p::IPP == max(p::IPP, p::IPP));
  CPPUNIT_ASSERT(p::TPP == max(p::TPP, p::TPP));
  CPPUNIT_ASSERT(p::CPP == max(p::CPP, p::CPP));

  CPPUNIT_ASSERT(p::FPP == max(p::BEG, p::FPP));
  CPPUNIT_ASSERT(p::HPP == max(p::FPP, p::HPP));
  CPPUNIT_ASSERT(p::IPP == max(p::HPP, p::IPP));
  CPPUNIT_ASSERT(p::TPP == max(p::IPP, p::TPP));
  CPPUNIT_ASSERT(p::CPP == max(p::TPP, p::CPP));
  CPPUNIT_ASSERT(p::END == max(p::CPP, p::END));
}

#import std.ostringstream
auto tests::unit::phase::Functions::test_operator_insert() -> void {
  using scold::phase::Phase;
  std::ostringstream buf;
  buf << Phase::FPP << '.' << Phase::HPP << '.' << Phase::IPP << '.' << Phase::TPP << '.' << Phase::CPP;
  std::string const expected = "fpp.hpp.ipp.tpp.cpp";
  std::string const actual = buf.str();
  CPPUNIT_ASSERT(expected == actual);
}

#import std.istringstream 
auto tests::unit::phase::Functions::test_operator_extract_good() -> void {
  std::istringstream ibuf("fpp hpp ipp tpp cpp");
  using scold::phase::Phase;
  Phase fpp, hpp, ipp, tpp, cpp;
  ibuf >> fpp >> hpp >> ipp >> tpp >> cpp;;
  CPPUNIT_ASSERT(Phase::FPP == fpp);
  CPPUNIT_ASSERT(Phase::HPP == hpp);
  CPPUNIT_ASSERT(Phase::IPP == ipp);
  CPPUNIT_ASSERT(Phase::TPP == tpp);
  CPPUNIT_ASSERT(Phase::CPP == cpp);
}

auto tests::unit::phase::Functions::test_operator_extract_fail() -> void {
  std::istringstream ibuf("fpp hpp ipp tpp cpp FAIL fpp");
  using scold::phase::Phase;
  Phase fpp, hpp, ipp, tpp, cpp, fail, fpp2;
  ibuf >> fpp >> hpp >> ipp >> tpp >> cpp >> fail >> fpp2;
  CPPUNIT_ASSERT(Phase::FPP == fpp);
  CPPUNIT_ASSERT(Phase::HPP == hpp);
  CPPUNIT_ASSERT(Phase::IPP == ipp);
  CPPUNIT_ASSERT(Phase::TPP == tpp);
  CPPUNIT_ASSERT(Phase::CPP == cpp);
  CPPUNIT_ASSERT(ibuf.fail());
}

#import std.cerr
#import std.type_info
auto tests::unit::phase::Functions::test_operator_extract_throwing() -> void {
  std::istringstream ibuf("fpp hpp ipp tpp cpp FAIL fpp");
  try {
    ibuf.exceptions(std::ios::failbit);
    using scold::phase::Phase;
    Phase fpp, hpp, ipp, tpp, cpp, fail, fpp2;
    ibuf >> fpp >> hpp >> ipp >> tpp >> cpp >> fail >> fpp2;
    CPPUNIT_ASSERT(false);
  } catch (std::ios::failure const &e) {
    std::cerr << "#1 (GOOD) caught " << typeid(e).name() << " saying q(" << e.what() << ")\n";
    CPPUNIT_ASSERT(true);
  } catch (std::exception const &e) {
    // This isn't supposed to happen.
    // But it happens because libstdc++ is not compiled in C++11 mode.
    // It happens because cxxabiv1::__cxa_throw does not throw what is in the public header files
    // ... instead it throws c++03-type stuff (std::ios_base::failure)
    //     which does not inherit from std::system_error, but rather inherits directly from std::exception
    //
    // To Wit:
    //    #0  __cxxabiv1::__cxa_throw (obj=obj@entry=0x7caac0, tinfo=0x7ffff7572700 <typeinfo for std::ios_base::failure>, dest=0x7ffff7297af0 <std::ios_base::failure::~failure()>) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:63
    //    #1  0x00007ffff72b1176 in std::__throw_ios_failure (__s=__s@entry=0x7ffff733a127 "basic_ios::clear") at ../../../../../libstdc++-v3/src/c++11/functexcept.cc:126
    //    #2  0x00007ffff72ef74d in std::basic_ios<char, std::char_traits<char> >::clear (this=<optimized out>, __state=<optimized out>) at /usr/src/debug/gcc-6.2.1-20160916/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_ios.tcc:48
    //    #3  0x00000000005230d2 in scold::operator>> (in=..., fill=@0x7fffffffd6d8: 8169120) at src/scold/Phase.xcpp:126
    //
    std::cerr << "#2 (BAD) caught " << typeid(e).name() << " saying q(" << e.what() << ")\n";
    //
    // Blick ... This isn't supposed to happen, but we treat it as a success case (our workaround).
    //
    CPPUNIT_ASSERT(true);
  }
  CPPUNIT_ASSERT(ibuf.fail());
}

#import scold.phase.operators
auto tests::unit::phase::Functions::test_operator_mul_string_Phase() -> void {
  std::string file{"file"};
  CPPUNIT_ASSERT("file.fpp" == file * ::scold::Phase::FPP);
  CPPUNIT_ASSERT("file.hpp" == file * ::scold::Phase::HPP);
  CPPUNIT_ASSERT("file.ipp" == file * ::scold::Phase::IPP);
  CPPUNIT_ASSERT("file.tpp" == file * ::scold::Phase::TPP);
  CPPUNIT_ASSERT("file.cpp" == file * ::scold::Phase::CPP);
}

auto tests::unit::phase::Functions::test_operator_mul_Module_Phase() -> void {
  ::scold::Module const module{"apple", "prune", "Class"};
  CPPUNIT_ASSERT("apple.prune.Class.fpp" == module * ::scold::Phase::FPP);
  CPPUNIT_ASSERT("apple.prune.Class.hpp" == module * ::scold::Phase::HPP);
  CPPUNIT_ASSERT("apple.prune.Class.ipp" == module * ::scold::Phase::IPP);
  CPPUNIT_ASSERT("apple.prune.Class.tpp" == module * ::scold::Phase::TPP);
  CPPUNIT_ASSERT("apple.prune.Class.cpp" == module * ::scold::Phase::CPP);
}

auto tests::unit::phase::Functions::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Functions");
  s << call("test_declaration", &Functions::test_declaration)
    << call("succ", &Functions::test_succ)
    << call("pred", &Functions::test_pred)
    << call("lt", &Functions::test_lt)
    << call("le", &Functions::test_le)
    << call("gt", &Functions::test_gt)
    << call("ge", &Functions::test_ge)
    << call("eq", &Functions::test_eq)
    << call("ne", &Functions::test_ne)
    << call("min", &Functions::test_min)
    << call("max", &Functions::test_max)
    << call("operator<<", &Functions::test_operator_insert)
    << call("operator>>-good", &Functions::test_operator_extract_good)
    << call("operator>>-fail", &Functions::test_operator_extract_fail)
    << call("operator>>-throwing", &Functions::test_operator_extract_throwing)
    << call("operator*-string-Phase", &Functions::test_operator_mul_string_Phase)
    << call("operator*-Module-Phase", &Functions::test_operator_mul_Module_Phase)
    ;
  return finalize(s);
}
#endiv
