// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests {
  namespace unit {
    namespace stream {
      class Assessor;
    }
  }
}
#endiv
#divert <hpp>
class tests::unit::stream::Assessor : public cppunit::test::Fixture {
public:
  auto test_constructor() -> void;
  auto test_divert_start() -> void;
  auto test_divert_end() -> void;
  auto test_endiv() -> void;
  auto test_small_document() -> void;

  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.Phase
#import scold.stream.Assessor
auto tests::unit::stream::Assessor::test_constructor() -> void {
  ::scold::stream::Assessor a;
  // Yup, it constructed.
  CPPUNIT_ASSERT(true);
}

auto tests::unit::stream::Assessor::test_divert_start() -> void {
  ::scold::stream::Assessor a;
  auto r1 = a("#divert <fpp>");
  CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r1));
  CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r1));
}

auto tests::unit::stream::Assessor::test_divert_end() -> void {
  ::scold::stream::Assessor a;
  auto r1 = a("#divert <fpp>");
  CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r1));
  CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r1));
  CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r1));
  auto r2 = a("#divert </fpp>");
  CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r2));
  CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r2));
  CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r2));
}

auto tests::unit::stream::Assessor::test_endiv() -> void {
  ::scold::stream::Assessor a;
  auto r1 = a("#divert <fpp>");
  CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r1));
  CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r1));
  CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r1));
  auto r2 = a("#endiv");
  CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r2));
  CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r2));
  CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r2));
}

auto tests::unit::stream::Assessor::test_small_document() -> void {
  ::scold::stream::Assessor a;
  { auto r = a("// -*- c++ -*- file starts here");
    CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::BEG == diversion(r)); }
  { auto r = a("// class name declarations start here (class forward declarations)");
    CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::BEG == diversion(r)); }
  { auto r = a("#divert <fpp>");
    CPPUNIT_ASSERT(::scold::Phase::BEG == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r)); }
  { auto r = a("class C;");
    CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r)); }
  { auto r = a("#endiv");
    CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r)); }

  { auto r = a("// complete declarations start here");
    CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::FPP == diversion(r)); }
  { auto r = a("#divert <hpp>");
    CPPUNIT_ASSERT(::scold::Phase::FPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::HPP == diversion(r)); }
  { auto r = a("class C { int i; };");
    CPPUNIT_ASSERT(::scold::Phase::HPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::HPP == diversion(r)); }
  { auto r = a("#endiv");
    CPPUNIT_ASSERT(::scold::Phase::HPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::HPP == diversion(r)); }

  { auto r = a("// inline definitions start here");
    CPPUNIT_ASSERT(::scold::Phase::HPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::HPP == diversion(r)); }
  { auto r = a("#divert <ipp>");
    CPPUNIT_ASSERT(::scold::Phase::HPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::IPP == diversion(r)); }
  { auto r = a("auto f(C &c) -> int { return 2; }");
    CPPUNIT_ASSERT(::scold::Phase::IPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::IPP == diversion(r)); }
  { auto r = a("#endiv");
    CPPUNIT_ASSERT(::scold::Phase::IPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::IPP == diversion(r)); }

  { auto r = a("// template definition declarations start here");
    CPPUNIT_ASSERT(::scold::Phase::IPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::IPP == diversion(r)); }
  { auto r = a("#divert <tpp>");
    CPPUNIT_ASSERT(::scold::Phase::IPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::TPP == diversion(r)); }
  { auto r = a("template<typename T> auto f(T &t) -> int { return 2; }");
    CPPUNIT_ASSERT(::scold::Phase::TPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::TPP == diversion(r)); }
  { auto r = a("#endiv");
    CPPUNIT_ASSERT(::scold::Phase::TPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::TPP == diversion(r)); }

  { auto r = a("// outline definitions start here");
    CPPUNIT_ASSERT(::scold::Phase::TPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::TPP == diversion(r)); }
  { auto r = a("#divert <cpp>");
    CPPUNIT_ASSERT(::scold::Phase::TPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::CPP == diversion(r)); }
  { auto r = a("auto g() -> int { return 2; }");
    CPPUNIT_ASSERT(::scold::Phase::CPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::FORE == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::CPP == diversion(r)); }
  { auto r = a("#endiv");
    CPPUNIT_ASSERT(::scold::Phase::CPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::CPP == diversion(r)); }
  { auto r = a(" // end of file!");
    CPPUNIT_ASSERT(::scold::Phase::CPP == prev(r));
    CPPUNIT_ASSERT(::scold::Ground::BACK == ground(r));
    CPPUNIT_ASSERT(::scold::Phase::CPP == diversion(r)); }
}

#import tests.unit.stream.Assessor
auto tests::unit::stream::Assessor::suite() -> cppunit::Test * {
  using namespace ::unit::rigging::suite;
  Stream s("Assessor");
  s << call("test_constructor", &Assessor::test_constructor)
    << call("test_divert_start", &Assessor::test_divert_start)
    << call("test_divert_end", &Assessor::test_divert_end)
    << call("test_endiv", &Assessor::test_endiv)
    << call("test_small_document", &Assessor::test_small_document)
    ;
  return finalize(s);
}
#endiv
