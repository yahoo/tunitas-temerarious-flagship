// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <hpp>
#import c.argv
#import sys.exits.Code
#import scold.Configuration
namespace remonstrate {
  //
  // Called from "C" main(int, char *[]) -> int
  //
  // Usage:
  //
  //   see c.main.xcpp
  //
  auto main(scold::Configuration &, c::argv) -> sys::exits::Code;
}
#endiv
#divert <cpp>
#import remonstrate.Usage
#import format.q
#import options.Code
#import options.argument.constants
#import options.longish.Getter
#import options.longish.Specification
#import options.longish.Step
#import options.shortish.Specification
#import options.throwable.Conflict
#import scold.Configuration
#import scold.exception.Quitting
#import scold.Version
#import scold.process
#import std.cerr
#import std.clog
#import std.cout
#import std.endl
#import std.exception
#import std.logic_error
#import std.string
#import sys.exits.Code
#import sys.exits

using format::q;

namespace {

  namespace ac = options::argument;
  using oi = options::indicator::Code;
  options::shortish::Specification const SHORT_SPECIFICATION{"dE:hI:kKmMnNo:O:s:S:vV"};
  options::longish::Specification const LONG_SPECIFICATION{
    { // (obscure) redefine the make depend line
      // the default (configure.ac) should be sufficient for baleful-ballad
      "make-depend-script", ac::REQUIRED, oi::CHR_b },
    { // the same as cpio '-d' and '--make-directories'
      "make-directories", ac::NO, oi::CHR_d },
    { // (ahem, somewhat the) same as cc (gcc) -I and --include
      "include", ac::REQUIRED, oi::CHR_I },
    { "submodule", ac::REQUIRED, oi::CHR_E },
    { "external", ac::REQUIRED, oi::CHR_E },
    // Reasonable
    { "modulesdir",             ac::REQUIRED, oi::CHR_m },
    { "modulesdir-directory",   ac::REQUIRED, oi::CHR_m },
    { "modulesdir-variable",    ac::REQUIRED, oi::CHR_M },
    { "objdir",                 ac::REQUIRED, oi::CHR_o },
    { "objdir-directory",       ac::REQUIRED, oi::CHR_o },
    { "objdir-variable",        ac::REQUIRED, oi::CHR_O },
    { "srcdir",                 ac::REQUIRED, oi::CHR_s },
    { "srcdir-directory",       ac::REQUIRED, oi::CHR_s },
    { "srcdir-variable",        ac::REQUIRED, oi::CHR_S },
      // options
    { "insert-namespace",                ac::NO, oi::CHR_n },
    { "no-insert-namespace",             ac::NO, oi::CHR_N },
    { "matryoshka-namespace-nesting",    ac::NO, oi::CHR_k },
    { "no-matryoshka-namespace-nesting", ac::NO, oi::CHR_K },
    { "one-step-regeneration",           ac::NO, oi::CHR_1 },
    { "one-step",                        ac::NO, oi::CHR_1 },
    { "two-step-regeneration",           ac::NO, oi::CHR_2 },
    { "two-step",                        ac::NO, oi::CHR_2 },
    //
    // standard options
    //
    { "debug",        ac::NO, oi::DEBUG_MODE },
    { "dry-run",      ac::NO, oi::DRY_RUN_MODE },
    { "help",         ac::NO, oi::USAGE_SUBCOMMAND },
    { "quiet",        ac::NO, oi::QUIET_MODE },
    { "usage",        ac::NO, oi::USAGE_SUBCOMMAND },
    { "verbose",      ac::NO, oi::VERBOSE_MODE },
    { "version",      ac::NO, oi::VERSION_SUBCOMMAND },
    //
    // experimental &( deprecated) aliases for modulesdir, srcdir, objdir
    //
    // objdir, c++dir, ccdir, cppdir, cxxdir are aliases because .c++, .cpp, .cxx are suffixes
    { "c++dir",       ac::REQUIRED, oi::CHR_o },
    { "ccdir",        ac::REQUIRED, oi::CHR_o },
    { "cppdir",       ac::REQUIRED, oi::CHR_o },
    { "cxxdir",       ac::REQUIRED, oi::CHR_o },
    // srcdir, scolddir, xcppdir are aliases
    { "scolddir",     ac::REQUIRED, oi::CHR_s },
    { "xc++dir",      ac::REQUIRED, oi::CHR_s },
    { "xcppdir",      ac::REQUIRED, oi::CHR_s },
    { "xcxxdir",      ac::REQUIRED, oi::CHR_s },
    { }
  };

}

auto remonstrate::main(scold::Configuration &cfg, c::argv argv) -> sys::exits::Code try {
  // FIXME -- set the terminate handler
  options::longish::Getter get(SHORT_SPECIFICATION, LONG_SPECIFICATION, argv);
  options::longish::Step step;
  while ( ! end(step = get()) )  {
    switch (code(step)) {
    case options::Code::CHR_d:
      cfg.make_directories = true;
      verbose(cfg) << "make intermediate directories\n";
      break;
    case options::Code::DEBUG_MODE:
      cfg.debug_mode = true;
      debug(cfg) << "entering debug mode\n";
      break;
    case options::Code::DRY_RUN_MODE:
      cfg.dry_run_mode = true;
      verbose(cfg) << "entering dry-run mode\n";
      break;
    case options::Code::QUIET_MODE:
    case options::Code::CHR_q:
      cfg.quiet_mode = true;
      // indeed, quiet-mode and verbose-mode are independent
      verbose(cfg) << "quiet mode\n";
      break;
    case options::Code::VERBOSE_MODE:
    case options::Code::CHR_v:
      cfg.verbose_mode = true;
      verbose(cfg) << "enabling verbose mode\n";
      break;
    case options::Code::CHR_b:
      cfg.make_depend_script = required(step);
      debug(cfg) << "make_depend_script=" << q(cfg.make_depend_script) << '\n';
      break;
    case options::Code::CHR_E:
      cfg.SUBMODULES.push_back(required(step));
      debug(cfg) << "SUBMODULES += " << q(required(step)) << '\n';
      break;
    case options::Code::CHR_I:
      cfg.MODULES.push_back(required(step));
      debug(cfg) << "MODULES += " << q(required(step)) << '\n';
      break;
    case options::Code::CHR_k:
      cfg.matryoshka_namespace_nesting = true;
      break;
    case options::Code::CHR_K:
      cfg.matryoshka_namespace_nesting = false;
      break;
    case options::Code::CHR_m:
      cfg.cplusplus_modules_directory.literal = required(step);
      debug(cfg) << "cplusplus_modules_directory.literal=" << q(cfg.cplusplus_modules_directory.literal) << '\n';
      break;
    case options::Code::CHR_M:
      cfg.cplusplus_modules_directory.symbolic = required(step);
      debug(cfg) << "cplusplus_modules_directory.symbolic=" << q(cfg.cplusplus_modules_directory.symbolic) << '\n';
      break;
    case options::Code::CHR_n:
      cfg.insert_namespace = true;
      break;
    case options::Code::CHR_N:
      cfg.insert_namespace = false;
      break;
    case options::Code::CHR_o:
      cfg.cplusplus_objects_directory.literal = required(step);
      debug(cfg) << "cplusplus_objects_directory.literal=" << q(cfg.cplusplus_objects_directory.literal) << '\n';
      break;
    case options::Code::CHR_O:
      cfg.cplusplus_objects_directory.symbolic = required(step);
      debug(cfg) << "cplusplus_objects_directory.symbolic=" << q(cfg.cplusplus_objects_directory.symbolic) << '\n';
      break;
    case options::Code::CHR_s:
      cfg.scold_source_directory.literal = required(step);
      debug(cfg) << "scold_source_directory.literal=" << q(cfg.scold_source_directory.literal) << '\n';
      break;
    case options::Code::CHR_S:
      cfg.scold_source_directory.symbolic = required(step);
      debug(cfg) << "scold_source_directory.symbolic=" << q(cfg.scold_source_directory.symbolic) << '\n';
      break;
    case options::indicator::Code::CHR_1:
      cfg.regeneration = scold::Regeneration::TWO_STEP;
      break;
    case options::indicator::Code::CHR_2:
      cfg.regeneration = scold::Regeneration::ONE_STEP;
      break;
    case options::Code::USAGE_SUBCOMMAND:
    case options::Code::CHR_h:
      throw remonstrate::Usage(cfg.NAME, sys::exits::OK);
    case options::Code::VERSION_SUBCOMMAND:
    case options::Code::CHR_V:
      throw scold::Version(cfg.NAME);
    case options::Code::MISSING:
      error(cfg) << "missing value, a value is requried for " << word_in_error(step) << '\n';
      throw remonstrate::Usage(cfg.NAME, sys::exits::USAGE);
    case options::Code::UNKNOWN:
      error(cfg) << "unknown option at " << word_in_error(step) << '\n';
      throw remonstrate::Usage(cfg.NAME, sys::exits::USAGE);
    default:
      std::logic_error("case not handled");
    }
  }
  cfg.cplusplus_modules_directory.finalize();
  cfg.cplusplus_objects_directory.finalize();
  cfg.scold_source_directory.finalize();
  for (auto filename : get) {
    scold::process(cfg, filename);
  }
  return sys::exits::OK;
} catch (options::throwable::Version const &e) {
  std::cout << e << std::endl;
  return sys::exits::OK;
} catch (options::throwable::Usage const &e) {
  e.stream() << e << std::endl;
  return e.code();
} catch (scold::exception::Quitting const &e) {
  std::cerr << cfg.NAME  << ": error " << e.what() << '\n';
  return e.code();
} catch (std::exception const &e) {
  std::cerr << cfg.NAME << ": error, (unexpected) " << e.what() << '\n';
  return sys::exits::SOFTWARE;
}
#endiv
