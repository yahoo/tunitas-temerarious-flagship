// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace validate {
    class Result;
  }
}
#endiv
#divert <hpp>
#import std.ostream
#import std.string
namespace scold {
  namespace validate {
    inline auto operator<<(std::ostream &, Result const &) -> std::ostream &;

    // Boolean logic, but preserve the causal reason (reasoning right-to-left)
    inline auto operator&(Result const &, Result const &) -> Result;
    inline auto operator&(Result const &, Result &&) -> Result;
    inline auto operator&(Result &&, Result const &) -> Result;
    inline auto operator&(Result &&, Result &&) -> Result;

    inline auto operator|(Result const &, Result const &) -> Result;
    inline auto operator|(Result &&, Result const &) -> Result;
    inline auto operator|(Result const &, Result &&) -> Result;
    inline auto operator|(Result &&, Result &&) -> Result;
  }
}

class scold::validate::Result {
public:
  inline explicit Result(bool status = DEFAULT_STATUS, std::string const &reason = DEFAULT_REASON);
  inline Result(bool status, std::string &&reason);
  inline auto operator!() const -> bool;
  inline operator bool() const;
  inline auto operator~() const -> Result;
  inline static auto is_invalid(std::string const &excuse) -> Result;
  inline static auto is_valid() -> Result;
public:
  bool status;
  std::string reason;
  static constexpr bool const DEFAULT_STATUS = true;
  static std::string const DEFAULT_REASON;
public:
  struct tests { struct Suite; };
  friend struct tests::Suite;
};
#endiv
#divert <ipp>
#import std.forward

auto scold::validate::operator<<(std::ostream &o, Result const &r) -> std::ostream & {
  return o << (r ? "OK" : r.reason);
}

auto scold::validate::Result::is_invalid(std::string const &excuse) -> Result {
  return Result(false, excuse);
}

auto scold::validate::Result::is_valid() -> Result {
  return Result(true);
}

auto scold::validate::operator&(Result const &a, Result const &b) -> Result {
  bool c_status = a.status && b.status;
  Result c(c_status, c_status ? a.reason : b.reason);
  return c;
}

auto scold::validate::operator&(Result const &a, Result &&b) -> Result {
  bool c_status = a.status && b.status;
  using reason_type = decltype(a.reason);
  Result c(c_status, c_status ? reason_type(a.reason) : std::move(b.reason));
  return c;
}

auto scold::validate::operator&(Result &&a, Result const &b) -> Result {
  bool c_status = a.status && b.status;
  using reason_type = decltype(b.reason);
  Result c(c_status, c_status ? std::forward<std::string>(a.reason) : reason_type(b.reason));
  return c;
}

auto scold::validate::operator&(Result &&a, Result &&b) -> Result {
  bool c_status = a.status && b.status;
  Result c(c_status, c_status ? std::forward<std::string>(a.reason) : std::forward<std::string>(b.reason));
  return c;
}

auto scold::validate::operator|(Result const &a, Result const &b) -> Result {
  Result c(a.status || b.status,
	   a.status ? a.reason : b.reason);
  return c;
}

auto scold::validate::operator|(Result &&a, Result const &b) -> Result {
  using reason_type = decltype(b.reason);
  Result c(a.status || b.status,
	   a.status ? std::forward<std::string>(a.reason) : reason_type(b.reason));
  return c;
}

auto scold::validate::operator|(Result const &a, Result &&b) -> Result {
  using reason_type = decltype(a.reason);
  Result c(a.status || b.status,
	   a.status ? reason_type(a.reason) : std::forward<std::string>(b.reason));
  return c;
}

auto scold::validate::operator|(Result &&a, Result &&b) -> Result {
  Result c(a.status || b.status,
	   a.status ? std::forward<std::string>(a.reason) : std::forward<std::string>(b.reason));
  return c;
}

scold::validate::Result::Result(bool the_status, std::string const &the_reason)
  : status(the_status)
  , reason(the_reason) {
  ;
}

scold::validate::Result::Result(bool the_status, std::string &&the_reason)
  : status(the_status)
  , reason(std::forward<std::string>(the_reason)) {
  ;
}

auto scold::validate::Result::operator!() const -> bool {
  return !status;
}

scold::validate::Result::operator bool() const {
  return status;
}

auto scold::validate::Result::operator~() const -> Result {
  Result that( !this->status, this->reason);
  return that;
}
#endiv
#divert <cpp>
std::string const scold::validate::Result::DEFAULT_REASON{"no reason given"};
#endiv
