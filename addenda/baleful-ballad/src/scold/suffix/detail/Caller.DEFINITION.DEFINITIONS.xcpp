// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import scold.suffix.detail.Caller
namespace scold {
  namespace suffix {
    namespace detail {
      template<typename DEFINITION, typename... DEFINITIONS> struct Caller<DEFINITION, DEFINITIONS...>;
    }
  }
}
#endiv
#divert <hpp>
#import scold.Suffix
#import mvr.State
#import mvr.status
#import mvr.SAV
#import scold.suffix.detail.Definition
template<typename DEFINITION, typename... DEFINITIONS> struct scold::suffix::detail::Caller<DEFINITION, DEFINITIONS...> {
  using definition = DEFINITION;
  using subcaller = Caller<DEFINITIONS...>;
  inline static auto c_str(Suffix suffix) -> char const * {
    if (definition::value() == suffix) {
      return definition::c_str();
    } else {
      return subcaller::c_str(suffix);
    }
  }
  inline static auto str(Suffix suffix) -> std::string { return recurrence<std::string>(suffix, &definition::str, &subcaller::str); }
  inline static auto to(std::string const &specimen) -> mvr::SAV<Suffix> {
    if (definition::str() == specimen) {
      using namespace mvr;
      return status<Suffix>(State::VALUE, definition::value()); // yup, a value was found
    } else {
      return subcaller::to(specimen);
    }
  }
private:
  inline static auto recurrence(Suffix suffix, bool (*base)(), bool (*recur)(Suffix)) -> bool {
    if (definition::value() == suffix) {
      return (*base)();
    } else {
      return (*recur)(suffix);
    }
  }
  template<typename RESULT> inline static auto recurrence(Suffix suffix, RESULT (*base)(), RESULT (*recur)(Suffix)) -> RESULT {
    if (definition::value() == suffix) {
      return (*base)();
    } else {
      return (*recur)(suffix);
    }
  }
};
#endiv
