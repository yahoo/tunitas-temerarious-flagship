// -*- c++ -*- in the SCOLD styling that is so popular these days
#divert <hpp>
#import std.string
#import std.tuple
#import std.vector
#import scold.splitting.On
namespace scold {
  namespace splitting {
    using split_result_type = std::tuple<std::vector<std::string>, validate::Result>;
    auto split(On, std::string const &subject) -> split_result_type;
  }
}
#endiv
#divert <cpp>
#import mvr.recv
#import mvr.send
#import std.ostringstream
#import std.string
#import scold.validate.Result
auto scold::splitting::split(On on, std::string const &subject) -> split_result_type {
  std::vector<std::string> result;
  // "." is a one-character sequence
  // "/" is a multi-character sequence because the '/' can be repeated, which is ignored
  // "::" is a 2-character sequence
  //
  // "latent pending" describes the condition where an empty buf needs to be appended (e.g. a trailing slash)
  bool latent_pending_in_buf = true;
  std::string buf;
  for (std::string::const_iterator i(subject.begin()), e(subject.end()); e != i; ++i) {
    if (on_the_boundary(on, *i)) {
      result.push_back(buf);
      buf.clear();
      validate::Result r;
      mvr::recv(i, r) = past_the_boundary(on, i, e);
      if ( !r ) {
	// the failure and whatever has been recovered so far
	return mvr::send(result, r);
      }
      // "latent pending" until such time as we append something
      latent_pending_in_buf = true;
    } else if (on_any_boundary(*i)) {
      std::ostringstream err;
      err << "'" << *i << "' is invalid here, expected " << on;
      // result is whatever we've found so far, before the error condition
      return mvr::send(result, validate::Result::is_invalid(err.str()));
    } else {
      buf += *i;
      // no longer "latent pending" but rather "explicitly pending" by !buf.empty()
      latent_pending_in_buf = false;
    }
  }
  if (latent_pending_in_buf || ! buf.empty() ) {
    // This may push back an empty buf, but that's the point
    // Examples:
    //     /a/b/c/ <----------- the last filename name is empty, "think '.'"
    //     std::apple:: <------ the last name is empty, this is not a legal C++ namespace-scoped name
    //     std.posix. <-------- the last name slot is empty, this is not a legal C++ module name
    result.push_back(buf);
  }
  return mvr::send(result, validate::Result::is_valid());
}
#endiv
