// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace streams {
    // where STREAMS is
    //     scold::Streams
    //     scold::Streams const
    template<typename STREAMS> class Range;
  }
}
#endiv
#divert <hpp>
#import scold.Phase
#import scold.phase.Incrementer
#import scold.Streams
#import scold.streams.Iterator
#import std.is_base_of
#import std.remove_const
template<typename STREAMS> class scold::streams::Range {
  // This is a template so that STREAMS can be 'const' or 'muting'
  // Allowed:
  //   Range<Streams>
  //   Range<Streams const>
 public:
  using streams_type = STREAMS;
  static_assert(std::is_base_of<scold::Streams, typename std::remove_const<streams_type>::type>::value, "inappropriate type for STREAMS");
  inline Range(streams_type *, Phase start, Phase finish, phase::Incrementer);
  using const_iterator = Iterator<streams_type const, typename streams_type::stream_type const>;
  inline auto begin() const -> const_iterator;
  inline auto end() const -> const_iterator;
  using iterator = Iterator<streams_type, typename streams_type::stream_type>;
  inline auto begin() -> iterator;
  inline auto end() -> iterator;
protected:
  streams_type *owner;
  Phase start;
  Phase finish;
  phase::Incrementer incrementer;
};
#endiv
#divert <ipp>
template<typename STREAMS> scold::streams::Range<STREAMS>::Range(streams_type *arg_owner, Phase arg_start, Phase arg_finish, phase::Incrementer arg_incrementer)
  : owner(arg_owner) {
  ;
}

template<typename STREAMS> auto scold::streams::Range<STREAMS>::begin() const -> const_iterator {
  return const_iterator(owner, start, incrementer);
}

template<typename STREAMS> auto scold::streams::Range<STREAMS>::end() const -> const_iterator {
  return const_iterator(owner, finish);
}

template<typename STREAMS> auto scold::streams::Range<STREAMS>::begin() -> iterator {
  return iterator(owner, start, incrementer);
}

template<typename STREAMS> auto scold::streams::Range<STREAMS>::end() -> iterator {
  return iterator(owner, finish);
}
#endiv
