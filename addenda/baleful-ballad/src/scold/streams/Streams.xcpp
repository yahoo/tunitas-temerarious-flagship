// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace streams {
    class Streams;
  }
}
#endiv
#divert <hpp>
#import scold.line.Item
namespace scold {
  namespace streams {
    // Write a "line" into the (background) of the Streams
    inline auto operator<<(Streams &, line::Item const &) -> Streams &;
    inline auto operator<<(Streams &, line::Item &&) -> Streams &;
  }
}

#import scold.Files // to be friends with files::operator<<

#import scold.phase.Definition
#import scold.phase.Phase
#import scold.stream.Stream
#import scold.streams.Iterator
#import std.size_t
class scold::streams::Streams {
public:
  Streams() = default;
  using stream_type = stream::Stream;
  using const_stream_type = stream::Stream const;
  inline auto operator[](phase::Phase) const -> const_stream_type &;
  inline auto operator[](phase::Phase) -> stream_type &;
  using const_iterator = Iterator<Streams const, stream::Stream const>;
  inline auto begin() const -> const_iterator;
  inline auto end() const -> const_iterator;
  using iterator = Iterator<Streams, stream::Stream>;
  inline auto begin() -> iterator;
  inline auto end() -> iterator;
protected:
  friend auto files::operator<<(Files &, Streams const &) -> Files &;
  friend auto files::operator<<(line::Stream<Files &, std::string>, Streams const &) -> line::Stream<Files &, std::string>;
  friend auto files::operator<<(line::Stream<Files &, std::string const &>, Streams const &) -> line::Stream<Files &, std::string const &>;
  friend auto streams::operator<<(Streams &, line::Item const &) -> Streams &;
  friend auto streams::operator<<(Streams &, line::Item &&) -> Streams &;
  Stream background;
  Stream diverted[phase::Definition::diversion_size()];
  // ... so we don't have to write operator[] twice or cut & paste
  template<std::size_t N, typename STREAM> inline static auto operator_index(STREAM (&)[N], Phase) -> STREAM &;
};
#endiv
#divert <ipp>
auto scold::streams::operator<<(Streams &s, line::Item const &l) -> Streams & {
  s.background.push_back(l);
  return s;
}

#import std.forward
auto scold::streams::operator<<(Streams &s, line::Item &&anon) -> Streams & {
  s.background.push_back(std::forward<line::Item>(anon));
  return s;
}

#import scold.phase.Definition
#import std.invalid_argument
#include <cassert>
template<std::size_t N, typename STREAM> auto scold::streams::Streams::operator_index(STREAM (&array)[N], Phase phase) -> STREAM & {
  phase::Definition def(phase);
  if (!def.has_index()) {
    throw std::invalid_argument("no index for phase");
  }
  auto index = def.index();
  assert(index < sizeof (array)/sizeof (array[0])); // already checked by def.has_index()
  return array[index];
}

auto scold::streams::Streams::operator[](phase::Phase ph) const -> const_stream_type & {
  return operator_index(diverted, ph);
}

auto scold::streams::Streams::operator[](phase::Phase ph) -> stream_type & {
  return operator_index(diverted, ph);
}

#import scold.phase.Phase // phase::succ
#import scold.phase.Incrementer
auto scold::streams::Streams::begin() const -> const_iterator {
  phase::Incrementer increment(phase::succ);
  return const_iterator(this, phase::Phase::FPP, increment);
}

auto scold::streams::Streams::end() const -> const_iterator {
  return const_iterator(this, phase::Phase::END);
}

auto scold::streams::Streams::begin() -> iterator {
  phase::Incrementer increment(phase::succ);
  return iterator(this, phase::Phase::FPP, increment);
}

auto scold::streams::Streams::end() -> iterator {
  return iterator(this, phase::Phase::END);
}
#endiv
