// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace line {
    //
    // Usage:
    //     std::string filename "somefile.xcpp";
    //     Stream somestream = compute_somestream(...);
    //     named(std::cout, filename) << somestream; <---------------- see named(...) with operator<<
    //
    // See the name(...) constructor function
    //
    enum Lookup_Stream { };
    template<typename STREAMY, typename STRINGY> class Stream;
  }
}
#endiv
#divert <hpp>
#import std.pair
#import std.string
#import std.is_reference
#import std.is_same
template<typename STREAMY, typename STRINGY> class scold::line::Stream : public std::pair<STREAMY, STRINGY> {
  using ancestor = std::pair<STREAMY, STRINGY>;
  static_assert(std::is_reference<STREAMY>::value, "not a reference");
  static_assert((std::is_same<STRINGY, std::string>::value ||
                 std::is_same<STRINGY, std::string const &>::value), "need 'std::string' or 'std::string const &'");
public:
  using stream_reference = STREAMY;
  using string_value = STRINGY; // a reference, or not
  using ancestor::pair;
  // routed to the STREAMY in the first position
  inline explicit operator bool() const;
  inline auto operator!() const -> bool;
};

namespace scold {
  namespace line {
    // WATCHOUT - don't rename "outbound" to be "stream" though that would be natural.  'namescape stream' occludes it.
    template<typename STREAMY, typename STRINGY> inline auto outbound(Stream<STREAMY, STRINGY> const &) -> typename Stream<STREAMY, STRINGY>::stream_reference;
    template<typename STREAMY, typename STRINGY> inline auto filename(Stream<STREAMY, STRINGY> const &) -> typename Stream<STREAMY, STRINGY>::string_value; 

    template<typename STREAM> inline auto named(STREAM &outbound, std::string const &filename) -> Stream<STREAM &, std::string const &>;
    template<typename STREAM> inline auto named(STREAM &outbound, std::string &&filename) -> Stream<STREAM &, std::string>;
  }
}
#endiv
#divert <ipp>
template<typename STREAMY, typename STRINGY> auto scold::line::outbound(Stream<STREAMY, STRINGY> const &s) -> typename Stream<STREAMY, STRINGY>::stream_reference {
  return s.first;
}

template<typename STREAMY, typename STRINGY> auto scold::line::filename(Stream<STREAMY, STRINGY> const  &s) -> typename Stream<STREAMY, STRINGY>::string_value {
  return s.second;
}

template<typename STREAM> auto scold::line::named(STREAM &o, std::string const &s) -> Stream<STREAM &, std::string const &> {
  return Stream<STREAM &, std::string const &>(o, s);
}

#import std.forward
template<typename STREAM> auto scold::line::named(STREAM &o, std::string &&anon) -> Stream<STREAM &, std::string> {
  return Stream<STREAM &, std::string>(o, std::forward<std::string>(anon));
}

template<typename STREAMY, typename STRINGY> scold::line::Stream<STREAMY, STRINGY>::operator bool() const {
return ancestor::first.operator bool();
}

template<typename STREAMY, typename STRINGY> auto scold::line::Stream<STREAMY, STRINGY>::operator!() const -> bool {
  return ancestor::first.operator!();
}
#endiv
