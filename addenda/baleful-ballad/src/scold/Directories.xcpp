// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  //
  // The manage the (making of) the directories of the Filenames
  // scold::Directories is like scold::Files, it manages a multiplicity.
  // It lists and makes the multiple directories.
  //
  class Directories;
}
#endiv
#divert <hpp>
#import scold.filenames.Filenames
#import scold.filenames.Filenames.Directories
#import scold.directories.mkdirp.Result
#import std.set
#import std.string
class scold::Directories {
public:
  inline Directories();
  inline auto exceptions() const -> bool;
  inline auto exceptions(bool exception_on_failure) -> void;
  using list_result_type = filenames::Filenames::Directories;
  inline auto list(filenames::Filenames const &) -> list_result_type;
  using mkdir_result_type = directories::mkdirp::Result;
  inline auto mkdir(filenames::Filenames const &) -> mkdir_result_type;
protected:
  auto make_some_directories(filenames::Filenames::Directories const &) -> mkdir_result_type;
  bool exception_on_failure;
};
#endiv
#divert <ipp>
scold::Directories::Directories()
  : exception_on_failure(false) {
  ;
}

auto scold::Directories::exceptions() const -> bool {
  return exception_on_failure;
}

auto scold::Directories::exceptions(bool set) -> void {
  exception_on_failure = set;
}

#import scold.Phases
#import scold.filenames.dirnames
auto scold::Directories::list(filenames::Filenames const &filenames) -> list_result_type {
  return filenames::dirnames(filenames, Phases());
}

auto scold::Directories::mkdir(filenames::Filenames const &filenames) -> mkdir_result_type {
  return make_some_directories(list(filenames));
}
#endiv
#divert <cpp>
#import scold.directories.Failure
#import sys.posix.mkdirp
#import sys.posix.E
auto scold::Directories::make_some_directories(list_result_type const &seedlist) -> mkdir_result_type {
  using sys::posix::mkdirp; 
  for (auto const &directory : seedlist) {
    auto made = mkdirp(directory, 0777);
    if (sys::posix::E::EXIST != sys_error_code(made)) {
      if (!ok(made)) {
        if (exception_on_failure) {
          directories::Failure failure(ok(made), error_num(made), directory, seedlist);
          throw failure;
        } else {
          mkdir_result_type ret(ok(made), error_num(made), directory, seedlist);
          return ret;
        }
      }
    }
  }
  return mkdir_result_type();
}
#endiv
