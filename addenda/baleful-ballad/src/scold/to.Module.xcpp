// -*- c++ -*- with SCOLD stylings
#divert <hpp>
// The module name <scold.to.Module> corresponds to
//    the function template to<...>(...)
//    specialized to return scold::Module
#import scold.to.RESULT.string
#import scold.Module
namespace scold {
  //
  // system/subsystem/package/Class.xcpp -> { system, subsystem, package, Class }
  // system/subsystem/package/namespace.xcpp -> { system, subsystem, package }
  //     ... see how the 'namespace' keyword is removed if it is last
  //
  template<> inline auto to<Module>(std::string const &filename) -> Module;

  // Case 1
  //   scold_srcdir = /views/build/module-specimen/src
  //   $(scold_srcdir)/system/subsystem/package/Class.xcpp -> { system, subsystem, package, Class }
  // Case 2
  //   scold_modulesdir = ./obj/modules
  //   $(scold_modulesdir)/system.subsystem.package.Class  -> { system, subsystem, package, Class }
  // 
  template<> auto to<Module>(std::string const &filename, std::string const &ignorable_prefix) -> Module;
}
#endiv
#divert <ipp>
template<> auto scold::to<scold::Module>(std::string const &filename) -> Module {
  return to<Module>(filename, "");
}
#endiv
#divert <cpp>
#import scold.suffix.Definition
#import std.getline
#import std.istringstream
#import std.move
#import std.runtime_error
template<> auto scold::to<scold::Module>(std::string const &filename, std::string const &ignorable_prefix) -> Module {
  // ... must make a function-local copy of the filename before disassembling it.
  // ... the function argument must be a const-reference argument to match the template overload.
  std::string work(filename);
  if (0 != ignorable_prefix.size() && 0 == work.find(ignorable_prefix)) {
    work = work.substr(ignorable_prefix.size());
    while (work.size() && '/' == work.front()) {
      work.erase(0, 1); // expect there is but one leading slash
    }
  }
  // file component separators (slashes) are turned into module component separators (dots)
  for (std::string::size_type i(0), e(work.size()); e != i; ++i) {
    if ('/' == work[i]) {
      work[i] = '.';
    }
  }
  Module module;
  {
    std::istringstream buf(work);
    std::string name;
    while (std::getline(buf, name, '.')) {
      if (name.size()) {
        // ignore empty names as that means that there were duplicate '/' characters in the filename
        module.push_back(name);
      }
    }
    if (!buf.eof()) {
      // huh?  FIXME Should this be a scold-specific exception?  This is unexpected, an "internal error" sort of a thing
      throw std::runtime_error("istringstream failed in module parsing");
    }
  }
  // use suffix::Definition here so that 'xcpp' is considered as well
  if (module.size() && ok(suffix::Definition::to(module.back()))) {
    // e.g. .../system/subsystem/package/Class.xcpp
    // The suffix will turn into a module. Trim that.
    module.erase(module.end()-1);
  }
  if (module.size() && "namespace" == module.back()) {
    // e.g. .../system/subsystem/package/namespace.xcpp
    // The final keyword "namespace" is an implementation choice. Trim that.
    module.erase(module.end()-1);
  }
  return module;
}
#endiv
