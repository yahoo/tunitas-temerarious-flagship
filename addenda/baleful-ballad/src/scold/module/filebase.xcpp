// -*- c++ -*- in the SCOLD styling that is so fashionable these days
#divert <hpp>
#import std.string
#import scold.module.Module
namespace scold {
  namespace module {
    //
    // Converts the module name separators (dots) into file component separators (slashes)
    //
    // A module  has a syntax with dots
    //     e.g. apple.banana.cherry.Dog
    //
    // A filebase has a syntax with slashes yet but no suffix
    //     e.g. apple/banana/cherry/Dog
    //
    // WATCHOUT - there is a convention of using dots within the final filename to signify specialization
    //     e.g.
    //          (module)   apple.banana.cherry.as.RESULT.string 
    //          (filebase) apple/banana/cherry/as.RESULT.string
    //             because $(srcdir)/apple/banana/cherry/as.RESULT.string.xcpp exists
    //
    // This can only be understood in the context of the $(srcdir)
    inline auto filebase(Module const &, std::string const &srcdir_context) -> std::string;
  }
}
#endiv
#divert <ipp>
#import std.invalid_argument
#import scold.module.probe
#import want.join
//
// Add in slashes until the file is found
//
//   apple.banana.cherry.as.RESULT.string.xcpp
//   apple/banana.cherry.as.RESULT.string.xcpp
//   apple/banana/cherry.as.RESULT.string.xcpp
//   apple/banana/cherry/as.RESULT.string.xcpp
//
// If nothing arises earlier then ...
//
//   apple/banana/cherry/as/RESULT/string
//
auto scold::module::filebase(Module const &module, std::string const &srcdir_context) -> std::string {
  if (module.empty()) {
    throw std::invalid_argument("empty module");
  }
  if (srcdir_context.empty()) {
    // it should at least be "."
    throw std::invalid_argument("empty $(srcdir) context");
  }
  Module::const_iterator b=module.begin();
  Module::const_iterator i=b;
  Module::const_iterator e=module.end();
  do {
    //
    // WATCHOUT - the function module::probe(...) must be visited with i varying between b and e (inclusive)
    // This is not the usual iteration of [b, e).  We need to iterate i across [b, e]
    auto probed = module::probe(srcdir_context, b, i, e);
    if (ok(probed)) {
      return value(probed);
    }
    if (i == e) {
      // cannot increment any further.
      break;
    } else {
      // Increment and revisit the probe
      ++i;
    }
  } while (1); // NOT the same as ``while (++i != e)''
  return want::join('/', module);
}
#endiv
