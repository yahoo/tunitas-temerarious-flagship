// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import mvr.send
#import scold.module.Module
#import std.tuple
namespace scold {
  namespace module {
    namespace detail {
      namespace enclosing {
        enum ADL { }; // so that ADL will find detail::enclosing::Result
        using Result = std::tuple<ADL, bool, Module>;
      }
    }
  }
}
#endiv
#divert <hpp>
#import mvr.send
#import scold.module.Module
#import std.tuple
namespace scold {
  namespace module {
    namespace detail {
      namespace enclosing {
        inline auto global(Result const &) -> bool;

        // n.b. on the name 'value' to access (one of the values) in the result.
        // - can't call it 'module' as there is such a namespace
        // - can't call it 'enclosing' as there is such a namespace
        // Not helpful to make up a wholly new name te remember.

        inline auto value(Result const &) -> Module const &;
        inline auto value(Result &&) -> Module;

        static_assert(std::is_same<Result, decltype(mvr::send(ADL(), true, Module()))>::value, "mvr::send-recv mismatch");
      }
    }
  }
}
#endiv
#divert <ipp>
#import std.get
#import std.forward
auto scold::module::detail::enclosing::global(Result const &r) -> bool {
  return std::get<1>(r);
}

auto scold::module::detail::enclosing::value(Result const &r) -> Module const & {
  return std::get<2>(r);
}

auto scold::module::detail::enclosing::value(Result &&r) -> Module {
  return std::get<2>(r);
}
#endiv
