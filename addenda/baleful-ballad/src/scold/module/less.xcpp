// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#forward scold.module.Module
#import std.less
namespace std {
  //
  // The specialization
  // ... so that the STL containers, e.g. std::set<Module> will function
  //
  template<> struct less<scold::module::Module>;
}
#endiv
#divert <hpp>
template<> struct std::less<scold::module::Module> {
  inline auto operator()(scold::module::Module const &, scold::module::Module const &) const -> bool;
};
#endiv
#divert <ipp>
#import scold.module.Module
auto std::less<scold::module::Module>::operator()(scold::module::Module const &a, scold::module::Module const &b) const -> bool {
  using iterator = scold::module::Module::const_iterator;
  iterator ai=a.begin(), bi=b.begin();
  iterator ae=a.end(), be=b.end();
  while (ai != ae && bi != be) {
    if (*ai < *bi) {
      return true;
    } else if ( ! (*ai == *bi) ) {
      return false;
    }
    ai++;
    bi++;
  }
  // We have reached the end of a or b, both being equal so far.  Which is shorter?
  // if a is shorter, then a is less (than) b.
  return ai == ae && bi != be;
}
#endiv
