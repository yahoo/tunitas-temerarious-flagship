// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import scold.phase.detail.Caller
namespace scold {
  namespace phase {
    namespace detail {
      template<> struct Caller<>;
    }
  }
}
#endiv
#divert <hpp>
#import scold
#import scold.Phase
#import mvr.SAV
#import mvr.State
#import mvr.status
#import std.logic_error
#forward scold.stream // steam::index_t
template<> struct scold::phase::detail::Caller<> {
  inline static auto has_diversion(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto has_index(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto index(Phase) -> stream::index_t { throw_fail(); return stream::index_t(); }
  inline static constexpr auto diversion_counter(unsigned base) -> stream::index_t { return base; }
  inline static auto has_succ(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto has_pred(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto can_endiv(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto has_suffix(Phase) -> bool { throw_fail(); return bool(); }
  inline static auto c_str(Phase) -> char const * { throw_fail(); return nullptr; }
  inline static auto str(Phase) -> std::string { throw_fail(); return std::string(); }
  inline static auto to(std::string const &specimen) -> mvr::SAV<Phase> {
    using namespace mvr;
    return status<Phase>(State::NONE, Phase()); // no definable value was found
  }
private:
  inline static auto throw_fail() -> void {
    // This indicates a programmer error.
    // The Caller<...> series should have matched something by this time.
    // That it did not means that there is a Definition missing in the
    // type alias of scold::phase::Definition::caller_type.
    throw std::logic_error("caller fails");
  }
};
#endiv
