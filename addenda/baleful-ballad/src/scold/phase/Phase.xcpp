// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace phase {
    // The encoding & ordering is *almost* arbitrary
    // Requirements:
    //    1. BEG must 0 so Phase::BEG == Phase()
    //    2. BEG..FPP..CPP..END must be sequential integers
    // Other properties of the encodings are recorded in phase::Definition
    //
    // The enum models the parts of the SCOLD translation unit
    //
    // Ground       BACK FORE BACK FORE BACK FORE BACK FORE BACK FORE BACK
    // Phase    BEG------FPP-------HPP-------IPP-------TPP-------CPP------END
    //
    enum class Phase { BEG = 0, FPP, HPP, IPP, TPP, CPP, END };
  }
}
#endiv
#divert <hpp>
#import std.ostream
#import std.istream
namespace scold {
  namespace phase {
    // compute the relationships on FPP..CPP (invalid on others)
    inline auto succ(Phase) -> Phase;
    inline auto pred(Phase) -> Phase;

    inline auto lt(Phase, Phase) -> bool;
    inline auto le(Phase, Phase) -> bool;
    inline auto gt(Phase, Phase) -> bool;
    inline auto ge(Phase, Phase) -> bool;

    inline auto eq(Phase, Phase) -> bool;
    inline auto ne(Phase, Phase) -> bool;

    inline auto min(Phase, Phase) -> Phase;
    inline auto max(Phase, Phase) -> Phase;

    inline auto operator<<(std::ostream &, Phase) -> std::ostream &;
    auto operator>>(std::istream &, Phase &) -> std::istream &;
    // see the (separate) helpers for operator<< printing
    //   want::braket(Phase)
    //   want::dot(Phase)
  }
}
#entail scold.phase.operators
#endiv
#divert <ipp>
#import scold.phase.Definition
#import std.invalid_argument
auto scold::phase::succ(Phase phase) -> Phase {
  Definition definition(phase);
  if (!definition.has_succ()) {
    throw std::invalid_argument("no_succ");
  }
  return Phase((int)(phase)+1);
}

auto scold::phase::pred(Phase phase) -> Phase {
  Definition definition(phase);
  if (!definition.has_pred()) {
    throw std::invalid_argument("no_pred");
  }
  return Phase((int)(phase)-1);
}

auto scold::phase::lt(Phase a, Phase b) -> bool {
  return !eq(a, b) && le(a, b);
}

auto scold::phase::le(Phase a, Phase b) -> bool {
  return a == min(a, b);
}

auto scold::phase::gt(Phase a, Phase b) -> bool {
  return !eq(a, b) && ge(a, b);
}

auto scold::phase::ge(Phase a, Phase b) -> bool {
  return a == max(a, b);
}

auto scold::phase::eq(Phase a, Phase b) -> bool {
  return (int)(a) == (int)(b);
}

auto scold::phase::ne(Phase a, Phase b) -> bool {
  return (int)(a) != (int)(b);
}

#import std.max
auto scold::phase::max(Phase a, Phase b) -> Phase {
  return Phase(std::max((int)(a), (int)(b)));
}

#import std.min
auto scold::phase::min(Phase a, Phase b) -> Phase {
  return Phase(std::min((int)(a), (int)(b)));
}

#import scold.phase.Definition
auto scold::phase::operator<<(std::ostream &o, Phase value) -> std::ostream & {
  Definition def(value);
  return o << def.str();
}
#endiv
#divert <cpp>
#import scold.phase.Definition
auto scold::phase::operator>>(std::istream &in, Phase &fill) -> std::istream & {
  std::string token;
  char c1, c2, c3;
  // expect: "fpp" "hpp" "ipp" "tpp" "cpp" or "xcpp"
  if (in >> c1 >> c2 >> c3) {
    token = std::string{c1, c2, c3};
    if ('x' == c1) {
      char c4;
      if (in >> c4) {
        token.push_back(c4);
      } else {
        in.setstate(std::ios::failbit); // might throw
        return in;
      }
    }
  }
  auto r = Definition::to(token);
  if (ok(r)) {
    fill = value(r);
  } else {
    in.setstate(std::ios::failbit); // might throw
  }
  return in;
}
#endiv
