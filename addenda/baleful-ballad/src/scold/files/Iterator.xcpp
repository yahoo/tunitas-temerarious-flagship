// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace files {
    template<typename FILES_CONSTY, typename STREAM_CONSTY> class Iterator;
  }
}
#endiv
#divert <hpp>
namespace scold {
  namespace files {
    template<typename FILES_CONSTY, typename STREAM_CONSTY> inline auto operator==(Iterator<FILES_CONSTY, STREAM_CONSTY> const &, Iterator<FILES_CONSTY, STREAM_CONSTY> const &) -> bool;
    template<typename FILES_CONSTY, typename STREAM_CONSTY> inline auto operator!=(Iterator<FILES_CONSTY, STREAM_CONSTY> const &, Iterator<FILES_CONSTY, STREAM_CONSTY> const &) -> bool;
  }
}

#forward scold.Files
#import scold.Phase
#import std.iterator
#import std.forward_iterator_tag
#import std.ostream
template<typename FILES_CONSTY, typename STREAM_CONSTY> class scold::files::Iterator : public std::iterator<std::forward_iterator_tag, STREAM_CONSTY &, void, void, void> {
  using ancestor = std::iterator<std::forward_iterator_tag, STREAM_CONSTY &, void, void, void>;
public:
  using files_type = FILES_CONSTY;
  inline Iterator(files_type *, Phase position);
  inline auto operator++() -> Iterator &;
  inline auto operator++(int) -> Iterator;
  // NO SUCH auto operator*() const -> value_type const &; (makes no sense; think about it ...)
  inline auto operator*() -> typename ancestor::value_type &;
protected:
  files_type *owner;
  Phase position;
  friend auto files::operator== <>(Iterator const &, Iterator const &) -> bool;
};
#endiv
#divert <ipp>
#import scold.Files
template<typename FILES_CONSTY, typename STREAM_CONSTY> auto scold::files::operator==(Iterator<FILES_CONSTY, STREAM_CONSTY> const &a, Iterator<FILES_CONSTY, STREAM_CONSTY> const &b) -> bool {
  return a.owner == b.owner && a.position == b.position;
}

template<typename FILES_CONSTY, typename STREAM_CONSTY> auto scold::files::operator!=(Iterator<FILES_CONSTY, STREAM_CONSTY> const &a, Iterator<FILES_CONSTY, STREAM_CONSTY> const &b) -> bool {
  return !operator==(a, b);
}

template<typename FILES_CONSTY, typename STREAM_CONSTY> scold::files::Iterator<FILES_CONSTY, STREAM_CONSTY>::Iterator(files_type *arg_owner, Phase arg_position)
  : ancestor()
  , owner(arg_owner)
  , position(arg_position) {
  ;
}

template<typename FILES_CONSTY, typename STREAM_CONSTY> auto scold::files::Iterator<FILES_CONSTY, STREAM_CONSTY>::operator++() -> Iterator & {
  position = succ(position);
  return *this;
}

template<typename FILES_CONSTY, typename STREAM_CONSTY> auto scold::files::Iterator<FILES_CONSTY, STREAM_CONSTY>::operator++(int) -> Iterator {
  Iterator old(*this);
  operator++();
  return *this;
}

#import scold.phase.Definition
#include <cassert>
template<typename FILES_CONSTY, typename STREAM_CONSTY> auto scold::files::Iterator<FILES_CONSTY, STREAM_CONSTY>::operator*() -> typename ancestor::value_type & {
  // FIXME ... this is the single line of code that is distinct between scold::filenames::Iterator<...> and scold::files::Iterator<...>; see also scold::streams::Iterator<...>
  phase::Definition def(position);
  auto index = def.index();
  assert(0 <= index && index < sizeof (owner->streams)/sizeof (owner->streams[0]));
  return owner->streams[index];
}
#endiv
