// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#forward scold.Accruals
namespace scold {
  //
  // Dependencies for make
  //
  // $(lhs) : $(objdir)/package/subpackage/component/Class
  // $(lhs) : $(objdir)/fpp/package.subpackage.component.Class
  // $(lhs) : $(objdir)/package/subpackage/component/Class.cpp
  //
  template<> class scold::Accruals<DEPEND>;
}
#endiv
#divert <hpp>
#import scold.Filenames
#import scold.Module
#import scold.Regeneration
#import scold.Stream
#import std.string
#import std.set
template<> class scold::Accruals<scold::DEPEND> {
public:
  // For the meaning of the arguments, see the public member variables (below)
  inline Accruals(std::string const &lhs, std::string const &modulesdir, std::string const &objdir, std::string const &srcdir, std::string const &make_script, Regeneration regeneration);
  //
  // Configurations
  //
  // The lhs of a (GNU-)make dependency; may be partially symbolic
  // e.g. obj/src/path/example.lo             i.e. no variables
  // e.g. $(objdir)/path/example.lo           i.e. some variables
  // e.g. $(objdir)/path/example.$(lo)        i.e. full dress variables
  //
  std::string lhs;
  // The "modulesdir" directory for dependency creation; may be a symbolic name.
  // e.g. $(modulesdir)
  std::string modulesdir;
  // The "objdir" directory for dependency creation; may be a symbolic name.
  // e.g. $(objdir)
  std::string objdir;
  // The "srcdir" directory for dependency creation; may be a symbolic name.
  // e.g. $(srcdir)
  std::string srcdir;
  //
  // The MAKE_DEPEND_SCRIPT from configure.ac
  //
  //     obj/modules/fpp/sqar.CONFIG : src/sqar/CONFIG.xcpp
  //     	$(bbDC) $(bbDC_FLAGS) $(SEARCHPATH) $<  <------------------- this line
  //     ^
  //     |
  //     \---------- \t (tab)
  //
  std::string make_script;
  //
  // Regeneration, now defaults to two-step
  // See the documentation in scold.Regeneration
  //
  scold::Regeneration regeneration;
  //
  // Accruals
  //
  // Accrual of the (GNU)make style dependencies
  Stream out;
  // Accrual of the modules upon which this one depends
  std::set<Module> antecedents;
  // generate and insert basic recomputation stanza chain
  auto generate_recomputation_stanza(Filenames const &) -> void;
};

#endiv
#divert <ipp>
scold::Accruals<scold::DEPEND>::Accruals(std::string const &arg_lhs, std::string const &arg_modulesdir, std::string const &arg_objdir, std::string const &arg_srcdir, std::string const &arg_make_script, Regeneration regeneration)
  : lhs(arg_lhs)
  , modulesdir(arg_modulesdir)
  , objdir(arg_objdir)
  , srcdir(arg_srcdir)
  , make_script(arg_make_script)
  , regeneration{regeneration}
  , out()
  , antecedents() {
  ;
}
#endiv
#divert <cpp>
#import scold.fragment.make.declare
#import scold.fragment.make.depend
#import scold.fragment.make.script_rm
#import scold.Suffix
#import scold.version.String
#import std.underlying_type
#import std.ostringstream
auto scold::Accruals<scold::DEPEND>::generate_recomputation_stanza(Filenames const &filenames) -> void {
  namespace make = scold::fragment::make;
  auto const regeneration_version_tag_comment = [](Regeneration regeneration) {
                                                  std::ostringstream buf;
                                                  buf << "# dc  version " << version::String{} << " regeneration (algorithm) " << (std::underlying_type<Regeneration>::type) regeneration << '\n';
                                                  return line::Item{buf.str()};
                                                }(regeneration);

  // WATCHOUT - this is super delicate ... the dependency chain must work the same for all files
  //
  // Recipe herein:             (with A->B meaning "A depends B" or "A is regeneratable from B"
  //
  //   LO -> MK
  //   O --> MK -> TPP -> IPP -> HPP -> FPP -> CPP
  //
  // Recipe out in userland in .../Makefrag.am
  //
  //   CPP -> XCPP
  // 
  // And the user (the project) MUST use the two-step method for re-disaggregating the XCPP -> CPP (et al.)
  //
  //   $(lib_libscold_la_SOURCES) : obj/src/%.cpp : src/%.xcpp <---------------------------- (XCPP -> CPP)
  //   	   $(STEP1) $(call bbHGTW_DISAGGREGATE_COMPILE, $@)
  //   $(scold_cxxdir)/scold/dependencies.mk: <--------------------------------------------- disaggregate && dependencies
  //       $(BOTH) $(call bbHGTW_COMPILE, $(lib_libscold_la_SOURCES))
  // 
  out << regeneration_version_tag_comment;
  out << make::depend(objdir, filenames[Suffix::O], objdir, filenames[Suffix::MK]);
  out << make::depend(objdir, filenames[Suffix::LO], objdir, filenames[Suffix::MK]);
  out << make::depend(objdir, filenames[Suffix::MK], modulesdir, filenames[Suffix::TPP]);
  out << make::depend(modulesdir, filenames[Suffix::TPP], modulesdir, filenames[Suffix::IPP]);
  out << make::depend(modulesdir, filenames[Suffix::IPP], modulesdir, filenames[Suffix::HPP]);
  out << make::depend(modulesdir, filenames[Suffix::HPP], modulesdir, filenames[Suffix::FPP]);
  out << make::depend(modulesdir, filenames[Suffix::FPP], objdir, filenames[Suffix::CPP]);

  auto const l1 = line::Item("\t" + make_script);
  if (Regeneration::ONE_STEP == regeneration) {
    // WATCHOUT - it is not clear that the ONE_STEP method is correct.
    // WATCHOUT - under ONE-STEP - both *.cpp  and *.mk need to exist together (or both be missing) because of the rules (above)
    // And the ONE-STEP method is the Old Way..
    out << make::depend(objdir, filenames[Suffix::MK], srcdir, filenames[Suffix::XCPP])
        << l1;
    out << make::depend(objdir, filenames[Suffix::CPP], srcdir, filenames[Suffix::XCPP])
        << l1;
  }

  //
  // https://www.gnu.org/software/automake/manual/html_node/Clean.html
  // Concept of the heuristic of cleandliness
  // 
  // make mostlyclean
  // make clean
  // make distclean
  // make maintainer-clean
  // 
  // If make built it,
  //     if it is commonly something that one would want to rebuild
  //         (for instance, a .o file),
  //         then mostlyclean should delete it.
  //     else
  //         then clean should delete it.
  // If configure built it,
  //     then distclean should delete it.
  // If the maintainer built it
  //     (for instance, a .info file),
  //     then maintainer-clean should delete it.
  // 
  // Of course, maintainer-clean should not delete anything that needs to exist in order to run ‘./configure && make’. 
  //
  // This assumes the automake convention that the '-local'-suffixed productions are
  // reserved to the programmer.  And we use '::' eo append to the rules.
  //
  constexpr make::Rule const ruletype = make::Rule::COLON_COLON;
  out << make::declare("mostlyclean-local", ruletype);
  out << make::script_rm(objdir, filenames[Suffix::O], filenames[Suffix::LO]);

  out << make::declare("clean-local", ruletype);
  out << make::script_rm(modulesdir, filenames[Suffix::FPP], filenames[Suffix::HPP], filenames[Suffix::IPP], filenames[Suffix::TPP]);
  // WATCHOUT - both *.cpp  and *.mk need to exist together (or both be missing) because of the rules (above)
  out << make::script_rm(objdir, filenames[Suffix::CPP]);
  out << make::script_rm(objdir, filenames[Suffix::MK]);
}
#endiv
