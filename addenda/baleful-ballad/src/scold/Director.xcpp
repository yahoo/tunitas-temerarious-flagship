// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  struct Director;
}
#endiv
#divert <hpp>
#import scold.config.Context
#import scold.config.Generic
#import scold.Stream
#import scold.search.Build
#import scold.Processor
#import scold.processor.Forward
#import scold.processor.Import
#import scold.processor.Entail
#import scold.processor.Error
#import scold.processor.Nop
#import scold.processor.Source
#import want.regex.pattern
struct scold::Director {
  Director(config::Generic const &, config::Context &, search::Build /*nonconst*/ &);
  // Dispatch a nop on an independently managed empty, un-numbered line.
  auto operator()() -> Processor;
  // Examine the line, dispatch a processor to process it.
  using line_type = Stream::value_type;
  auto operator()(line_type &) -> Processor;
protected:
  want::regex::pattern const CPP_DIRECTIVE;
  want::regex::pattern const SCOLD_DIRECTIVE;
  processor::Nop     nop;
  processor::Forward forward;
  processor::Import  import;
  processor::Entail  entail;
  processor::Error   error;
  processor::Source  source;
};
#endiv
#divert <cpp>
scold::Director::Director(config::Generic const &cfg, config::Context &ctx, search::Build &build)
  : CPP_DIRECTIVE(R"regex(^\s*#\s*(include|ifdef|if|endif|define)\b.*)regex")
    // a broad pattern which is refined within each line processor
    // overbroadly match so that errors can be reasonably reported for close-to-correct syntax
  , SCOLD_DIRECTIVE(R"regex(^\s*#\s*(import|forward|entail)\b.*)regex")
  , nop(cfg, ctx)
  , forward(cfg, ctx, build)
  , import(cfg, ctx, build)
  , entail(cfg, ctx, build)
  , error(cfg, ctx)
  , source(cfg, ctx) {
  ;
}

auto scold::Director::operator()() -> Processor {
  return Processor(nop.EMPTY, nop);
}

#import want.regex.match 
#import want.regex.smatch 
auto scold::Director::operator()(line_type &line) -> Processor {
  want::regex::smatch sm;
  if (want::regex::match(value(line), sm, CPP_DIRECTIVE)) {
    return Processor(line, source);
  } else if (want::regex::match(value(line), sm, SCOLD_DIRECTIVE)) {
    auto keyword = sm[1];
    if ("forward" == keyword) {
      return Processor(line, forward);
    } else if ("import" == keyword) {
      return Processor(line, import);
    } else if ("entail" == keyword) {
      return Processor(line, entail);
    } else {
      // somewhat botched
      return Processor(line, error);
    }
  } else {
    // This means that the C++ Preprocessor gets to see & report on all botched #-commencing lines
    return Processor(line, source);
  }
}
#endiv
