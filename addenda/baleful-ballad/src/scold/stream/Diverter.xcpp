// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace stream {
    class Diverter;
  }
}
#endiv
#divert <hpp>
#import scold.stream.Processor
#import scold.stream.Imputer
#import scold.Streams
class scold::stream::Diverter : public Processor {
  using ancestor = Processor;
public:
  inline Diverter(config::Generic const &, config::Context &);
  using input_type = Imputer::output_type;
  using output_type = Streams;
  inline auto operator()(input_type &&) -> output_type;
};
#endiv
#divert <ipp>
scold::stream::Diverter::Diverter(config::Generic const &arg_cfg, config::Context &arg_ctx)
  : ancestor(arg_cfg, arg_ctx) {
  ;
}

#import scold.Ground
#import std.move
auto scold::stream::Diverter::operator()(input_type &&anon) -> output_type {
  input_type in(std::forward<input_type>(anon));
  Streams out;
  using record = Streams::stream_type::value_type;
  for (auto &tuple: in) {
    auto ground = std::get<0>(tuple);
    auto lineno = std::get<2>(tuple);
    auto &line = std::get<3>(tuple);
    auto rec = record(lineno, std::move(line));
    switch (ground) {
    case Ground::FORE:
      {
        auto phase = std::get<1>(tuple);
        out[phase] << rec;
      }
      break;
    case Ground::BACK:
      {
        out << rec;
      }
      break;
    case Ground::UNUSEABLE:
    default: // there are no other enumerators to handle
      // drop it (silently, bitching already occurred)
      break;
    }      
  }
  return out;
}
#endiv
