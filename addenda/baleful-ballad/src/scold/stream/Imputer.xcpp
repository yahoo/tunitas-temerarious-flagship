// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace stream {
    class Imputer;
  }
}
#endiv
#divert <hpp>
#import scold.stream.Processor
#import scold.Ground
#import scold.Phase
#import scold.Reader
#import std.vector
#import std.string
#import std.size_t
#import std.tuple
class scold::stream::Imputer : public Processor {
  using ancestor = Processor;
public:
  inline Imputer(config::Generic const &, config::Context &);
  using input_type = Reader::output_type;
  using output_type = std::vector<std::tuple<Ground, Phase, line::number_t, std::string>>;
  inline auto operator()(input_type &&) -> output_type;
};
#endiv
#divert <ipp>
scold::stream::Imputer::Imputer(config::Generic const &arg_cfg, config::Context &arg_ctx)
  : ancestor(arg_cfg, arg_ctx) {
  ;
}

#import scold.Phase
#import scold.config.logging
#import scold.stream.Assessor
#import scold.line.Item
#import std.cerr
#import want.format.braket
auto scold::stream::Imputer::operator()(input_type &&in) -> output_type {
  using want::format::braket;
  output_type out;
  Assessor assess;
  std::size_t lineno = 0;
  for (auto &line : in) {
    lineno++;
    auto r = assess(line);
    // indeed, warnings and errors are independent (one can have both)
    if (has_quibbles(r)) {
      line::Item dummy(lineno, line);  // ahem ... get a line number established
      if (has_warning(r)) {
        warning(cfg, ctx, dummy) << warning_message(r) << '\n';
      }
      if (has_error(r)) {
        error(cfg, ctx, dummy) << error_message(r) << '\n';
      }
    }
    if (keep(r)) {
      output_type::value_type assessed(ground(r), diversion(r), lineno, std::move(line));
      out.push_back(std::move(assessed));
    }
  }
  line::Item end(lineno, "");
  if (assess.in_foreground()) {
    error(cfg, ctx, end) << "the file ends inside #divert " << braket(assess.state<Phase>()) << '\n';
  } else if (!assess.in_background()) {
    error(cfg, ctx, end) << "the file ends in an erroneous state at " << assess.state<Ground>() << " in " << braket(assess.state<Phase>()) << "\n";
  } else {
    debug(cfg, ctx, end) << "OK (imputation of back- or fore-ground and phase)\n";
  }
  return out;
}
#endiv
