// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace search {
    namespace cache {
      enum class Type
      { // The module is in the searchpath somewhere (and not otherwise HEREIN or SUBMODULE)
        // This is a default case when the interface or source is not otherwise visible
        // ... it must be, will be, in the SEARCHPATH, materializing as the build progresses.
        INCLUDE = 0,
        // The module is generated from sources that are built herein.
        HEREIN,
        // The module is generated from sources that are built as a submodule.
        SUBMODULE };
    }
  }
}
#endiv
#divert <hpp>
namespace scold {
  namespace search {
    namespace cache {
      //
      // Also see the parallel overloads series
      //   type(Entry), type(Type)
      //   buildable_sources(Entry), buildable_sources(Type)
      //   include_interfaces_only(Entry), include_interfaces_only(Type)
      // ... you get the idea
      //

      // an identity transform
      inline auto type(Type) -> Type;

      // The module of the entry is buildable from sources
      // a) it is built in the current tree
      // b) it is built in a submodule tree
      inline auto buildable_from_sources(Type) -> bool;

      // The module has interface-only import semantics
      // a) it must be in the searchpath now
      // b) it will be in the searchpath as the build progresses
      inline auto include_interfaces_only(Type) -> bool;

    }
  }
}
#endiv
#divert <ipp>
auto scold::search::cache::type(Type t) -> Type {
  return t;
}

auto scold::search::cache::buildable_from_sources(Type t) -> bool {
  return Type::HEREIN == t || Type::SUBMODULE == t;
}

auto scold::search::cache::include_interfaces_only(Type t) -> bool {
  return ! buildable_from_sources(t);
}
#endiv
