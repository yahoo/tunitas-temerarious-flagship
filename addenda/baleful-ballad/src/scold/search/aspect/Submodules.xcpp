// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace search {
    namespace aspect {
      //
      // The submodule lookup; git submodules following the SCOLD paradigm.
      //
      // Usage (via the descendant)
      //
      //     Submodules search(...directories...);
      //     scold::Module module{"std", "iostream"};
      //     auto searched = search(module);
      //     if (ok(searched)) {
      //         std::string fullpath = value(searched);
      //     }
      //
      // The Submodules path
      //     where submodule source code lives.
      //     it does not exist until it is built, so we have to guess
      //
      // Submodules have a triple of directories where the module might exist
      //    modulesdir     -- once built, the module { *.fpp, *.hpp, *.ipp, *.tpp }
      //    objdir         -- once built the module *.cpp exist here
      //    srcdir         -- prior to building, the *.xcpp exists here
      //
      class Submodules;
    }
  }
}
#endiv
#divert <hpp>
#import scold.Submodule
#import scold.Module
#import scold.search.aspect.Prototype
#import std.initializer_list
#import std.string
#import std.vector 
class scold::search::aspect::Submodules : public Prototype {
  using ancestor = Prototype;
public:
  inline static auto promote(std::vector<std::string> const &) -> std::vector<scold::Submodule>;
  inline static auto promote(std::vector<std::string> &&) -> std::vector<scold::Submodule>;
  inline static auto promote(std::initializer_list<std::string>) -> std::vector<scold::Submodule>;
  //
  using submodule_series_type = std::vector<scold::Submodule>;
  inline explicit Submodules(std::initializer_list<scold::Submodule>);
  inline explicit Submodules(submodule_series_type const &);
  inline explicit Submodules(submodule_series_type &&);
  // no copy semantic
  Submodules(Submodules const &) = delete;
  inline auto operator=(Submodules const &) -> Submodules & = delete;
  // a move semantic
  Submodules(Submodules &&) = default;
  auto operator=(Submodules &&) -> Submodules & = default;
  // pesky ... make it easier to construct these things from easily-available materials
  inline explicit Submodules(std::vector<std::string> const &);
  inline explicit Submodules(std::vector<std::string> &&);
  inline explicit Submodules(std::initializer_list<std::string>);
protected:
  inline auto operator_call(cache_aspect &, scold::Module const &) -> result_type;
  submodule_series_type submodule_series;
};
#endiv
#divert <ipp>
#import std.forward
#import std.move

auto scold::search::aspect::Submodules::promote(std::vector<std::string> const &vs) -> std::vector<scold::Submodule> {
  std::vector<scold::Submodule> ret;
  for (auto const &s : vs) {
    ret.emplace_back(s);
  }
  return ret;
}

auto scold::search::aspect::Submodules::promote(std::vector<std::string> &&anon) -> std::vector<scold::Submodule> {
  std::vector<scold::Submodule> ret;
  for (auto &s : anon) {
    ret.emplace_back(std::move(s));
  }
  return ret;
}

auto scold::search::aspect::Submodules::promote(std::initializer_list<std::string> il) -> std::vector<scold::Submodule> {
  std::vector<std::string> pre(il);
  return promote(std::move(pre));
}

scold::search::aspect::Submodules::Submodules(std::vector<std::string> const &vs)
  : Submodules(promote(vs)) {
  ;
}

scold::search::aspect::Submodules::Submodules(std::vector<std::string> &&anon)
  : Submodules(promote(std::forward<std::vector<std::string>>(anon))) {
  ;
}

scold::search::aspect::Submodules::Submodules(std::initializer_list<std::string> il)
  : Submodules(promote(il)) {
  ;
}

scold::search::aspect::Submodules::Submodules(std::initializer_list<scold::Submodule> il)
  : submodule_series(il) {
  ;
}

scold::search::aspect::Submodules::Submodules(submodule_series_type const &arg_path)
  : submodule_series(arg_path) {
  ;
}

#import std.forward
scold::search::aspect::Submodules::Submodules(submodule_series_type &&anon)
  : submodule_series(std::forward<submodule_series_type>(anon)) {
  ;
}

#import mvr.andvalue 
#import scold.to
#import std.string
auto scold::search::aspect::Submodules::operator_call(cache_aspect &aspect, scold::Module const &module) -> result_type {
  auto basename = to<std::string>(module);
  auto i = aspect.cache.find(basename);
  auto e = aspect.cache.end();
  if (e != i) {
    return mvr::andvalue<result_type::value_type>(i->second);
  } else {
    for (auto const &submodule : submodule_series) {
      auto probed = probe_and_cache(aspect, cache::Type::SUBMODULE, submodule, module);
      if (ok(probed)) {
        return probed;
      }
    }
    return mvr::andvalue<result_type::value_type>(); // do not cache the negative result
  }
}
#endiv
