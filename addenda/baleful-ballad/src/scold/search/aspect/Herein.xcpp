// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace search {
    namespace aspect {
      //
      // Probe the current build area "here"
      //
      // Usage (via the descendant)
      //
      //     Herein search(...directory...)
      //     scold::Module module{"std", "iostream"}; <------------ probe this
      //     auto searched = search(module);
      //     if (ok(searched)) {
      //         std::string directory = value(searched); <-------- the directory
      //         ...use directory...
      //     }
      //
      // The path for the build "here"
      // like Submodule, but only for a single directory.
      //
      // Heres have a triple of directories where the module might exist
      //    modulesdir     -- once built, the module { *.fpp, *.hpp, *.ipp, *.tpp }
      //    objdir         -- once built the module *.cpp exist here
      //    srcdir         -- prior to building, the *.xcpp exists here
      //
      class Herein;
    }
  }
}
#endiv
#divert <hpp>
#import scold.Module
#import scold.Submodule
#import scold.search.aspect.Prototype
#import std.string
#import mvr.SAV
class scold::search::aspect::Herein : public Prototype {
  using ancestor = Prototype;
public:
  inline explicit Herein(scold::Submodule const &builddir);
  inline explicit Herein(scold::Submodule &&builddir);
  // no copy semantic
  Herein(Herein const &) = delete;
  auto operator=(Herein const &) -> Herein & = delete;
  // a move semantic
  Herein(Herein &&) = default;
  auto operator=(Herein &&) -> Herein & = default;
  // pesky ... make it easier to construct these things from easily-available materials
  inline explicit Herein(std::string const &builddir_is_here);
  inline explicit Herein(std::string &&builddir_is_here);
protected:
  inline auto operator_call(cache_aspect &, scold::Module const &) -> result_type;
  scold::Submodule builddir;
};
#endiv
#divert <ipp>
#import std.forward
#import std.move

scold::search::aspect::Herein::Herein(std::string const &arg_builddir)
  : builddir(arg_builddir) {
  ;
}

scold::search::aspect::Herein::Herein(std::string &&anon)
  : builddir(std::forward<std::string>(anon)) {
  ;
}

scold::search::aspect::Herein::Herein(scold::Submodule const &arg_builddir)
  : builddir(arg_builddir) {
  ;
}

#import std.forward
scold::search::aspect::Herein::Herein(scold::Submodule &&anon)
  : builddir(std::forward<scold::Submodule>(anon)) {
  ;
}

#import mvr.andvalue
#import scold.to
#import std.string
auto scold::search::aspect::Herein::operator_call(cache_aspect &aspect, scold::Module const &module) -> result_type {
  auto basename = to<std::string>(module);
  auto i = aspect.cache.find(basename);
  auto e = aspect.cache.end();
  if (e != i) {
    return mvr::andvalue<result_type::value_type>(i->second);
  } else {
    auto probed = probe_and_cache(aspect, cache::Type::HEREIN, builddir, module);
    if (ok(probed)) {
      return probed;
    }
    return mvr::andvalue<result_type::value_type>(); // do not cache the negative result
  }
}
#endiv
