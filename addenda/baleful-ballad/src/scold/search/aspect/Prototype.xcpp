// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace search {
    namespace aspect {
      // The prototype of the search aspect
      class Prototype;
    }
  }
}
#endiv
#divert <hpp>
#import mvr.SAV
#import scold.Module
#import scold.Submodule
#import scold.search.cache.Type
#import scold.search.cache.Entry
#forward scold.search.cache.Unit
#import std.string
class scold::search::aspect::Prototype {
protected:
  ~Prototype() = default; // descendants only
public:
  Prototype() = default;
  // The operator()(...) of the final descendant returns such a result type.
  using result_type = mvr::SAV<cache::Entry>;
protected:
  // The final descendant will bind a Cache with the search aspect.
  using cache_aspect = cache::Unit;
  using cache_type = cache::Type;
  auto probe_and_cache(cache_aspect &, cache_type, std::string const &directory, std::string const &basename) -> result_type;
  auto probe_and_cache(cache_aspect &, cache_type, scold::Submodule const &building, scold::Module const &module) -> result_type;
};
#endiv
#divert <ipp>
#import scold.search.cache.Entry
#import scold.search.cache.Unit
#endiv
#divert <cpp>
#import mvr.andvalue
#import scold.fragment.workbench
#import sys.posix.exists
auto scold::search::aspect::Prototype::probe_and_cache(cache_aspect &aspect, cache_type type, std::string const &directory, std::string const &basename) -> result_type {
  using sys::posix::exists;
  using scold::fragment::workbench;
  //
  // If directory / basename exists
  // return directory
  //
  auto candidate = finalize(workbench() * directory / basename);
  if (exists(candidate)) {
    // don't return candidate, instead return the precursor, the directory where it will be found.
    auto ret = aspect.cache[basename] = cache::Entry(type, directory);
    return mvr::andvalue<result_type::value_type>(ret);
  }
  // failure to find.
  // DO NOT attempt to cache negative lookups.
  // There will be other aspects that probe_and_cache using other searchpaths.
  return mvr::andvalue<result_type::value_type>();
}

#import mvr.andvalue
#import scold.Filenames
#import scold.Suffix
#import scold.to
#import sys.posix.exists
#import want.series
auto scold::search::aspect::Prototype::probe_and_cache(cache_aspect &aspect, cache_type type, scold::Submodule const &building, scold::Module const &module) -> result_type {
  using sys::posix::exists;  
  //
  // If .../external/$submodule/src/package/subpackage/Component.xcpp exists
  // return .../external/$submodule
  //
  Filenames const filenames = to<Filenames>(module, modulesdir(building), objdir(building), srcdir(building));
  //
  // Only probe the tpp and xcpp phases (the fpp, hpp, ipp are redundant in tpp).
  // Prefer the already-built (*.tpp) one over the source yet-to-be-built (*.xcpp).
  //
  // WATCHOUT - this function returns true if the disaggregated modules are not yet disaggregatedd
  // WATCHOUT - BUT the source code is visible in the submodule tree
  // WATCHOUT -               WATCHOUT visible for any reason whatsoever (especially when visible but not mentioned in a nearby Makefile .../Makefrag.am)
  //
  // WATCHOUT - To wit:
  // WATCHOUT -     missing:   external/module-c-string/obj/modules/c.argv
  // WATCHOUT -     found:     external/module-c-string/src/c/argv.xcpp
  // WATCHOUT -     return     external/module-c-string/obj/modules <---------- is this the wrong answer when external/module-c-string is never built?
  // WATCHOUT -                                                                 arguably, this is the wrong answer when external/module-s-string is not built.
  //
  for (auto suffix : want::series(Suffix::TPP, Suffix::XCPP)) {
    auto const &candidate = filenames[suffix];
    if (exists(candidate)) {
      // don't return candidate, instead return the directory where it will be found 
      auto ret = aspect.cache[to<std::string>(module)] = cache::Entry(type, modulesdir(building));
      return mvr::andvalue<result_type::value_type>(ret);
    }
  }
  // failed to find
  // ... NO: do not cache negative lookups
  // ... ... some other aspect may find it elsewhere (and cache it)
  return mvr::andvalue<result_type::value_type>();
}
#endiv
