// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold {
  namespace processor {
    //
    // Handle the external modules.
    //
    // This is harder than it looks.
    // We may be building the module herein or in one of the submodules.
    // That copy, once built, MUST override the (legacy, global) copy.
    // The local module might not be constituted yet (not in the searchpath),
    // so we have to probe for the sources of it.
    //
    // Example:
    //     /opt/scold/modules/c.argv
    //     .../dev/external/modules-c-string/src/c/argv.xcpp
    //     .../dev/src/mypackage/Class.xcpp
    //
    // c.argv is already built and available
    // c.argv will be built as a submodule of the current build
    // 'dev' with mypackage.Class
    //
    // Counter-Example:
    //     /opt/scold/modules/std.uint64_t <---------------------------- installed, in the searchpath (not buildable from source)
    //     .../dev/external/modules-std/modules/std.uint64_t <---------- hand-coded, in the searchpath (not buildable from source)
    //     .../dev/src/mypackage/Class.xcpp
    //
    // Reminder: the submodules have non-buildable sources in .../include and .../modules
    //           the submodules produce buildable sources in .../obj/modules and .../obj/src
    //
    //
    // Priorities:
    // 1. does the module already exist in the searchpath? (via -Idirectory)
    // 2. does the module already exist
    //    or will the module exist in the submodules of the project?  (via -Erootdir)
    //
    // reminder the submodules (-Erootdir) consist of two parts
    //    $rootdir/include         use -I$rootdir/include
    //    $rootdir/modules         use -I$rootdir/modules
    //    $rootdir/obj/modules     implied by -E$rootdir
    //    $rootdir/obj/src         implied by -E$rootdir
    //    $rootdir/src             implied by -E$rootdir
    //
    // Usage
    //     auto r = probe(module)
    //     if (buildable_from_sources(r)) {
    //        ...built by us in this tree so $(modulesdir) is appropriate
    //     } else if (include_interfaces_only(r)) {
    //        ...just buy the interface, as declared, the location is unclear but in the searchpath
    //     } else {
    //        ...built by us nearby, as a submodule, so the directory(r) is the place to find it
    //     }
    // 
    class Externals;
  }
}
#endiv
#divert <hpp>
#import scold.Module
#import scold.search.Build
#import std.string
#import scold.search.cache.Entry
#import mvr.SAV
class scold::processor::Externals {
protected:
  // non-const references because the objects self-update their caches upon discovery.
  inline explicit Externals(search::Build &);
  // A reference to the (shared, cache-heavy) searchpath(s).
  // Shared amongst the many different processors (foward, import, entail, etc.)
  search::Build &build;
public:
  // using result_type = search::Build::result_type;
  using result_type = mvr::SAV<search::cache::Entry>;
  inline auto probe(Module const &) -> result_type;
};
#endiv
#divert <ipp>
scold::processor::Externals::Externals(search::Build &arg_build)
  : build(arg_build) {
  ;
}

#import mvr.andvalue
#import std.move
auto scold::processor::Externals::probe(Module const &query) -> result_type {
  return build(query);
}
#endiv
