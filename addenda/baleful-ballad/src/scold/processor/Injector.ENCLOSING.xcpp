// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#forward scold.processor.Injector
namespace scold {
  namespace processor {
    enum ENCLOSING { };
    template<> class Injector<ENCLOSING>;
  }
}
#divert </fpp>
#divert <hpp>
#import scold.Configuration
#import scold.Director
#import scold.Filenames
#import scold.Module
#import scold.Processor
#import scold.processor.Redirector
#import scold.Stream
#import std.string
template<> class scold::processor::Injector<scold::processor::ENCLOSING> : public Redirector {
  using ancestor = Redirector;
public:
  inline Injector(configuration_type const &, context_type const &, director_type &);
  //
  // reminder, the scold_source_directory is available in ancestor::cfg.scold_source_directory
  //
  inline auto operator()(std::string const &filename_xcpp) -> Processor;
  inline auto operator()(Module const &) -> Processor;
  inline auto operator()(Filenames const &) -> Processor;
protected:
  inline auto inject(Filenames const &) -> Processor;
  // We have to put the synthesized lines someplace.
  Stream sink;
};
#endiv
#divert <ipp>
scold::processor::Injector<scold::processor::ENCLOSING>::Injector(configuration_type const &arg_cfg, context_type const &arg_ctx, director_type &arg_director)
  : ancestor(arg_cfg, arg_ctx, arg_director) {
  ;
}

auto scold::processor::Injector<scold::processor::ENCLOSING>::operator()(std::string const &filename_xcpp) -> Processor {
  auto this_module_filenames = to<Filenames>(filename_xcpp, cfg.scold_source_directory.literal);
  return inject(this_module_filenames);
}

auto scold::processor::Injector<scold::processor::ENCLOSING>::operator()(Module const &this_module) -> Processor {
  auto this_module_filenames = to<Filenames>(this_module, cfg.scold_source_directory.literal);
  return inject(this_module_filenames);
}

auto scold::processor::Injector<scold::processor::ENCLOSING>::operator()(Filenames const &this_module_filenames) -> Processor {
  return inject(this_module_filenames);
}

#import scold.ispure
#import scold.line.Item
#import scold.Module
#import scold.fragment.preproc.import
#import scold.Suffix
#import scold.to
auto scold::processor::Injector<scold::processor::ENCLOSING>::inject(Filenames const &this_module_filenames) -> Processor {
  // Is a pure namspace module.  So, do it: inject.
  // ... but guard against other conditions
  if (!cfg.insert_namespace) {
    // import nothing because we were directed as such
    sink << line::Item("// a placeholder, because --no-insert-namespace");
  } else if (ispure(this_module_filenames) && !cfg.matryoshka_namespace_nesting) {
    // (a policy choice)
    // import nothing when a pure namesaces (no nested Russian dolls)
    sink << line::Item("// a placeholder, there is no enclosing namespace");
  } else {
    // #import a.b when we're working with a.b.Class
    // #import a.b when we're working with a.b.Caller.DEFINITION.DEFINITIONS
    Module enclosing_module = to<Module>(this_module_filenames[Suffix::NS], cfg.scold_source_directory.literal);
    if (enclosing_module.empty()) {
      // import nothing because there is no enclosing namespace
      sink << line::Item("// a placeholder, there is no enclosing namespace");
    } else {
      using namespace scold::fragment::preproc;
      auto injected = import(enclosing_module);
      debug(cfg) << "import of enclosing namespace: " << value(injected) << '\n';
      sink << injected;
    }
  }
  return director(sink.back());
}
#endiv
