// -*- c++ -*- in the SCOLD styling that is so fashionable these days
#divert <fpp>
namespace scold {
  namespace fragment {
    namespace detail {
      enum class Quote
      {   NOT,         // e.g. #import some.module.name; same for #forward, #entail 
          DOUBLE,      // e.g. #include "some.module.name", #include "hpp/some.module.name"
          ANGLE };     // e.g. #include <some.module.name>, #include <fpp/some.module.name>
    }
  }
}
#endiv
#divert <hpp>
#import scold.module.Module
#import path.filename.mount.Value
#import scold.line.Item
namespace scold {
  namespace fragment {
    namespace detail {
      // ahem, constexpr seems overkill here, but you get the point.
      inline constexpr auto is_angle(Quote) -> bool;
      inline constexpr auto is_double(Quote) -> bool;
      inline constexpr auto is_not(Quote) -> bool;

      //
      // Both (X-)SCOLD and CPP use the same #ifdef preprocessor paradigm
      //
      // recall that <module> and "module" are "mostly" the same thing
      // and X-SCOLD passes #include through to cpp which acts upon it.
      //
      // Quoting is fraught:
      //
      //     #include "module"        speaking to CPP or SCOLD
      //     #include "filename"      speaking to CPP, finds nearby directory filename, filesname in the searchpath
      //     #include <filename>      speaking to CPP, finds filename in the searchpath
      //     #import module
      //     #entail module
      //     #forward module
      //
      // Thus the 'directive' is one of { entail, forward, import, include }
      //

      inline auto ifdef(char const *directive, Quote, module::Module const &) -> line::Item;
      inline auto ifdef(char const *directive, Quote, std::string const &filename) -> line::Item;
      inline auto ifdef(char const *directive, Quote, path::filename::mount::Value &&) -> line::Item;
    }
  }
}

constexpr auto scold::fragment::detail::is_angle(Quote quote) -> bool {
  return Quote::ANGLE == quote;
}

constexpr auto scold::fragment::detail::is_double(Quote quote) -> bool {
  return Quote::DOUBLE == quote;
}

constexpr auto scold::fragment::detail::is_not(Quote quote) -> bool {
  return Quote::NOT == quote;
}
#endiv
#divert <ipp>
#import std.ostringstream
#import format.qq
#import format.braket
#import std.runtime_error

#import scold.to
auto scold::fragment::detail::ifdef(char const *directive, Quote quote, module::Module const &module) -> line::Item {
  return ifdef(directive, quote, to<std::string>(module));
}
#import nonstd.exception.Invalid_Enum
auto scold::fragment::detail::ifdef(char const *directive, Quote quote, std::string const &filename) -> line::Item {
  using namespace format;
  std::ostringstream buf;
  buf << "#" << directive << " ";
  if (is_double(quote)) {
    buf << qq(filename);
  } else if (is_angle(quote)) {
    buf << braket(filename);
  } else if (is_not(quote)) {
    buf << filename;
  } else {
    throw nonstd::exception::Invalid_Enum{quote};
  }
  return line::Item(buf.str());
}

#import std.forward
auto scold::fragment::detail::ifdef(char const *directive, Quote quote, path::filename::mount::Value &&anon) -> line::Item {
  return ifdef(directive, quote, finalize(std::forward<path::filename::mount::Value>(anon)));
}
#endiv
