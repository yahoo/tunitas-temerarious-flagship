// -*- c++ -*- in the SCOLD styling that is so popular these days
#divert <hpp>
#import scold.Configuration
namespace scold {
  //
  // Process a *.xcpp file according to the configuration.
  // Throws on errors
  //   scold::exception::Unprocessed
  //   scold::exception::Quitting on serious errors (e.g. a regex failure, an internal error?)
  //
  // Usage #1:
  //     for (auto const &filename : ...some_filenames...) {
  //       process(cfg, filename);
  //     }
  //
  // Usage #2:
  //     for (auto const &filename : ...some_filenames...) {
  //       try {
  //         process(cfg, filename);
  //       } catch (exception::Unprocessed const &e) {
  //         std::cerr << e.what() << '\n';
  //       }
  //     }
  //
  auto process(Configuration const &cfg, std::string const &filename) -> void;
}
#endiv
#divert <cpp>
#import format.qq
#import format.tuple
#import nonstd.copy
#import mvr.recv
#import scold.Accruals
#import scold.config.Context
#import scold.Director
#import scold.Directories
#import scold.directories.Failure
#import scold.exception.Quitting
#import scold.exception.Unprocessed
#import scold.Filenames
#import scold.filenames.relativize
#import scold.Files
#import scold.line.literal
#import scold.Makefrag
#import scold.module.enclosing
#import scold.module.Module
#import scold.fragment.preproc.include
#import scold.fragment.workbench
#import scold.phase.range
#import scold.Phases
#import scold.PIO
#import scold.pluralize
#import scold.processor.Injector
#import scold.Reader
#import scold.search.Build
#import scold.stream.Imputer
#import scold.stream.Diverter
#import scold.Streams
#import scold.Suffix
#import scold.suffix.resuffix
#import scold.to
#import slurp.Failure
#import std.dec
#import std.error_code
#import std.exception
#import std.hex
#import std.ios.failure
#import std.is_same
#import std.logic_error
#import std.ostringstream
#import std.regex_error
#import std.string
#import std.system_error
#import sys.exits.constants
#import uuid.generate.random
#import want.regex.error
#import want.tuppelgang
#import want.format.braket
auto scold::process(Configuration const &cfg, std::string const &filename) -> void {
  try {
    using format::qq;
    using scold::fragment::preproc::include;
    using scold::fragment::workbench;
    using scold::line::literal;
    using scold::processor::Injector;
    using scold::processor::ENCLOSING;
    using want::tuppelgang;
    using want::format::braket;
    config::Context ctx(filename);
    Module module = to<Module>(filename, cfg.scold_source_directory.literal);
    Filenames filenames = to<Filenames>(module, cfg.cplusplus_modules_directory.literal, cfg.cplusplus_objects_directory.literal, cfg.scold_source_directory.literal);
    Filenames relfilenames = relativize(filenames, cfg.cplusplus_modules_directory.literal, cfg.cplusplus_objects_directory.literal, cfg.scold_source_directory.literal);
    debug(cfg) << "process variables {"
               << "\ninsert_namespace=" << cfg.insert_namespace
               << "\nmatryoshka_namespace_nesting=" << cfg.matryoshka_namespace_nesting
               << "\nmodulesdir-directory=" << cfg.cplusplus_modules_directory.literal
               << "\nmodulesdir-variable=" << cfg.cplusplus_modules_directory.symbolic
               << "\nobjdir-directory=" << cfg.cplusplus_objects_directory.literal
               << "\nobjdir-variable=" << cfg.cplusplus_objects_directory.symbolic
               << "\nsrcdir-directory=" << cfg.scold_source_directory.literal
               << "\nsrcdir-variable=" << cfg.scold_source_directory.symbolic
               << "\nmake-depend-script=" << cfg.make_depend_script
               << "\nmodule=" << module
               << "\nfilenames[fpp]=" << filenames[Phase::FPP] 
               << "\nfilenames[hpp]=" << filenames[Phase::HPP] 
               << "\nfilenames[ipp]=" << filenames[Phase::IPP] 
               << "\nfilenames[tpp]=" << filenames[Phase::TPP] 
               << "\nfilenames[cpp]=" << filenames[Phase::CPP] 
               << "\nfilenames[ns]=" << filenames[Suffix::NS] 
               << "\nfilenames[o]=" << filenames[Suffix::O]
               << "\nfilenames[mk]=" << filenames[Suffix::MK]
               << "\n}\n";
    Directories directories;
    directories.exceptions(true);
    // TODO -- set up a guardian that will remove the empty files if an error is thrown before success.
    Files storage;
    storage.exceptions(std::ios::failbit|std::ios::badbit);
    Makefrag makefrag;
    makefrag.exceptions(std::ios::failbit|std::ios::badbit);
    if (!cfg.dry_run_mode) {
      if (cfg.verbose_mode) {
        if (cfg.make_directories) {
          verbose(cfg) << "making intermediate directories for " << filename << '\n';
          for (auto d : directories.list(filenames)) {
            verbose(cfg) << "making directory " << d << '\n';
          }
        }
        verbose(cfg) << "opening C++ files for " << filename << '\n';
        for (auto p : Phases()) {
          verbose(cfg) << "opening phase " << p << " as " << filenames[p] << '\n';
        }
        verbose(cfg) << "opening GNU makefile fragment " << filenames[Suffix::MK] << '\n';
      }
      if (cfg.make_directories) {
        directories.mkdir(filenames);
      }
      storage.open(filenames);
      makefrag.open(filenames);
    }
    Streams outs;
    Accruals<DEPEND> depends(filenames[Suffix::LO],
                             cfg.cplusplus_modules_directory.symbolic,
                             cfg.cplusplus_objects_directory.symbolic,
                             cfg.scold_source_directory.symbolic,
                             cfg.make_depend_script,
                             cfg.regeneration);
    try {
      Reader reader;
      stream::Imputer impute(cfg, ctx);
      stream::Diverter divert(cfg, ctx);
      Streams ins = divert(impute(reader(filename)));
      Accruals<IMPORT> imports;
      Accruals<ENTAIL> entails;
      auto build = [&cfg]{
                     auto const &srcdir = cfg.scold_source_directory.literal;
                     auto const &objdir = cfg.cplusplus_objects_directory.literal;
                     auto const &modulesdir = cfg.cplusplus_modules_directory.literal;
                     // copy the values out of the config, don't move out out of the config
                     auto top = Submodule{modulesdir, objdir, srcdir};
                     auto subs = search::aspect::Submodules::promote(cfg.SUBMODULES); // this creates a default of <.../obj/modules, .../obj/src, .../src>
                     auto elsewhere = nonstd::copy(cfg.MODULES);
                     return search::Build{move(top), move(subs), move(elsewhere)};
                   }();
      Director director(cfg, ctx, build);
      Injector<ENCLOSING> inject_enclosing(cfg, ctx, director);
      Phases phases;
      depends.out << literal("# -*- Makefile -*- dependencies for " + filename + ", disaggregated by ${dc}-${version} on ${date}");
      depends.generate_recomputation_stanza(relfilenames);
      // FIXME the $dc, $version and $date are not substituted
      outs << literal("// -*- c++ -*- in the SCOLD styling, disaggregated by ${dc}-${version} on ${date}");
      for (auto p : range(Phase::FPP, Phase::CPP)) {
        // reminder: 'pragma once' can only be put in header files
        // 1. gcc complains if it is in a (final) translation unit (i.e. in a .cpp file)
        // 2. it must be substantially the 1st statement in a (header) file
        // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52566
        //     #include with #pragma once and files' contents is the same
        // If the files have the same name and the same timestamp then they are considered to be "the same"
        // and gcc does not include. Yet they are different.  So we need to insert some gratuoutous differences.
        std::ostringstream buf;
        buf << "#pragma once // " << uuid::generate::random() << " (uniqueness to fool gcc)";
        outs[p] << literal(buf.str());
        // MAYBE outs[p] << finalize(?cpp?lb::pragma("once") << " // " << uuid::generate::random() << " (uniqueness to fool gcc)");
      }
      // include the precursors (e.g. fpp, hpp, ipp must precede tpp) and so on.
      inject_enclosing(filenames)(Phase::FPP, outs[Phase::FPP], imports, entails, depends);
      for (auto p : range(Phase::HPP, Phase::END)) {
        auto pp = pred(p);
        outs[p] << include(relfilenames[pp]);
      }
      for (PIO pio : want::tuppelgang(phases, ins, outs)) {
        // import antecedents
        pio.out += imports[pio.phase];
        // process the phase
        bool established_line_anchor = false;
        for (auto &line : pio.in) {
          if (!established_line_anchor) {
            // establish the #line numbering for the phase at the first known line number
            if (has_lineno(line)) {
              established_line_anchor = true;
              std::ostringstream buf;
              buf << "#line " << lineno(line) << " " << qq(filename);
              pio.out << literal(buf.str());
              // MAYBE pio.out << finalize(?cpp?lb::line(line) << " " << qq(filename));
            }
          }
          debug(cfg) << "process director " << pio.phase << " at line " << lineno(line) << " q!" << value(line) << "!\n";
          director(line)(pio.phase, pio.out, imports, entails, depends);
        }
        // and, finally, incorporate the entailments
        pio.out += entails[pio.phase];
      }
    } catch (slurp::Failure const &e) {
      // scold::Reader could not read threw slurp::Failure
      error(cfg) << "could not open " << e.filename() << " because " << e.code().message() << '\n';
      throw scold::exception::Unprocessed("continuing");
    }
    bool written = true;
    if (ctx.error_count) {
      written = false;
    }  else {
      using scold::named;
      // If we're in dry-run mode then these streams are not open, so nothing gets written
      written &= (bool)(named(storage, filename) << outs);
      written &= (bool)(makefrag << depends.out);
      if (!written) {
        error(cfg) << "failed to write " << braket(module) << '\n';
      }
    }
    if (!cfg.quiet_mode) {
      if (!written || cfg.verbose_mode) {
        using scold::pluralize;
        auto e = pluralize(ctx.error_count, "error");
        auto w = pluralize(ctx.warning_count, "warning");
        auto were = 1 == ctx.error_count ? "was" : "were";
        char const *status_word = written ? "GOOD" : "FAIL";
        auto &out = !written ? notice(cfg) : verbose(cfg);
        out << status_word << " DC " << braket(module) << ", there " << were << " " << e << ", " << w;
        if (!written) {
          out << " (the disaggregation was not written)";
        }
        out << '\n';
      } 
    }
    if (!written) {
      // WATCHOUT - if the sys::exits::FAIL is not provided then the process does not exit nonozero
      // and hypogeal-twilight's $(bbSCOLD_DEPENDENCIES_COMPILE) will not fail.  Yet a failure occured.
      throw scold::exception::Quitting("failed to translate " + filename, sys::exits::FAIL);
    }
  } catch (want::regex::error const &e) {
    static_assert(std::is_same<want::regex::error, std::regex_error>::value, "now they are different");
    //
    // This is unexpected; this is a programmer error.  All regexes are run-time constants.
    // Their compilation failure means that the programmer failed somehow
    // to define a correct regex; but the failure, of course is observed only at runtime.
    //
    // Alternatively, the regex library has some unexpected and unwanted behavior
    //     e.g. std::regex vs boost::regex.
    //     e.g. gcc 4 vs gcc 6.
    // Recall that in gcc4, std::regex is "incomplete" and throws an exception on most non-triial regex constructs.
    //
    debug(cfg) << "regex failure code=" << std::hex << (int)(e.code()) << ' ' << std::dec << e.what() << '\n';
    std::ostringstream buf;
    buf << "regex compliation fails as " << e.what();
    throw scold::exception::Quitting(buf.str());
  } catch (scold::directories::Failure const &failed) {
    // Failed to mkdir the Directories
    error(cfg) << failed.what();
    throw scold::exception::Unprocessed("continuing");
  } catch (std::ios::failure const &e) {
    //
    // FIXME ... this does not work as of gcc-6.3
    // WHEREAS libstdc++ is not yet compiled C++11 so all exeptions show up here
    //
    // C++ 11 and (uh) prior wherein std::ios::failure inherits from std::exception (mot std::system_error)
    // redundant in the stanza above
    auto ec = e.code();
    error(cfg) << "could not disaggregate " << filename << " because " << ec.message() << '\n';
    throw scold::exception::Unprocessed("continuing");
  } catch (std::system_error const &e) {
    //
    // FIXME ... this does not work as of gcc-6.3
    // WHEREAS libstdc++ is not yet compiled C++11 so all exeptions show up here
    //
    // Handles a write failure; failed to open and/or write to the Files.
    // This is distinct from the failure to read the filename in slurp, which is dealt with separately (above).
    //
    // C++ 14 and beyond wherein std::ios::failure inherits from std::system_error
    //
    // FIXME TODO - get the name of the Files member that could not be opened (created)
    // The messaging here is misleading because it speaks to 'filename' not Files.
    // The failure was on opening a member of Files.
    //
    auto ec = e.code();
    error(cfg) << "could not disaggregate " << filename << " because " << ec.message() << '\n';
    throw scold::exception::Unprocessed("continuing");
  } catch (std::exception const &e) {
    // C++ 11 and (uh) prior wherein std::ios::failure inherits from std::exception (mot std::system_error)
    // this catch clause ought to be redundant in the stanza above
    //
    // FIXME ... ONLY THIS WORKS as of gcc-6.3 ... supposed to be ultimately fixed only in gcc 7-series
    // WHEREAS libstdc++ is not yet compiled C++11 so all exeptions show up here
    //
    // WATCHOUT - this is a catchall clause which is here because libstdc++ is buggy
    // WATCHOUT - whereas libstdc++ is not yet compiled C++11 so all exeptions show up here
    //
    // WATCHOUT - the provenance of errno is unknown at this point, it frequently seems to be zero
    std::error_code ec(errno, std::system_category());
    {
      std::ostream &err = error(cfg);
      err << "failed to disaggregate " << filename;
      if (0 != ec.value()) {
        err << " because " << ec.message();
      }
      err << '\n';
    }
    throw scold::exception::Unprocessed("continuing");
  }
}
#endiv
