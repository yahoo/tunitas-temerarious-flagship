// -*- c++ -*- in the SCOLD styling that is so fashionable these days
#divert <hpp>
#import path.filename.mount.Value
#import std.string
namespace want {
  namespace path {
    //
    // Remove the leading "./" from a pathname
    // With a variant like path::filename::finalize(...) which completes the Value
    //
    inline auto dedot(::path::filename::mount::Value &&) -> std::string;
    inline auto dedot(std::string &&) -> std::string;
    inline auto dedot(std::string const &) -> std::string;
  }
}

namespace path {
  namespace filename {
    namespace mount {
      // Add it here so that ADL can find it.
      using ::want::path::dedot;
    }
  }
}

#endiv
#divert <ipp>
auto want::path::dedot(std::string const &path) -> std::string {
  return dedot(std::string(path));
}

auto want::path::dedot(std::string &&anon) -> std::string {
  if (anon.empty()) {
    anon += '.';
  } else { 
    bool needs_erasure = 1 < anon.size() && '.' == anon[0] && '/' == anon[1];
    if (needs_erasure) {
      //
      // ".///      -> "."
      // ".///path  -> "path"
      //
      std::string::size_type notslash = 1;
      // handle the multislash case of .////file.suffix
      while (notslash < anon.size() && '/' == anon[notslash]) {
        notslash++;
      }
      //
      // notslash is either
      // (a) at the end of the string
      // (b) the first not-slash character
      //
      if (anon.size() == notslash) {
        //
        // .///  --->   .
        //
        anon.erase(1, notslash-1);
      } else {
        //
        // .////.////ab  --->  .////ab    (and retry)
        //
        anon.erase(0, notslash);
        // try again
        return dedot(std::forward<std::string>(anon));
      }
    }
  }
  return std::forward<std::string>(anon);
}

auto want::path::dedot(::path::filename::mount::Value &&anon) -> std::string {
  std::string ret(std::forward<std::string>(anon.subject));
  return dedot(std::move(ret));
}
#endiv
