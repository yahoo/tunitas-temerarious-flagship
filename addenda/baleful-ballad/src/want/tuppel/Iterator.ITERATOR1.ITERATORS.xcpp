// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import want.tuppel.Iterator
namespace want {
  namespace tuppel {
    template<typename ITERATOR1, typename... ITERATORS> class Iterator<ITERATOR1, ITERATORS...>;
  }
}
#endiv
#divert <hpp>
namespace want {
  namespace tuppel {
    template<typename ITERATOR1, typename... ITERATORS> inline auto operator==(Iterator<ITERATOR1, ITERATORS...> const &, Iterator<ITERATOR1, ITERATORS...> const &) -> bool;
    template<typename ITERATOR1, typename... ITERATORS> inline auto operator!=(Iterator<ITERATOR1, ITERATORS...> const &, Iterator<ITERATOR1, ITERATORS...> const &) -> bool;
  }
}

#import std.tuple
#import want.tuppel.traits.Iterator
template<typename ITERATOR1, typename... ITERATORS> class want::tuppel::Iterator<ITERATOR1, ITERATORS...> : public traits::Iterator<ITERATOR1, ITERATORS...>::iterator {
  using ancestor = typename traits::Iterator<ITERATOR1, ITERATORS...>::iterator;
public:
  using iterator1_type = ITERATOR1;
  using iteratorN_type = Iterator<ITERATORS...>;
  using iterators_type = std::tuple<ITERATOR1, ITERATORS...>;
  Iterator() = default;
  inline Iterator(iterator1_type const &, iteratorN_type const &);
  inline Iterator(iterator1_type &&, iteratorN_type &&);
  inline explicit Iterator(iterators_type const &);
  inline explicit Iterator(iterators_type &&);
  inline auto operator++() -> Iterator &;
  inline auto operator++(int) -> Iterator;
  inline auto operator*() -> typename ancestor::value_type;
protected:
  iterator1_type iterator1;
  iteratorN_type iteratorN;
  friend auto tuppel::operator== <>(Iterator const &, Iterator const &) -> bool;
  inline static constexpr auto is_trivial() -> bool;
  // template<typename... I> friend class tuppel::Iterator;
  template<typename... I> friend auto tuppel::operator==(Iterator<I...> const &, Iterator<I...> const &) -> bool;
  template<typename I1, typename... IS> friend auto tuppel::operator==(Iterator<I1, IS...> const &, Iterator<I1, IS...> const &) -> bool;
};

template<typename ITERATOR1, typename... ITERATORS> constexpr auto want::tuppel::Iterator<ITERATOR1, ITERATORS...>::is_trivial() -> bool {
  return false;
}
#endiv
#divert <ipp>
#import std.runtime_error
#include <cassert>
template<typename ITERATOR1, typename... ITERATORS> auto want::tuppel::operator==(Iterator<ITERATOR1, ITERATORS...> const &a, Iterator<ITERATOR1, ITERATORS...> const &b) -> bool {
  auto done1 = a.iterator1 == b.iterator1;
  auto doneN = a.iteratorN == b.iteratorN;
  using iteratorN_type = typename Iterator<ITERATOR1, ITERATORS...>::iteratorN_type;
  if (!iteratorN_type::is_trivial()) {
    assert(!(std::is_same<Iterator<>, iteratorN_type>::value));
    // In the self-check, avoid the conflict with the principle that "nullity is always equal all the time" for Iterator<>
    if (done1 != doneN) {
      throw std::runtime_error("ragged tuppel iterators");
    }
  }
  return done1 && doneN;
}

template<typename ITERATOR1, typename... ITERATORS> auto want::tuppel::operator!=(Iterator<ITERATOR1, ITERATORS...> const &a, Iterator<ITERATOR1, ITERATORS...> const &b) -> bool {
  return !operator==(a, b);
}

template<typename ITERATOR1, typename... ITERATORS> want::tuppel::Iterator<ITERATOR1, ITERATORS...>::Iterator(iterator1_type const &arg1, iteratorN_type const &argN)
  : iterator1(arg1)
  , iteratorN(argN) {
  ;
}

template<typename ITERATOR1, typename... ITERATORS> want::tuppel::Iterator<ITERATOR1, ITERATORS...>::Iterator(iterator1_type &&anon1, iteratorN_type &&anonN)
  : iterator1(std::forward<iterator1_type>(anon1))
  , iteratorN(std::forward<iteratorN_type>(anonN)) {
  ;
}

#import want.tuple_rest
template<typename ITERATOR1, typename... ITERATORS> want::tuppel::Iterator<ITERATOR1, ITERATORS...>::Iterator(iterators_type const &arg1)
  : iterator1(std::get<0>(arg1))
  , iteratorN(want::tuple_rest(arg1)) {
  ;
}

template<typename ITERATOR1, typename... ITERATORS> want::tuppel::Iterator<ITERATOR1, ITERATORS...>::Iterator(iterators_type &&anon)
  : iterator1(std::get<0>(std::forward<iterators_type>(anon)))
  , iteratorN(want::tuple_rest(std::forward<iterators_type>(anon))) {
  ;
}

template<typename ITERATOR1, typename... ITERATORS> auto want::tuppel::Iterator<ITERATOR1, ITERATORS...>::operator++() -> Iterator & {
  iterator1++;
  iteratorN++;
  return *this;
}

template<typename ITERATOR1, typename... ITERATORS> auto want::tuppel::Iterator<ITERATOR1, ITERATORS...>::operator++(int) -> Iterator {
  Iterator old(*this);
  operator++();
  return old;
}

#import want.tuple_cons
template<typename ITERATOR1, typename... ITERATORS> auto want::tuppel::Iterator<ITERATOR1, ITERATORS...>::operator*() -> typename ancestor::value_type {
  return want::tuple_cons(*iterator1, *iteratorN);
}
#endiv
