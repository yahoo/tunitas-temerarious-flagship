// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import want.tuppel.Iterator
namespace want {
  namespace tuppel {
    template<> class Iterator<>;
  }
}
#endiv
#divert <hpp>
namespace want {
  namespace tuppel {
    inline auto operator==(Iterator<> const &, Iterator<> const &) -> bool;
    inline auto operator!=(Iterator<> const &, Iterator<> const &) -> bool;
  }
}

#import std.tuple
#import want.tuppel.traits.Iterator
template<> class want::tuppel::Iterator<> : public traits::Iterator<>::iterator {
  using ancestor = typename traits::Iterator<>::iterator;
public:
  using iterators_type = std::tuple<>;
  inline Iterator() = default;
  inline auto operator++() -> Iterator &;
  inline auto operator++(int) -> Iterator;
  inline auto operator*() -> value_type;
protected:
  inline static constexpr auto is_trivial() -> bool;
  //template<typename... I> friend class tuppel::Iterator;
  template<typename... I> friend auto tuppel::operator==(Iterator<I...> const &, Iterator<I...> const &) -> bool;
  template<typename I1, typename... IS> friend auto tuppel::operator==(Iterator<I1, IS...> const &, Iterator<I1, IS...> const &) -> bool;
};

constexpr auto want::tuppel::Iterator<>::is_trivial() -> bool {
  return true;
}
#endiv
#divert <ipp>
auto want::tuppel::operator==(Iterator<> const &a, Iterator<> const &b) -> bool {
  // nothing equals nothing, always and ever thus.
  return true;
}

auto want::tuppel::operator!=(Iterator<> const &a, Iterator<> const &b) -> bool {
  return !operator==(a, b);
}

auto want::tuppel::Iterator<>::operator++() -> Iterator<> & {
  return *this;
}

auto want::tuppel::Iterator<>::operator++(int) -> Iterator<> {
  return *this;
}

auto want::tuppel::Iterator<>::operator*() -> value_type {
  return value_type();
}
#endiv
