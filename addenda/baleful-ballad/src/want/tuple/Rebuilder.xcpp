// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.size_t
namespace want {
  namespace tuple {
    // Wow ... this was hard.
    // See tuple_rest(...) for how to operate this thing.
    //
    // Concept
    //     SIZE = std::tuple_size<TYPES...>::value;
    //     Rebuilder<true, SIZE, 0u, TYPES...> rebuilder;
    //     return rebuilder(subject)
    //
    // Initial conditions
    //   SKIP      = true  skip the first element of the tulpe
    //   COUNTDOWN = SIZE  the size of the TYPES... package
    //   POSITION  = 0     start at position 0
    //   TYPES...  = the package of types
    //
    template<bool SKIP, std::size_t COUNTDOWN, std::size_t POSITION, typename... TYPES> struct Rebuilder;
    template<std::size_t COUNTDOWN, typename... TYPES> struct Rebuilder<true, COUNTDOWN, 0u, TYPES...>;
    template<std::size_t COUNTDOWN, std::size_t POSITION, typename... TYPES> struct Rebuilder<false, COUNTDOWN, POSITION, TYPES...>;
    template<std::size_t POSITION, typename... TYPES> struct Rebuilder<false, 0u, POSITION, TYPES...>;
  }
}
#endiv
#divert <hpp>
#import std.tuple
#import want.tuple.Rest
template<std::size_t COUNTDOWN, typename... TYPES> struct want::tuple::Rebuilder<true, COUNTDOWN, 0u, TYPES...> {
  inline auto operator()(std::tuple<TYPES...> &&) const -> typename Rest<1u, TYPES...>::type;
};

template<std::size_t COUNTDOWN, std::size_t POSITION, typename... TYPES> struct want::tuple::Rebuilder<false, COUNTDOWN, POSITION, TYPES...> {
  inline auto operator()(std::tuple<TYPES...> &&) const -> typename Rest<POSITION, TYPES...>::type;
};

template<std::size_t POSITION, typename... TYPES> struct want::tuple::Rebuilder<false, 0u, POSITION, TYPES...> {
  inline auto operator()(std::tuple<TYPES...> &&) const -> typename Rest<POSITION, TYPES...>::type;
};
#endiv
#divert <ipp>
template<std::size_t COUNTDOWN, typename... TYPES> auto want::tuple::Rebuilder<true, COUNTDOWN, 0u, TYPES...>::operator()(std::tuple<TYPES...> &&anon) const -> typename Rest<1u, TYPES...>::type {
  Rebuilder<false, COUNTDOWN-1, 1u, TYPES...> redo;
  return redo(std::forward<std::tuple<TYPES...>>(anon));
}

#import std.move
#import want.tuple_cons
template<std::size_t COUNTDOWN, std::size_t POSITION, typename... TYPES> auto want::tuple::Rebuilder<false, COUNTDOWN, POSITION, TYPES...>::operator()(std::tuple<TYPES...> &&anon) const -> typename Rest<POSITION, TYPES...>::type {
  Rebuilder<false, COUNTDOWN-1, POSITION+1, TYPES...> redo;
  auto car = std::get<POSITION>(std::forward<std::tuple<TYPES...>>(anon));
  auto cdr = redo(std::forward<std::tuple<TYPES...>>(anon));
  return tuple_cons(std::move(car), std::move(cdr));
}

template<std::size_t POSITION, typename... TYPES> auto want::tuple::Rebuilder<false, 0u, POSITION, TYPES...>::operator()(std::tuple<TYPES...> &&) const -> typename Rest<POSITION, TYPES...>::type {
  return std::tuple<>();
}
#endiv
