// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want {
  namespace doppel {
    template<typename ITERATOR1, typename ITERATOR2> class Iterator;
  }
}
#endiv
#divert <hpp>
namespace want {
  namespace doppel {
    template<typename ITERATOR1, typename ITERATOR2> inline auto operator==(Iterator<ITERATOR1, ITERATOR2> const &, Iterator<ITERATOR1, ITERATOR2> const &) -> bool;
    template<typename ITERATOR1, typename ITERATOR2> inline auto operator!=(Iterator<ITERATOR1, ITERATOR2> const &, Iterator<ITERATOR1, ITERATOR2> const &) -> bool;
  }
}

#import want.doppel.traits.Iterator
template<typename ITERATOR1, typename ITERATOR2> class want::doppel::Iterator : public traits::Iterator<ITERATOR1, ITERATOR2>::iterator {
  using ancestor = typename traits::Iterator<ITERATOR1, ITERATOR2>::iterator;
public:
  using iterator1_type = ITERATOR1;
  using iterator2_type = ITERATOR2;
  Iterator() = default;
  inline Iterator(iterator1_type, iterator2_type);
  inline auto operator++() -> Iterator &;
  inline auto operator++(int) -> Iterator;
  inline auto operator*() -> typename ancestor::value_type;
protected:
  iterator1_type iterator1;
  iterator2_type iterator2;
  friend auto operator== <>(Iterator const &, Iterator const &) -> bool;
};
#endiv
#divert <ipp>
#import std.runtime_error
template<typename ITERATOR1, typename ITERATOR2> auto want::doppel::operator==(Iterator<ITERATOR1, ITERATOR2> const &a, Iterator<ITERATOR1, ITERATOR2> const &b) -> bool {
  auto done1 = a.iterator1 == b.iterator1;
  auto done2 = a.iterator2 == b.iterator2;
  if (done1 != done2) {
    throw std::runtime_error("ragged doppel iterators");
  }
  return done1 && done2;
}

template<typename ITERATOR1, typename ITERATOR2> auto want::doppel::operator!=(Iterator<ITERATOR1, ITERATOR2> const &a, Iterator<ITERATOR1, ITERATOR2> const &b) -> bool {
  return !operator==(a, b);
}

template<typename ITERATOR1, typename ITERATOR2> want::doppel::Iterator<ITERATOR1, ITERATOR2>::Iterator(iterator1_type arg1, iterator2_type arg2)
  : iterator1(arg1)
  , iterator2(arg2) {
  ;
}

template<typename ITERATOR1, typename ITERATOR2> auto want::doppel::Iterator<ITERATOR1, ITERATOR2>::operator++() -> Iterator & {
  iterator1++;
  iterator2++;
  return *this;
}

template<typename ITERATOR1, typename ITERATOR2> auto want::doppel::Iterator<ITERATOR1, ITERATOR2>::operator++(int) -> Iterator {
  Iterator old(*this);
  operator++();
  return old;
}

template<typename ITERATOR1, typename ITERATOR2> auto want::doppel::Iterator<ITERATOR1, ITERATOR2>::operator*() -> typename ancestor::value_type {
  return typename ancestor::value_type(*iterator1, *iterator2);
}
#endiv
