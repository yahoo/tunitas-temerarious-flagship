// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.forward_iterator_tag
#import std.input_iterator_tag
#import std.bidirectional_iterator_tag
#import std.random_access_iterator_tag
#import std.output_iterator_tag
namespace want {
  namespace doppel {
    namespace traits {
      template<typename CATEGORY1, typename CATEGORY2> struct Combine;

      // See http://www.cplusplus.com/reference/iterator/

      // The input stack composes nicely as the concepts are naturally ordered.
      // But output_iterator_tag is incomparable with everything, so we make policy:
      // and upon combination, anything with an output_iterator_tag is ... output_iterator_tag (even input)

      template<> struct Combine<std::forward_iterator_tag, std::forward_iterator_tag>;
      template<> struct Combine<std::forward_iterator_tag, std::input_iterator_tag>;
      template<> struct Combine<std::forward_iterator_tag, std::bidirectional_iterator_tag>;
      template<> struct Combine<std::forward_iterator_tag, std::random_access_iterator_tag>;

      template<> struct Combine<std::input_iterator_tag, std::forward_iterator_tag>;
      template<> struct Combine<std::input_iterator_tag, std::input_iterator_tag>;
      template<> struct Combine<std::input_iterator_tag, std::bidirectional_iterator_tag>;
      template<> struct Combine<std::input_iterator_tag, std::random_access_iterator_tag>;

      template<> struct Combine<std::bidirectional_iterator_tag, std::forward_iterator_tag>;
      template<> struct Combine<std::bidirectional_iterator_tag, std::input_iterator_tag>;
      template<> struct Combine<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>;
      template<> struct Combine<std::bidirectional_iterator_tag, std::random_access_iterator_tag>;

      template<> struct Combine<std::random_access_iterator_tag, std::forward_iterator_tag>;
      template<> struct Combine<std::random_access_iterator_tag, std::input_iterator_tag>;
      template<> struct Combine<std::random_access_iterator_tag, std::bidirectional_iterator_tag>;
      template<> struct Combine<std::random_access_iterator_tag, std::random_access_iterator_tag>;

      template<> struct Combine<std::output_iterator_tag, std::output_iterator_tag>;
      template<> struct Combine<std::output_iterator_tag, std::forward_iterator_tag>;
      template<> struct Combine<std::output_iterator_tag, std::input_iterator_tag>;
      template<> struct Combine<std::output_iterator_tag, std::bidirectional_iterator_tag>;
      template<> struct Combine<std::output_iterator_tag, std::random_access_iterator_tag>;
      template<> struct Combine<std::forward_iterator_tag,       std::output_iterator_tag>;
      template<> struct Combine<std::input_iterator_tag,         std::output_iterator_tag>;
      template<> struct Combine<std::bidirectional_iterator_tag, std::output_iterator_tag>;
      template<> struct Combine<std::random_access_iterator_tag, std::output_iterator_tag>;
    }
  }
}
#endiv
#divert <hpp>
template<typename CATEGORY1, typename CATEGORY2> struct want::doppel::traits::Combine {
  static_assert(0 == sizeof (CATEGORY1) && 0 != sizeof (CATEGORY1), "CATEGORY1 and CATEGORY2 are incompatible");
};

// The lowest capability dominates to produce the combined result
template<> struct want::doppel::traits::Combine<std::forward_iterator_tag, std::forward_iterator_tag>       { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::forward_iterator_tag, std::input_iterator_tag>         { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::forward_iterator_tag, std::bidirectional_iterator_tag> { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::forward_iterator_tag, std::random_access_iterator_tag> { using type = std::forward_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::input_iterator_tag, std::forward_iterator_tag>         { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::input_iterator_tag, std::input_iterator_tag>           { using type = std::input_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::input_iterator_tag, std::bidirectional_iterator_tag>   { using type = std::input_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::input_iterator_tag, std::random_access_iterator_tag>   { using type = std::input_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::bidirectional_iterator_tag, std::forward_iterator_tag>       { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::bidirectional_iterator_tag, std::input_iterator_tag>         { using type = std::input_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag> { using type = std::bidirectional_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::bidirectional_iterator_tag, std::random_access_iterator_tag> { using type = std::bidirectional_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::random_access_iterator_tag, std::forward_iterator_tag>       { using type = std::forward_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::random_access_iterator_tag, std::input_iterator_tag>         { using type = std::input_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::random_access_iterator_tag, std::bidirectional_iterator_tag> { using type = std::bidirectional_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::random_access_iterator_tag, std::random_access_iterator_tag> { using type = std::random_access_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::output_iterator_tag, std::output_iterator_tag> { using type = std::output_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::output_iterator_tag, std::forward_iterator_tag>       { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::output_iterator_tag, std::input_iterator_tag>         { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::output_iterator_tag, std::bidirectional_iterator_tag> { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::output_iterator_tag, std::random_access_iterator_tag> { using type = std::output_iterator_tag; };

template<> struct want::doppel::traits::Combine<std::forward_iterator_tag,       std::output_iterator_tag> { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::input_iterator_tag,         std::output_iterator_tag> { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::bidirectional_iterator_tag, std::output_iterator_tag> { using type = std::output_iterator_tag; };
template<> struct want::doppel::traits::Combine<std::random_access_iterator_tag, std::output_iterator_tag> { using type = std::output_iterator_tag; };
#endiv
