// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.size_t
#import std.istream
#import std.ifstream
#import std.ostream
#import std.ofstream
namespace want {
  namespace doppel {
    namespace traits {
      //
      // The traits of a CONTAINER used within Ganger<CONTAINER1, CONTAINER2>
      //
      template<typename CONTAINER> struct Container;
      template<typename CONTAINER> struct Container<CONTAINER const>;

      template<typename TYPE> struct Container<TYPE *>;
      template<typename TYPE> struct Container<TYPE const *>;
      template<std::size_t N, typename TYPE> struct Container<TYPE [N]>;
      template<std::size_t N, typename TYPE> struct Container<TYPE const [N]>;

      template<std::size_t N> struct Container<std::istream [N]>;
      template<std::size_t N> struct Container<std::istream const [N]>;
      template<std::size_t N> struct Container<std::ifstream [N]>;
      template<std::size_t N> struct Container<std::ifstream const [N]>;

      template<std::size_t N> struct Container<std::ostream [N]>;
      template<std::size_t N> struct Container<std::ostream const [N]>;
      template<std::size_t N> struct Container<std::ofstream [N]>;
      template<std::size_t N> struct Container<std::ofstream const [N]>;
    }
  }
}
#endiv
#divert <hpp>
#import std.iterator_traits
#import std.iterator
template<typename CONTAINER> struct want::doppel::traits::Container : public std::iterator_traits<typename CONTAINER::iterator> {
  // we need the iterator type itself!
  using iterator = typename CONTAINER::iterator;
};

template<typename CONTAINER> struct want::doppel::traits::Container<CONTAINER const> : public std::iterator_traits<typename CONTAINER::const_iterator> {
  // we need the iterator type itself!
  using iterator = typename CONTAINER::const_iterator;
};

template<typename TYPE> struct want::doppel::traits::Container<TYPE *> : public std::iterator_traits<TYPE *> {
  using iterator = TYPE *;
};

template<typename TYPE> struct want::doppel::traits::Container<TYPE const *> : public std::iterator_traits<TYPE const *> {
  using iterator = TYPE const *;
};

template<std::size_t N, typename TYPE> struct want::doppel::traits::Container<TYPE [N]> : public Container<TYPE *> { };
template<std::size_t N, typename TYPE> struct want::doppel::traits::Container<TYPE const [N]> : public Container<TYPE const *> { };

template<std::size_t N> struct want::doppel::traits::Container<std::istream [N]> : public std::iterator<std::output_iterator_tag, std::istream &, void, void, void> {
  using iterator = std::istream *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::istream const [N]> : public std::iterator<std::output_iterator_tag, std::istream const &, void, void, void> {
  using iterator = std::istream const *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::ifstream [N]> : public std::iterator<std::output_iterator_tag, std::ifstream &, void, void, void> {
  using iterator = std::ifstream *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::ifstream const [N]> : public std::iterator<std::output_iterator_tag, std::ifstream const &, void, void, void> {
  using iterator = std::ifstream const *;
};

template<std::size_t N> struct want::doppel::traits::Container<std::ostream [N]> : public std::iterator<std::output_iterator_tag, std::ostream &, void, void, void> {
  using iterator = std::ostream *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::ostream const [N]> : public std::iterator<std::output_iterator_tag, std::ostream const &, void, void, void> {
  using iterator = std::ostream const *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::ofstream [N]> : public std::iterator<std::output_iterator_tag, std::ofstream &, void, void, void> {
  using iterator = std::ofstream *;
};
template<std::size_t N> struct want::doppel::traits::Container<std::ofstream const [N]> : public std::iterator<std::output_iterator_tag, std::ofstream const &, void, void, void> {
  using iterator = std::ofstream const *;
};
#endiv
