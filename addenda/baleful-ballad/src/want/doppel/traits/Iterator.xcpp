// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want {
  namespace doppel {
    namespace traits {
      //
      // The traits of the doppel::Iterator
      //
      template<typename ITERATOR1, typename ITERATOR2> struct Iterator;
    }
  }
}

#import std.iterator_traits
namespace std {
  template<typename ITERATOR1, typename ITERATOR2> struct iterator_traits<want::doppel::traits::Iterator<ITERATOR1, ITERATOR2>>;
}
#endiv
#divert <hpp>
#import std.conditional
#import std.forward_iterator_tag
#import std.is_copy_constructible
#import std.iterator
#import std.iterator_traits
#import std.pair
#import want.doppel.traits.Combine
template<typename ITERATOR1, typename ITERATOR2> struct want::doppel::traits::Iterator {
  using traits1_type = std::iterator_traits<ITERATOR1>;
  using traits2_type = std::iterator_traits<ITERATOR2>;
private:
  template<typename TRAITS> struct value_or_reference {
    using type = typename std::conditional<std::is_copy_constructible<typename TRAITS::value_type>::value, typename TRAITS::value_type, typename TRAITS::value_type &>::type;
  };
  using value1_type = typename value_or_reference<traits1_type>::type;
  using value2_type = typename value_or_reference<traits2_type>::type;
public:
  // the basics of std::iterator
  // because we're returning pairs, we can't meaningfully have a difference, pointer or reference type.
  using iterator_category = typename traits::Combine<typename traits1_type::iterator_category, typename traits2_type::iterator_category>::type;
  using value_type = std::pair<value1_type, value2_type>;
  using difference = void;
  using pointer = void;           // we're not using pointer_pair
  using reference = void;         // we're not using reference_pair
  // capture the result of the decisions recorded herein
  using iterator = std::iterator<iterator_category, value_type, difference, pointer, reference>;
  using traits_type = iterator; // ahem, in case you forget
};

template<typename ITERATOR1, typename ITERATOR2> struct std::iterator_traits<want::doppel::traits::Iterator<ITERATOR1, ITERATOR2>>
  : public want::doppel::traits::Iterator<ITERATOR1, ITERATOR2>::iterator { };
#endiv
