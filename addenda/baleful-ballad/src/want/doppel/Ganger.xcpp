// -*- c++ -*- C++23 with S.C.O.L.D. stylings; For terms, see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want {
  namespace doppel {
    template<typename CONTAINER1, typename CONTAINER2> class Ganger;
  }
}
#endiv
#divert <hpp>
#import std.remove_reference
#import want.doppel.traits.Container
#import want.doppel.Iterator
#import std.add_const
#import std.enable_if
#import std.is_same
template<typename CONTAINER1, typename CONTAINER2> class want::doppel::Ganger {
public:
  using container1_type = CONTAINER1;
  using container2_type = CONTAINER2;
  inline Ganger(container1_type &, container2_type &);
  using iterator = Iterator<typename traits::Container<typename std::remove_reference<CONTAINER1>::type>::iterator,
                            typename traits::Container<typename std::remove_reference<CONTAINER2>::type>::iterator>;
  inline auto begin() -> iterator;
  inline auto end() -> iterator;
  using const_iterator = Iterator<typename traits::Container<typename std::add_const<typename std::remove_reference<CONTAINER1>::type>::type>::iterator,
                                  typename traits::Container<typename std::add_const<typename std::remove_reference<CONTAINER2>::type>::type>::iterator>;
  inline auto begin() const -> const_iterator;
  inline auto end() const -> const_iterator;
protected:
  container1_type &container1;
  container2_type &container2;
};
#endiv
#divert <ipp>
template<typename CONTAINER1, typename CONTAINER2> want::doppel::Ganger<CONTAINER1, CONTAINER2>::Ganger(container1_type &arg1, container2_type &arg2)
  : container1(arg1)
  , container2(arg2) {
  ;
}

#include <cassert>
#import std.distance
#import std.begin
template<typename CONTAINER1, typename CONTAINER2> auto want::doppel::Ganger<CONTAINER1, CONTAINER2>::begin() -> iterator {
  // DO NOT assert(std::distance(std::begin(container1), std::end(container1)) == std::distance(std::begin(container2), std::end(container2)));
  // because if the iterators are input iterators then you've exhausted the input
  return iterator(std::begin(container1), std::begin(container2));
}

#include <cassert>
#import std.distance
#import std.begin
template<typename CONTAINER1, typename CONTAINER2> auto want::doppel::Ganger<CONTAINER1, CONTAINER2>::begin() const -> const_iterator {
  // DO NOT assert(std::distance(std::begin(container1), std::end(container1)) == std::distance(std::begin(container2), std::end(container2)));
  return const_iterator(std::begin(container1), std::begin(container2));
}

#import std.end
template<typename CONTAINER1, typename CONTAINER2> auto want::doppel::Ganger<CONTAINER1, CONTAINER2>::end() -> iterator {
  return iterator(std::end(container1), std::end(container2));
}

#import std.end
template<typename CONTAINER1, typename CONTAINER2> auto want::doppel::Ganger<CONTAINER1, CONTAINER2>::end() const -> const_iterator {
  return const_iterator(std::end(container1), std::end(container2));
}
#endiv
