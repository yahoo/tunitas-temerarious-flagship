#!/usr/bin/perl

#
# recover the Name, Version, Release from a specfile
#
# Specimen #1:
#
#     Name:           example-package
#     Version:        0.16.1
#     Release:        1%{?dist}
#
# Specimen #2:
#
#     %define this_version 0.16.1
#     %global this_release 1 <---------------------- %define or %global
#     ...
#     %bcond_with thrm
#     %if %{with thrm}
#     %define trial t99. <------------ matching code in .../am/archive.mk and in the PACKAGE.spec file
#     %endif
#     ...
#     Name:           example-package
#     Version:        %{this_version}
#     Release:        %{?trial}%{this_release}%{?dist} <----- trial is unset
#
# Usage:
#     extract-rpm-specfile-value --usage
#     extract-rpm-specfile Name $filename.spec
#     extract-rpm-specfile Version $filename.spec
#     extract-rpm-specfile Release $filename.spec
#

use strict;
use warnings;
use constant DEBUG => 0;

our $NAME = $0;
$NAME =~ s,.*/,,;

sub this_ify($) {
    my $word = shift;
    $word =~ tr/]A-Z]/[a-z]/;
    return qq(this_) . $word;
}

sub grepping($$$) {
    my ($tag_keyword, $this_keyword, $filename) = @_;
    print STDERR qq(debug: grepping for $tag_keyword or $this_keyword from $filename\n) if DEBUG;
    open(my $fd, '<', $filename) || die qq($NAME: error, could not open $filename because $!\n);
    my @defines;
    while (<$fd>) {
        if (DEBUG > 1) {
            # does not debug all possible patterns (below)
            print STDERR q(debug: ) . qq($_);
            print STDERR q(debug: ) . qr!^%(?:define|global)[[:space:]]*$this_keyword[[:space:]]*([^[:space:]].*)! . qq(\n);
            print STDERR q(debug: ) . ($_ =~ qr/^%(?:define|global)[[:space:]]*$this_keyword[[:space:]]*([^[:space:]].*)/) . qq(\n);
        }
        # look for "this_" or "that_" prefixed definitions of epoch, version, release, base_package, devel_package
        if (/^%(define|global)[[:space:]]*((?:this|that)_(?:epoch|version|release|\S*_package))[[:space:]]*([^[:space:]].*)/) {
            print STDERR qq(debug: found $1 $2 $3\n) if DEBUG;
            push @defines, $_;
        }
        if (/^$tag_keyword:[[:space:]]*([^[:space:]].*)/) {
            my $val = $1;
            # guard against sloppiness in the specfile
            # e.g.
            #    Release: %{?trial}${this_release}%{?dist} -------- see the '$' sign?  should be a '%'
            $val =~ tr/$/%/;
            print STDERR qq(debug: found $val in tag $tag_keyword\n) if DEBUG;
            return ($val, @defines);
        }
    }
    die qq($NAME: error, could not find $tag_keyword or $this_keyword in $filename\n);
}

our $USAGE_MESSAGE = <<__USAGE_MESSAGE__;
usage: $NAME <keyword> <filename>.spec
Keyword ::= { Name | Version | Release } 
__USAGE_MESSAGE__

print STDERR qq(debug: ARGV=[@ARGV]\n) if DEBUG;
if (1 == @ARGV && 0 != scalar(grep { $_ eq ${ARGV[0]}; } qw(-h -q --help --usage))) {
    print $USAGE_MESSAGE;
    exit 0;
}

die <<__USAGE__ unless 2 == @ARGV;
$NAME: error, found: << $NAME @ARGV >>
$USAGE_MESSAGE
__USAGE__

my ($val, @defines) = grepping($ARGV[0], this_ify($ARGV[0]), $ARGV[1]);
# shutup the safety check in .../rpm/macros.thrm
#    error: need to %declare_thrm before using %{trial}
push @defines, qq(%define trial %{nil}); 
print STDERR qq{debug: defines=(@defines)\n} if DEBUG;

my (@rpm_defines) = map {
    chomp $_;
    $_ =~ s/%(?:define|global)\s+(\S*)\s+(\S+)/--define '%$1 $2'/;
    $_;
} (@defines);
print STDERR qq{debug: rpm_defines=(@rpm_defines)\n} if DEBUG;

my $reval = `rpm @rpm_defines --eval "$val"`;
chomp $reval;
print STDERR qq(debug: evaluates as $reval\n) if DEBUG;
print $reval, qq(\n);
