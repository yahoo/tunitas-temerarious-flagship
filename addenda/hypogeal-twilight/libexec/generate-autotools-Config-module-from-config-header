#!/usr/bin/perl
# see LICENSE file nearby.

use warnings;
use strict;

our ($NAME) = ($0 =~ m|(?:.*/)?(.*)|);
our $VERSION = <<__VERSION__;
$NAME: version v0.45.1-0.devel of hypogeal-twilight
__VERSION__
our $USAGE = <<__USAGE__;
usage: $NAME { options } .../config.h .../autotools.xcpp

Options

    --tag=<TYPE>
             generate the specialization autotools::autoconf::autotools<TYPE>
             there is no default value
             e.g. --tag=package::subpackage::ENUM
    --import=<module-name>
             add an #import declaration for the module to the generated result
             this is optional and may be repeated
             likely at least one is necessary to import the definition of TYPE
             e.g. --import=package.subpackage
    --include=<filename>
             add a direct #include of <filename> to the generated result
             this is optional and may be repeated
             e.g. --include=package.subpackage

Files

    .../config.h is the input,
                 it is the config.h from post-configure autotools.
    .../autotools.xcpp is the output,
                 it is the SCOLD-style constexpr capture of config.h,
                 it can be named anything,
                 it will contain the generated specialization autotools::autoconf::Config<TYPE>

The suggested the location of autotools.xcpp for is the "top level"
    obj/src/package/subpackage/autotools.xcpp
  Then
    xscold --objdir=obj/src --srcdir=obj/src obj/src/package/subpackage/autotools.xcpp

Example:
    mkdir -p obj/src/package/subpackage
    $NAME --TAG=package::subpackage::CONFIG config.h obj/src/package/subpackage/autotools.xcpp
    xscold --objdir=obj/src --srcdir=obj/src obj/src/package/subpackage/autotools.xcpp
__USAGE__

use constant DEBUG => 0;
use POSIX qw(&chmod &localtime &rename &strftime &unlink);
use File::Basename qw(&basename &dirname);

sub readonly($) { 
    my $fh = shift;
    my @bundle = (stat $fh);
    return undef unless @bundle;
    my $perm = $bundle[2] & 07777;
    return chmod($perm & ~0333, $fh);
}

sub is_floating_literal($) {
    my $value = shift;
    # A floating point number cannot have two decimal points (a vstring has such)
    return ($value =~ m/\d+\./ || $value =~ m/\d+[\d.]*[Ee]\d+/) && ! ($value =~ m/\..*\./);
}

sub estimate_type_of_literal($$;$) {
    my ($SYMBOL, $value, $bool_hint) = @_;
    return q(char const *) if $value =~ m/^"/;
    return q(wchar_t const *) if $value =~ m/^L"/;
    return q(char) if $value =~ m/^'/;
    return q(wchar_t) if $value =~ m/^L'/;
    return q(long double) if $value =~ m/l$/i && is_floating_literal $value;
    return q(double)      if is_floating_literal $value;
    # does anyone use mere float literals?
    return q(int long long unsigned) if $value =~ m/ull$/i || $value =~ m/llu$/i;
    return q(int long unsigned)      if $value =~ m/ul$/i || $value =~ m/lu$/i;
    # (semver-style) version numbers are unsigned, by definition
    return q(int unsigned)           if $value =~ m/u$/i || $SYMBOL =~ m/^PACKAGE_/;
    #
    # probably an int
    #                                                           /* Define if your MySQL library has SSL functions */
    #                                                           #define HAVE_MYSQL_SSL_SET /**/
    return q(bool) if ($SYMBOL =~ m/^HAVE_/i || $bool_hint) && (q(0) eq $value || q(1) eq $value || $value =~ m{/\*.*\*/});
    return q(int signed);
}

our $TAGTYPE; # must be set in the options processing
our @IMPORT_MODULES;
our @INCLUDE_FILES;
our $srcdir = q(.); # deprecated, unused
our $objdir = q(.); # deprecated, unused
while (@ARGV) {
    last unless $ARGV[0] =~ m/^-/;
    my $option = shift @ARGV;
    if ($option =~ m/^--(?:usage|help|h)$/) {
        print $USAGE;
        exit 0;
    } elsif ($option =~ m/^--(?:version|V)$/) {
        print $VERSION;
        exit 0;
    } elsif ($option =~ m/^--srcdir=(.*)/) {
        $srcdir = $1;
    } elsif ($option =~ m/^--objdir=(.*)/) {
        $objdir = $1;
    } elsif ($option =~ m/^--tag=(.*)/) {
        $TAGTYPE = $1;
    } elsif ($option =~ m/^--import=(.*)/) {
        push @IMPORT_MODULES, $1;
    } elsif ($option =~ m/^--include=(.*)/) {
        push @INCLUDE_FILES, $1;
    } else {
        print STDERR qq($NAME: error, unknown option $option\n);
        print STDERR $USAGE;
        exit 1;
    }
}
die $USAGE unless 2 == @ARGV;
die qq($NAME: error, specifying--tag=TYPE is required\n) unless defined $TAGTYPE;
our $INPUT = shift @ARGV;
our $FINAL = shift @ARGV;
# WATCHOUT - there may be multiple concurrent invocations of $0 which operate on different pairs (INPUT,FINAL)
our $TEMPY = dirname($INPUT) . qq(/t99.$$) . basename($INPUT) . q(.) . basename($FINAL) . qq(~);

our $timestamp = strftime("%Y-%M-%d %H:%M:%S", localtime(time));
our ($buildconf) = ($0 =~ m|^(?:.*/)?(.*)|);

open(my $input, '<', $INPUT) or die qq($NAME: error, could not read $INPUT because $!\n);
unlink($TEMPY); # ignore the problem (open will see it)
open(my $tempy, '>', $TEMPY) or die qq($NAME: error, could not write $TEMPY because $!\n);
readonly($tempy) or die qq($NAME: error, failed to make $TEMPY readonly because $!\n);

our @PACKAGES = qw(autotools autoconf);
our $Class = q(Config);

my $IMPORT_STATEMENTS = q();
my $INCLUDE_STATEMENTS = q();
my $CLASS_DECLARATION = q();
my $CLASS_DEFINITION = q();
my $MEMBER_DEFINITIONS = q();
{
    for my $import (@IMPORT_MODULES) {
        $IMPORT_STATEMENTS .= qq(#import $import\n);
    }
} {
    for my $include (@INCLUDE_FILES) {
        $INCLUDE_STATEMENTS .= qq(#include "$include"\n);
    }
} {
    my $indent_count = 0;
    for my $package (@PACKAGES) {
        $CLASS_DECLARATION .= q( ) x $indent_count . qq(namespace $package {\n);
        $indent_count += 2;
    }
    $CLASS_DECLARATION .= q( ) x $indent_count . qq(template<typename TAG> struct $Class;\n);
    $CLASS_DECLARATION .= q( ) x $indent_count . qq(template<> struct $Class<$TAGTYPE>;\n);
    for my $package (@PACKAGES) {
        $indent_count -= 2;
        $CLASS_DECLARATION .= q( ) x $indent_count . qq(}\n);
    }
}

$CLASS_DEFINITION .= qq(template<> struct ) . join(q(::), @PACKAGES) . q(::) . $Class . qq(<$TAGTYPE> {\n);
print STDERR qq(debug: reading $INPUT\n) if DEBUG;
my $bool_comment_hint = 0;
while (<$input>) {
    print STDERR qq(debug: $_) if DEBUG;
    if ($_ =~ m/^\s*$/) {
        # ignore empty lines
    } elsif ($_ =~ m|^\s*//|) {
        $bool_comment_hint = $_ =~ m/Define to 1 if you have/;
        $CLASS_DEFINITION .= $_;
    } elsif (my ($comment) = ($_ =~ m|^\s*/\*\s*(.*)|)) {
        my $at_end;
        do {
            print STDERR qq(debug: (comment) $_) if DEBUG;
            $bool_comment_hint = $_ =~ m/Define to 1 if you have/;
            $at_end = $_ =~ m|\*/|;
            $comment =~ s|\s*\*/\s*$||;
            $CLASS_DEFINITION .= q(// ) . $comment . qq(\n);
        } while (!$at_end && ($_ = <$input>));
    } elsif (my ($SYMBOL, $VALUE) = ($_ =~ m/^\s*#\s*define\b\s+(\S+)\s+(.*)/)) {
        my $type = estimate_type_of_literal($SYMBOL, $VALUE, $bool_comment_hint);
        $VALUE = q(true) if $VALUE =~ m{/\*.*\*/};
        $bool_comment_hint = 0; # is now used up
        my $symbol = $SYMBOL;
        $symbol =~ tr/A-Z/a-z/;
        $CLASS_DEFINITION .= qq(inline static constexpr auto $symbol() -> $type { return $VALUE; }\n);
    } else {
        warn qq($INPUT, ignoring unexpected line $_\n);
    }
}
print STDERR qq(debug: done reading $INPUT\n) if DEBUG;
$CLASS_DEFINITION .= qq(};\n);

# All member functions are 'inline static constexpr'
# All member function definitions are provided in the class definition itself.
# There is no distinct <ipp> with separate member function definitions.

print $tempy <<__STANZA__;
// -*- c++ -*- in the SCOLD stylings that are so popular these days
// Established by $buildconf at $timestamp
#divert <fpp>
$IMPORT_STATEMENTS
$INCLUDE_STATEMENTS
$CLASS_DECLARATION
#endiv
#divert <hpp>
$CLASS_DEFINITION
#endiv
__STANZA__

close($input) or die qq($NAME: error, failed to close $INPUT because $!\n);
close($tempy) or die qq($NAME: error, failed to close $TEMPY because $!\n);
rename($TEMPY, $FINAL) or die qq($NAME: error, failed to rename $TEMPY $FINAL because $!\n);
exit(0);
