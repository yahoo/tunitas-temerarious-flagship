#!/bin/sh
# test-suite-summarizer - basic test suite summarizer
declare NAME=${0##*/}

# Copyright (C) 2017-2017 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# Extracted from and adapted from some living Makefile.am, c.f. automake-1.13.4-1
scriptversion=2017-10-01.01; # UTC

#
# Usage:
#  similar to the automake productions for testing.
#
#     $(TEST_SUITE_LOG): $(TEST_LOGS)
#     \t./test-suite-compiler $@ $^
#
#     $(TEST_SUITE_LOG): $(TEST_LOGS)
#     \t./test-suite-compiler --PACKAGE_STRING='$(PACKAGE_STRING)' $@ $^
#
# Previously it was open-coded in the Makefile (!!!),
# To wit:
#
#     $(TEST_SUITE_LOG): $(TEST_LOGS)
#     \t...this-script-herein-is-open-coded-inlined...
#

# Make unconditional expansion of undefined variables an error.
# This helps a lot in preventing typo-related bugs.
set -u
# [remove] Leftover from when this was positioned within a Makefile (where set -e) reigns.
set +e

declare -i debug_mode=0
declare -i dry_run_mode=0
declare -i rerun_mode=0
declare -i verbose_mode=0

function debug() {
    if ((debug_mode)); then
        echo "debug:" "$@"
    fi
} >&2

function version_subcommand() {
    # WATCHOUT - this is manually recorded here from ChangeLog
    echo "${NAME}: version 0.2.0 of incendiary-sophist"
    exit 0
}

function usage_subcommand() {
    local -i e=$1; shift
    (
        if ((0 != e)); then
            cat
        else
            cat 1>&2
        fi
    ) <<EOF
${##*/}: error, not enough arguments
usage: ${##*/} [ ...options... ] test-suite.log [ directory/testcase.log ... ]

Switches
--verbose                prattle verbosely
--dry-run                do nothing
--rerun-tests            rerun tests if necessary, recursively calls \$(MAKE) 
--debug                  you snould not need this

Makefile Variables
--PACKAGE_STRING=\$(PACKAGE_STRING)
--PACKAGE_BUGREPORT=\$(PACKAGE_BUGREPORT)
--subdir=\$(subdir)
EOF
    exit $e
}

# Reminder: the autoconf world also defines other strings, not made available herein
#
#   PACKAGE_
#   PACKAGE_NAME
#   PACKAGE_TARNAME
#   PACKAGE_VERSION
#   PACKAGE_STRING
#   PACKAGE_BUGREPORT
#   PACKAGE_URL
#
# these variables are expected to be supplied from options
declare PACKAGE_STRING=PACKAGE_STRING
declare PACKAGE_BUGREPORT=PACKAGE_BUGREPORT
declare subdir=.

while ((0 < $#)); do
    case $1 in
    ( --package=* | --PACKAGE=* | --package[-_]string=* | --PACKAGE[-_]STRING=* )
        PACKAGE_STRING=$(expr "x$1" : '^x--[^=]*=\(.*\)')
        shift
        ;;
    ( --package[-_]bugreport=* | --PACKAGE[-_]BUGREPORT=* )
        PACKAGE_BUGREPORT=$(expr "x$1" : '^x--[^=]*=\(.*\)')
        shift
        ;;
    ( --subdir=* )
        subdir=$(expr "x$1" : '^x--[^=]*=\(.*\)')
        shift
        ;;
    ( --debug )
        debug_mode=1
        shift
        ;;
    ( --dry-run )
        dry_run_mode=1
        shift
        ;;
    ( --rerun | --rerun-tests )
        rerun_mode=1
        shift
        ;;
    ( --redo | --redo-tests )
        echo "${NAME}: warning, treating $1 as --rerun-tests (use 'rerun', not 'redo')" 1>&2
        rerun_mode=1
        shift
        ;;
    ( --verbose )
        verbose_mode=1
        shift
        ;;
    ( --version | -V )
        version_subcommand
        ;;
    ( --usage | --help | -h )
        usage_subcommand 0
        ;;
    ( -- )
        shift
        break
        ;;
    ( -* )
        usage_subcommand 1
        ;;
    ( * )
        break
        ;;
    esac
done

if ((verbose_mode)) ; then
    space='  '
    cat <<EOF
Command line switches:
${space}debug=${debug_mode:-unset}
${space}dry-run=${dry_run_mode:-unset}
${space}rerun-tests=${rerun_tests_mode:-unset}
${space}verbose=${verbose_mode:-unset}
Variables (some from the environment):
${space}AM_COLOR_TESTS='${AM_COLOR_TESTS:-unset}'
${space}AM_MAKEFLAGS='${AM_MAKEFLAGS:-unset}'
${space}MFLAGS='${MFLAGS:-unset}'
${space}MAKEFLAGS='${MAKEFLAGS:-unset}'
${space}PACKAGE_STRING='${PACKAGE_STRING:-unset}'
${space}PACKAGE_BUGREPORT='${PACKAGE_BUGREPORT:-unset}'
${space}subdir='${subdir:-unset}'
${space}TERM='${TERM:-unset}'
EOF
fi

#
# Expecting at least two arguments, but one is mandatory
#
#     test-suite.log [ ...test.log... ]
if (($# < 1)); then
    usage_subcommand 1
fi 1>&2

declare TEST_SUITE_LOG=$1; shift
declare -a TEST_LOGS=( "$@" )

: ${AWK:=awk}
if ! type ${AWK:-awk} >/dev/null; then
    echo "${NAME}: error, ${AWK:-awk} is required; it is missing."
    exit 2
fi 1>&2

declare -a bases=( "${TEST_LOGS[@]%.log}" )
debug "bases=( ${bases[@]} )"

function am__is_gnu_make() {
    # It's always GNU make nowadays.
    true;
}

function am__make_running_with_option() {
    local target_option=$1; shift
    case ${target_option-} in
    (?) ;;
    (*) {
            echo "am__make_running_with_option: internal error: invalid target option '${target_option-}' specified"
            exit 1
        };;
    esac;
    local has_opt=no;
    local sane_makeflags=${MAKEFLAGS:-}
    if am__is_gnu_make; then
      sane_makeflags=${MFLAGS:-}
    else
      case ${MAKEFLAGS:-} in
        (*[\ \	]*)
          bs=\\;
          sane_makeflags=`printf '%s\n' "$MAKEFLAGS" | sed "s/$bs$bs[$bs $bs	]*//g"`;;
      esac;
    fi;
    skip_next=no;
    for flg in $sane_makeflags; do
      test $skip_next = yes && { skip_next=no; continue; };
      case $flg in
      (*=*|--*) continue;;
      (-*I)     skip_next=yes;;
      (-*I?*)   flg=${flg/I*};;
      (-*O)     skip_next=yes;;
      (-*O?*)   flg=${flg/O*};;
      (-*l)     skip_next=yes;;
      (-*l?*)   flg=${flg/l*};;
      (-[dEDm]) skip_next=yes;;
      (-[JT])   skip_next=yes;;
      esac;
      case $flg in
        *$target_option*) has_opt=yes; break;;
      esac;
    done;
    test $has_opt = yes
}

function am__make_dryrun() {
    am__make_running_with_option n
}

function am__f_ok () {
    test -f "$1" && test -r "$1";
}

function am__rerun_tests() {
    #
    # Whereas the Makefile already did this, we don't need to *redo* it.
    #
    # $(TEST_SUITE_LOG): $(TEST_LOGS)
    # \t.../test-suite-compiler $@ $^
    #
    test 0 != $rerun_mode
}

if am__rerun_tests; then
    declare -a redo_bases
    declare -a redo_logs
    declare -a redo_results
    debug "redoing? yes"
    debug "bases=( ${bases[@]} )"
    redo_bases=( $(for i in ${bases[@]}; do am__f_ok $i.trs && am__f_ok $i.log || echo $i; done) )
    if ((0 == ${#redo_bases[@]})); then
        debug "there are no test logs to redo, they all seem to exist"
    else
        debug "redo_bases=( ${redo_bases[@]} )"
        redo_logs=( "${redo_bases[@]/%/.log}" )
        redo_results=( "${redo_bases[@]/%/.trs}" )
        if ! am__make_dryrun; then
          rm -f "${redo_logs[@]}" && rm -f "${redo_results[@]}" || exit 1;
        fi;
        # the variable is expected and supposed to be unbound; if bound then there is a problem.
        if test -n "${am__remaking_logs:-}"; then
          echo "fatal: making ${TEST_SUITE_LOG}: possible infinite recursion detected" >&2;
        else
          # prevent infinite recusion by setting the semaphore ${am__remaking_logs}
          am__remaking_logs=yes ${MAKE:-make} ${AM_MAKEFLAGS:-} "${redo_logs[@]}"
        fi;
        if ! am__make_dryrun; then
          st=0;
          errmsg="fatal: making ${TEST_SUITE_LOG}: failed to create";
          for i in ${redo_bases[@]}; do
            test -f $i.trs && test -r $i.trs || { echo "$errmsg $i.trs" >&2; st=1; };
            test -f $i.log && test -r $i.log || { echo "$errmsg $i.log" >&2; st=1; };
          done;
          test $st -eq 0 || exit 1;
        fi
    fi
fi

function am__tty_colors() {
  mgn= red= grn= lgn= blu= brg= std=;
  am__color_tests=no
  if test "X${AM_COLOR_TESTS:-}" = Xno; then
    am__color_tests=no;
  elif test "X${AM_COLOR_TESTS:-}" = Xalways; then
    am__color_tests=yes;
  elif test "X${TERM:-dumb}" != Xdumb && { test -t 1; } 2>/dev/null; then
    am__color_tests=yes;
  fi;
  if test $$am__color_tests = yes; then
    red='[0;31m';
    grn='[0;32m';
    lgn='[1;32m';
    blu='[1;34m';
    mgn='[0;35m';
    brg='[1m';
    std='[m';
  fi;
}

am__tty_colors
declare -a results=( "${bases[@]/%/.trs}" )
debug "results[trs]=( ${results[@]} )"

# RESULT may be ''
function count_phase() {
    local RESULT=$1; shift
    local -a inputs=( "$@" )
    local ws='[ 	]'
    grep -e "^$ws*:test-result:$ws*$RESULT" ${inputs[@]} /dev/null | wc -l;
}

all=$(count_phase '' ${results[@]})
pass=$(count_phase PASS ${results[@]})
fail=$(count_phase FAIL ${results[@]})
skip=$(count_phase SKIP ${results[@]})
xfail=$(count_phase XFAIL ${results[@]})
xpass=$(count_phase XPASS ${results[@]})
error=$(count_phase ERROR ${results[@]})
if ((0 == fail + xpass + error)); then
  success=1;
else
  success=0;
fi;


#
# display_result_count [ --maybe-color | --no-color ] $phase $count
#
# $phase in { TOTAL PASS SKIP XFAIL FAIL XPASS ERROR }
#
function display_result_count () {
    if test x"$1" = x"--maybe-color"; then
      maybe_colorize=yes;
    elif test x"$1" = x"--no-color"; then
      maybe_colorize=no;
    else
      # when in a Makfeile then $@ is the current production
      echo "${NAME}: error, invalid 'display_result_count' usage" >&2; exit 4;
    fi;
    shift;
    desc=$1 count=$2;
    if test $maybe_colorize = yes && test $count -gt 0; then
      color_start=$3 color_end=$std;
    else
      color_start= color_end=;
    fi;
    echo "${color_start}# $desc $count${color_end}";
}

function create_testsuite_report () {
  display_result_count $1 "TOTAL:" $all   "$brg";
  display_result_count $1 "PASS: " $pass  "$grn";
  display_result_count $1 "SKIP: " $skip  "$blu";
  display_result_count $1 "XFAIL:" $xfail "$lgn";
  display_result_count $1 "FAIL: " $fail  "$red";
  display_result_count $1 "XPASS:" $xpass "$red";
  display_result_count $1 "ERROR:" $error "$mgn";
}

function am__rst_title() {
    sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo;
}

# A command that, given a newline-separated list of test names on the
# standard input, create the global log from their .trs and .log files.
function am__create_global_log() {
    ${AWK} '
function fatal(msg)
{
  print "'${##0}': fatal[awk], " msg | "cat >&2";
  exit 1;
}
function rst_section(header)
{
  print header;
  len = length(header);
  for (i = 1; i <= len; i = i + 1)
    printf "=";
  printf "\n\n";
}
{
  copy_in_global_log = 1;
  global_test_result = "RUN";
  while ((rc = (getline line < ($0 ".trs"))) != 0)
    {
      if (rc < 0)
         fatal("failed to read from " $0 ".trs");
      if (line ~ /^[ 	]*:global-test-result:[ 	]*/)
        {
          sub("^[ 	]*:global-test-result:[ 	]*", "", line);
          sub("[ 	]*$", "", line);
          global_test_result = line;
        }
      else if (line ~ /^[ 	]*:copy-in-global-log:[ 	]*[nN][oO]/)
        copy_in_global_log = 0;
    };
  if (copy_in_global_log)
    {
      rst_section(global_test_result ": " $0);
      while ((rc = (getline line < ($0 ".log"))) != 0)
      {
        if (rc < 0)
          fatal("failed to read from " $0 ".log");
        print line;
      };
      printf "\n";
    };
  close ($0 ".trs");
  close ($0 ".log");
}'
}

declare -i missing_logs=0
{
    declare -a retest_logs
    retest_logs=( )
    for log in "${TEST_LOGS[@]}" ; do
        if [ ! -e "$log" ] ; then
            echo "$NAME: warning, log file $log is missing (ignoring it)"
            missing_logs=1
        elif ((0 == ${#retest_logs[@]})); then
            retest_logs=( "$log" )
        else
            retest_logs=( "${retest_logs[@]}" "$log" )
        fi
    done
    TEST_LOGS=( "${retest_logs[@]}" )
} 1>&2
{
  echo "${PACKAGE_STRING:-\$PACKAGE_STRING}: ${subdir:-\$subdir}/${TEST_SUITE_LOG}" | am__rst_title;
  create_testsuite_report --no-color;
  echo;
  echo ".. contents:: :depth: 2";
  echo;
  for b in $bases; do echo $b; done | am__create_global_log;
} >${TEST_SUITE_LOG}.tmp || exit 1;
mv ${TEST_SUITE_LOG}.tmp ${TEST_SUITE_LOG};
if ((success)); then
  col="$grn";
 else
  col="$red";
  test "${VERBOSE:-no}" = no || cat ${TEST_SUITE_LOG};
fi;

br='==================='; br=$br$br$br$br;
echo "${col}$br${std}";
echo "${col}Testsuite summary for ${PACKAGE_STRING:-\$PACKAGE_STRING}${std}";
echo "${col}$br${std}";
create_testsuite_report --maybe-color
echo "$col$br$std";
if ((success)); then :; else
  echo "${col}See ${subdir:-\$subdir}/${TEST_SUITE_LOG}${std}";
  if test -n "${PACKAGE_BUGREPORT:-\$PACKAGE_BUGREPORT}"; then
    echo "${col}Please report problems to ${PACKAGE_BUGREPORT:-\$PACKAGE_BUGREPORT}${std}";
  fi;
  echo "$col$br$std";
fi;

if ((!missing_logs && success)) ; then
    exit 0
else
    exit 1
fi
