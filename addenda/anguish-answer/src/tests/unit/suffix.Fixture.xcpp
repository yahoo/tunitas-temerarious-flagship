// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests::unit::suffix { class Fixture; }
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
class tests::unit::suffix::Fixture : public cppunit::test::Fixture {
public:
  template<typename TYPE> auto test_Limits() -> void;
  auto test_Neighbors() -> void;
  auto test_Suffix() -> void;
  auto test_Suffix_less() -> void;
  auto test_Step() -> void;
  auto test_Step_less() -> void;
  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
#import scold.easy.suffix.Limits
template<typename TYPE> auto tests::unit::suffix::Fixture::test_Limits() -> void {
  using Subject = ::scold::easy::suffix::Limits<TYPE>;
  auto min = Subject::min();
  auto max = Subject::max();
  CPPUNIT_ASSERT(min < max);
}
#import scold.easy.suffix.Neighbors
auto tests::unit::suffix::Fixture::test_Neighbors() -> void {
  using Subject = ::scold::easy::suffix::Neighbors;
  Subject subject00;
  CPPUNIT_ASSERT(!subject00.pred);
  Subject subject01 = Subject{Subject::NONE, Subject::NONE};
  CPPUNIT_ASSERT(!subject01.pred);
  using ::scold::easy::suffix::Step;
  auto subject1 = Subject{Step::FPP, Step::HPP};
  auto subject2 = Subject{Step::HPP, Step::IPP};
  CPPUNIT_ASSERT(subject1.succ == subject2.pred);
  // NO SUCH operator!= -----> CPPUNIT_ASSERT(subject00 != subject01);
  // NO SUCH operator!= -----> CPPUNIT_ASSERT(subject1 != subject2);
}
#import scold.easy.suffix.Suffix
auto tests::unit::suffix::Fixture::test_Suffix() -> void {
  using Subject = ::scold::easy::suffix::Suffix;
  auto const subject = Subject{};
  auto const fpp = Subject::FPP;
  auto const hpp = Subject::HPP;
  CPPUNIT_ASSERT(fpp == subject);
  CPPUNIT_ASSERT(fpp != hpp);
}
#import scold.easy.suffix.Suffix.less
auto tests::unit::suffix::Fixture::test_Suffix_less() -> void {
  using Subject = ::scold::easy::suffix::Suffix;
  auto less = std::less<Subject>{};
  auto const fpp = Subject::FPP;
  auto const hpp = Subject::HPP;
  CPPUNIT_ASSERT(less(fpp, hpp));
}
#import scold.easy.suffix.Step
auto tests::unit::suffix::Fixture::test_Step() -> void {
  using Subject = ::scold::easy::suffix::Step;
  using Suffix = ::scold::easy::suffix::Suffix;
  auto const subjectSuffix0 = Subject{Suffix{}};
  auto const subjectDEFAULT = Subject{Subject::BEGIN}; // actually there is no available Subject{}
  auto const beg = Subject::BEGIN;
  auto const fpp = Subject::FPP;
  auto const hpp = Subject::HPP;
  CPPUNIT_ASSERT(subjectDEFAULT != subjectSuffix0);
  CPPUNIT_ASSERT(beg == beg);
  std::cerr << "to_string(subjectSuffix0): " << to_string(subjectSuffix0) << '\n';
  std::cerr << "to_string(subjectDEFAULT): " << [&subjectDEFAULT]() {
                                                  try {
                                                    return to_string(subjectDEFAULT);
                                                  } catch (std::exception const &) {
                                                    // there is no string repressentation for this value
                                                    return "subjectDEFAULT"s;
                                                  }
                                                }() << '\n';
  CPPUNIT_ASSERT(beg == subjectDEFAULT);
  CPPUNIT_ASSERT(fpp == subjectSuffix0);
  CPPUNIT_ASSERT(fpp != beg);
  CPPUNIT_ASSERT(fpp != hpp);
}
#import scold.easy.suffix.Step.less
auto tests::unit::suffix::Fixture::test_Step_less() -> void {
  using Subject = ::scold::easy::suffix::Step;
  using Step = ::scold::easy::suffix::Step;
  auto less = std::less<Subject>{};
  auto const beg = Subject{Step::BEGIN};
  auto const fpp = Subject{Step::FPP};
  auto const hpp = Subject{Step::HPP};
  CPPUNIT_ASSERT(less(beg, fpp));
  CPPUNIT_ASSERT(less(fpp, hpp));
}
#import rigging.suite.io
#import scold.easy.suffix.Suffix
#import scold.easy.suffix.Step
auto tests::unit::suffix::Fixture::suite() -> cppunit::Test * {
  using namespace ::rigging::suite;
  Stream series{"suffix"};
  series << []() {
              Stream lim{"Limits"};
              lim << call("Suffix", &Fixture::test_Limits<scold::easy::suffix::Suffix>)
                  << call("Step", &Fixture::test_Limits<scold::easy::suffix::Step>)
                ;
              return lim;
            }()
         << call("Neighbors", &Fixture::test_Neighbors)
         << call("Suffix", &Fixture::test_Suffix)
         << call("less<Suffix>", &Fixture::test_Suffix_less)
         << call("Step", &Fixture::test_Step)
         << call("less<Step>", &Fixture::test_Step_less)
    ;
  return finalize(series);
}
#endiv
