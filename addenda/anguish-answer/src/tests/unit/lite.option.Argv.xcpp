// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace tests::unit::lite::option { class Argv; }
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
#import lite.cli.option.Argv
class tests::unit::lite::option::Argv : public cppunit::test::Fixture {
public:
  using Subject = ::lite::cli::option::Argv;
  auto test_constructor_default() -> void;
  auto test_constructor_int() -> void;
  auto test_constructor_size() -> void;
  auto test_shift() -> void;
  auto test_done() -> void;
  auto test_front() -> void;
  auto test_usage_01() -> void;
  auto test_usage_02() -> void;
  auto test_usage_03() -> void;
  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
auto tests::unit::lite::option::Argv::test_constructor_default() -> void {
  Subject subject;
  CPPUNIT_ASSERT(0 == subject.size());
}
auto tests::unit::lite::option::Argv::test_constructor_int() -> void {
  {
    char v1s0[] = "a.out";
    char *v1[] = { v1s0, nullptr };
    int c = 1; // <---------------------- test this with int
    Subject subject{c, v1};
    CPPUNIT_ASSERT(1 == subject.size());
  } {
    char v2s0[] = "a.out";
    char v2s1[] = "-f";
    char *v2[] = { v2s0, v2s1, nullptr };
    int c = 2; // <---------------------- test this with int
    Subject subject{c, v2};
    CPPUNIT_ASSERT(2 == subject.size());
  }
}
auto tests::unit::lite::option::Argv::test_constructor_size() -> void {
  {
    char v1s0[] = "a.out";
    char *v1[] = { v1s0, nullptr };
    std::size_t s = 1; // <---------------------- test this with size_t
    Subject subject{s, v1};
    CPPUNIT_ASSERT(1 == subject.size());
  } {
    char v2s0[] = "a.out";
    char v2s1[] = "-f";
    std::size_t s = 2; // <---------------------- test this with size_t
    char *v2[] = { v2s0, v2s1, nullptr };
    Subject subject{s, v2};
    CPPUNIT_ASSERT(2 == subject.size());
  }
}
#import std.string_literals
auto tests::unit::lite::option::Argv::test_shift() -> void {
  using namespace std::string_literals;
  char vs0[] = "a.out";
  char vsa[] = "-a";
  char vsb[] = "-b";
  char vsc[] = "-c";
  char vsd[] = "-d";
  std::size_t s = 5; // <---------------------- test this with size_t
  char *v[] = { vs0, vsa, vsb, vsc, vsd, nullptr };
  Subject subject{s, v};
  subject = shift(subject); // -a
  subject = shift(subject); // -b
  subject = shift(subject); // -c
  subject = shift(subject); // -d
  try {
    shift(subject);
    CPPUNIT_ASSERT(false);
  } catch (std::exception const &) {
    CPPUNIT_ASSERT(true);
  }
}
auto tests::unit::lite::option::Argv::test_done() -> void {
  using namespace std::string_literals;
  char vs0[] = "a.out";
  char vsa[] = "-a";
  char vsb[] = "-b";
  char vsc[] = "-c";
  char vsd[] = "-d";
  std::size_t s = 5; // <---------------------- test this with size_t
  char *v[] = { vs0, vsa, vsb, vsc, vsd, nullptr };
  Subject subject{s, v};
  subject = shift(subject);
  CPPUNIT_ASSERT(!done(subject)); // -a
  CPPUNIT_ASSERT_EQUAL("-a"s, front(subject)); // -a
  subject = shift(subject);
  CPPUNIT_ASSERT_EQUAL("-b"s, front(subject)); // -b
  CPPUNIT_ASSERT(!done(subject)); // -b
  subject = shift(subject);
  CPPUNIT_ASSERT_EQUAL("-c"s, front(subject)); // -c
  CPPUNIT_ASSERT(!done(subject)); // -c
  subject = shift(subject);
  CPPUNIT_ASSERT_EQUAL("-d"s, front(subject)); // -d
  CPPUNIT_ASSERT(!done(subject)); // -d
  subject = shift(subject);
  CPPUNIT_ASSERT(done(subject)); // DONE
}
auto tests::unit::lite::option::Argv::test_front() -> void {
  using namespace std::string_literals;
  char vs0[] = "a.out";
  char vsa[] = "-a";
  char vsb[] = "-b";
  char vsc[] = "-c";
  char vsd[] = "-d";
  std::size_t s = 5; // <---------------------- test this with size_t
  char *v[] = { vs0, vsa, vsb, vsc, vsd, nullptr };
  Subject subject{s, v};
  subject = shift(subject);
  auto a = front(subject);
  CPPUNIT_ASSERT("-a"s == a);
  subject = shift(subject);
  auto b = front(subject);
  CPPUNIT_ASSERT("-b"s == b);
  subject = shift(subject);
  auto c = front(subject);
  CPPUNIT_ASSERT("-c"s == c);
  subject = shift(subject);
  auto d = front(subject);
  CPPUNIT_ASSERT("-d"s == d);
  subject = shift(subject);
  try {
    CPPUNIT_ASSERT(done(subject));
    front(subject);
    CPPUNIT_ASSERT(false);
  } catch (std::exception const &) {
    CPPUNIT_ASSERT(true);
  }
}
auto tests::unit::lite::option::Argv::test_usage_01() -> void {
  char vs0[] = "a.out";
  char vsa[] = "-a";
  char vsb[] = "-b";
  char vsc[] = "-c";
  char vsd[] = "-d";
  std::size_t EXPECTED = 5; // <---------------------- test this with size_t
  char *v[] = { vs0, vsa, vsb, vsc, vsd, nullptr };
  Subject args{EXPECTED, v};
  auto count = 0lu;
  for (args=shift(args); !done(args); args=shift(args)) {
    ++count;
  }
  CPPUNIT_ASSERT_EQUAL(EXPECTED-1, count);
}
auto tests::unit::lite::option::Argv::test_usage_02() -> void {
  char vs0[] = "a.out";
  std::size_t EXPECTED = 1; // <---------------------- test this with size_t
  char *v[] = { vs0, nullptr };
  Subject args{EXPECTED, v};
  auto count = 0lu;
  for (args=shift(args); !done(args); args=shift(args)) {
    ++count;
  }
  CPPUNIT_ASSERT_EQUAL(EXPECTED-1, count);
}
auto tests::unit::lite::option::Argv::test_usage_03() -> void {
  //
  // huh ... what else is there to test here?
  //
  CPPUNIT_ASSERT(true);
}
#import rigging.suite.io
auto tests::unit::lite::option::Argv::suite() -> cppunit::Test * {
  using namespace ::rigging::suite;
  Stream series("Argv");
  { 
    Stream con("constructor");
    con << call("default", &Argv::test_constructor_default)
        << call("{int,char*[]}", &Argv::test_constructor_int)
        << call("{size,char*[]", &Argv::test_constructor_size)
      ;
    series << move(con);
  }
  series << call("shift", &Argv::test_shift)
         << call("done", &Argv::test_done)
         << call("front", &Argv::test_front)
    ;
  { 
    Stream use("usage");
    use << call("01", &Argv::test_usage_01)
        << call("01", &Argv::test_usage_02)
        << call("03", &Argv::test_usage_03)
      ;
    series << move(use);
  }
  return finalize(series);
}
#endiv
