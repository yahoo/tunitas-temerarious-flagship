// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace lite::cli::option {
  //
  // The raw argument vector, from the operating system
  // With some common (perlish, bashish) operations upon it.
  //
  // WATCHOUT - you can't use this on arbitrary data types, the final nullptr sentinel is REQUIRED.
  // If you want to process arbitrary pointer-to-pointer type data structures, use
  // std::basic_vector<har> which does not check for the nullptr sentinel
  //
  // Let  main(3, v)
  // Then char *v[4] = { "a.out", "-flag", "-flag", nullptr };
  //                                                ^
  //                                                |
  //    this nullptr is provided by libc -----------/
  //
  // Usage:
  //
  //   auto main(int c, char *v[]) -> int {
  //     using namespace lite;
  //     cli::option::Argv argv{c, v};
  //     for (argv=shift(argv); !done(argv); argv=shift(argv)) {
  //       auto const candidate = front(argv);
  //     }
  //   }
  //
  class Argv;
}
#endiv
#divert <hpp>
#import std.string
namespace lite::cli::option {
  inline auto shift(Argv) -> Argv;
  inline auto done(Argv const &) -> bool;
  inline auto front(Argv const &) -> std::string;
}
#import c.argv
#import std.size_t
namespace lite::cli {
  class option::Argv : public c::argv {
    using ancestor = c::argv;
  public:
    Argv() = default;
    //using ancestor::basic_argv;
    inline Argv(int, char *[]); // exactly the same as main(int, char *[])
    inline Argv(std::size_t, char *[]); // what you'd expect
  };
}
#endiv
#divert <ipp>
#import std.max
namespace lite::cli::option {
  Argv::Argv(int c, char *v[])
    : ancestor{(std::size_t)std::max(0, c), v}
  { }
  Argv::Argv(std::size_t s, char *v[])
    : ancestor{s, v}
  { }
}
namespace lite::cli {
  auto option::shift(Argv av) -> Argv {
    if (av.empty()) {
      throw std::invalid_argument{"empty"};
    }
    return Argv{av.size()-1, 1+av.data()};
  }
  auto option::done(Argv const &av) -> bool {
    return av.empty();
  }
  auto option::front(Argv const &av) -> std::string {
  if (av.empty()) {
      throw std::invalid_argument{"empty"};
    }
    return std::string{av.front()};
  }
}
#endiv
