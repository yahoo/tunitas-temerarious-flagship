// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.string
namespace lite::cli::option {
  //
  // The "any" operator
  // Overloads operator== to mean "any of these"
  //
  // Usage:
  //
  //   auto const word = front(argv);
  //   if (word == any("-v", "--verbose"s)) {
  //      verbose_mode = true;
  //   }
  template<typename... STRINGS> class Any;
  template<> class Any<>;
  template<typename... REST> class Any<std::string, REST...>;
}
#endiv
#divert <hpp>
namespace lite::cli::option {
  template<> struct Any<> { };
  template<typename... REST> class Any<std::string, REST...> : public Any<REST...> {
    using ancestor = Any<REST...>;
  public:
    using Value = std::string;
    using Rest = Any<REST...>;
    inline explicit Any(Value, REST ...);
    Value value;
  };
  inline auto operator==(std::string const &, Any<> const &) -> bool;
  template<typename... STRINGS> inline auto operator==(std::string const &, Any<std::string, STRINGS...> const &) -> bool;
}
#endiv
#divert <ipp>
#import std.move
namespace lite::cli {
  auto option::operator==(std::string const &lhs, Any<> const &rhs) -> bool {
    return false;
  }
  template<typename... STRINGS> auto option::operator==(std::string const &lhs, Any<std::string, STRINGS...> const &rhs) -> bool {
    if (lhs == rhs.value) {
      return true;
    } else {
      return operator==(lhs, static_cast<typename Any<STRINGS...>::Rest const &>(rhs));
    }
  }
}
#import std.move
namespace lite::cli::option {
  template<typename... REST> Any<std::string, REST...>::Any(Value first, REST ...rest)
    : value{std::move(first)}
    , ancestor{std::move(rest)...}
  { }
}
#endiv
