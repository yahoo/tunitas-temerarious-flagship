// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <hpp>
#import scold.easy.option.Argv
#import nonstd.sysexits.constants 
namespace scold::easy {
  //
  // Called from ::main(int, char **)
  //
  // Usage:
  //
  //   auto main(int c, char *v[]) -> int {
  //     return remain(potion::Argv{c, v});
  //   }
  //
  auto remain(option::Argv) -> nonstd::sysexits::Code;
}
#endiv
#divert <cpp>
// see .../src/app/dc/remain.xcpp
//   auto remain(int c, char *v[]) -> int { return scold::easy::remain(option::Argv(c, v}); }
#import scold.easy.exception.Quitting
#import nonstd.sysexits.constants // FAIL
#import scold.easy.Configuration
#import scold.easy.Program
#import scold.easy.core.process
#import scold.easy.exception.aspect.Exiting
#import scold.easy.filesystem.operations
#import scold.easy.option.Parser
#import scold.easy.debuggable
auto scold::easy::remain(option::Argv argv) -> nonstd::sysexits::Code {
  using nonstd::sysexits::FAIL;
  using namespace filesystem;
  try {
    Program program{argv.front()};
    Configuration cfg{program};
    option::Parser parser{cfg};
    auto parsed = parser.parse(argv);
    if (!ok(parsed)) {
      (error(cfg) << "could not parse the options" << end(cfg));
      throw exception::Quitting{cfg.NAME, FAIL, "bad options"};
    } 
    if (cfg.debug_mode) {
      if (!cfg.verbose_mode) {
        std::clog << cfg.NAME << ", debug mode implies verbose mode, enabling verbose mode\n";
        cfg.verbose_mode = true;
      }
      debug(cfg) << "SEARCHPATH=" << debuggable(cfg.searchpath)
                 << " SOURCES_AREA=" << debuggable(cfg.project.sources_area)
                 << " LOCAL_OBJECTS_AREA=" << debuggable(cfg.project.local_objects_area)
                 << " LOCAL_MODULES_AREA=" << debuggable(cfg.project.local_modules_area)
                 << end(cfg);
    }
    if (!isa_directory(cfg.project.sources_area)) {
      (error(cfg) << "the --srcdir directory " << cfg.project.sources_area << " does not exist" << end(cfg));
      throw exception::Quitting{cfg.NAME, FAIL, "no srcdir directory"};
    }
    if (!isa_directory(cfg.project.local_objects_area)) {
      (error(cfg) << "the --objdir directory " << cfg.project.local_objects_area << " does not exist" << end(cfg));
      throw exception::Quitting{cfg.NAME, FAIL, "no objdir directory"};
    }
    if (!isa_directory(cfg.project.local_modules_area)) {
      (error(cfg) << "the --modulesdir directory " << cfg.project.local_modules_area << " does not exist" << end(cfg));
      throw exception::Quitting{cfg.NAME, FAIL, "no modulesdir directory"};
    }
    for (auto const &path : cfg.searchpath) {
      if (!isa_directory(path)) {
        // this is not necessarily an error, but will likely cause problems.
        (warning(cfg) << "the searchpath directory " << path << " does not exist " << end(cfg));
      }
    }
    auto files = value(std::move(parsed));
    for (auto const &path : files) {
      if (!isa_file(path)) {
        (warning(cfg) << "the source file " << path << " does not exist " << end(cfg));
        // we will run into hard errors in processing.
      }
    }
    for (auto const &filepath : files) {
      core::process(cfg, filepath);
    }
    return cfg.exit_code;
  } catch (exception::aspect::Exiting const &e) {
    e.stream() << put(e) << '\n';
    return e.code();
  }
}
#endiv
