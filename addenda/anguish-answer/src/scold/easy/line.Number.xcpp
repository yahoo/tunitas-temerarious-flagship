// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.uintmax_t
namespace scold::easy::line {
  //
  // The line number in a file.
  // Is its own special thing, not to be confused with an integer.
  //
  // Usage:
  //
  //   Number z = Number{};
  //   Number v1 = Number{1};
  //   auto v2 = 1 + v1;
  //   auto cur = v2;
  //   ++cur;
  //   cur++;
  //   auto b = z == cur;
  //   auto b = z != cur;
  //
  //   std::cout << "file.cpp:" << v1 << ": at that line, right there\n";
  //   auto s = to_string(v2);
  // 
  enum Number : std::uintmax_t;
}
#endiv
#divert <hpp>
#import std.basic_ostream
#import nonstd.required.Character
#import nonstd.required.Character_Traits
#import scold.easy.required
namespace scold::easy::line {
  template<required::Character CHAR, required::Character_Traits TRAITS> inline auto operator<<(std::basic_ostream<CHAR, TRAITS> &, Number const &) -> std::basic_ostream<CHAR, TRAITS> &;
  inline auto to_string(Number const &) -> std::string;
  inline auto operator++(Number &) -> Number &;
  inline auto operator++(Number &, int) -> Number;
  inline auto operator+(Number const &, int) -> Number;
  inline auto operator+(int, Number const &) -> Number;
  // Want operator<=>
  inline auto operator<(Number const &, Number const &) -> bool;
  inline auto operator<=(Number const &, Number const &) -> bool;
  inline auto operator>(Number const &, Number const &) -> bool;
  inline auto operator>=(Number const &, Number const &) -> bool;
}
namespace std {
  using scold::easy::line::to_string; // and any other one that happens to appear herein
}
#endiv
#divert <ipp>
#import std.underlying_type
#import std.to_string
namespace scold::easy {
  template<required::Character CHAR, required::Character_Traits TRAITS> auto line::operator<<(std::basic_ostream<CHAR, TRAITS> &o, Number const &n) -> std::basic_ostream<CHAR, TRAITS> & {
    using Underlying = typename std::underlying_type<Number>::type;
    return o << (Underlying) n;
  }
  auto line::to_string(Number const &n) -> std::string {
    using Underlying = typename std::underlying_type<Number>::type;
    return std::to_string((Underlying) n);
  }
  auto line::operator+(Number const &n, int i) -> Number {
    using Underlying = typename std::underlying_type<Number>::type;
    return Number{i + (Underlying) n};
  }
  auto line::operator+(int i, Number const & n) -> Number {
    return operator+(n, i);
  }
  auto line::operator++(Number &lhs) -> Number & {
    using Underlying = typename std::underlying_type<Number>::type;
    lhs = Number{1u + (Underlying) lhs};
    return lhs;
  }
  auto line::operator++(Number &lhs, int) -> Number {
    Number old{lhs};
    ++lhs;
    return old;
  }
  auto line::operator<(Number const &a, Number const &b) -> bool {
    using Underlying = typename std::underlying_type<Number>::type;
    return (Underlying) a < (Underlying) b;
  }
  auto line::operator<=(Number const &a, Number const &b) -> bool {
    using Underlying = typename std::underlying_type<Number>::type;
    return (Underlying) a <= (Underlying) b;
  }
  auto line::operator>(Number const &a, Number const &b) -> bool {
    return operator<(b, a);
  }
  auto line::operator>=(Number const &a, Number const &b) -> bool {
    return operator<=(b, a);
  }
}
#endiv
