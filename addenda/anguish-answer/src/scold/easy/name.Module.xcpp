// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::name {
  //
  // A module name
  //
  // Usage:
  //
  //   auto m = Module{"a.b.c"};
  //   auto m = Module{"nonstd"};
  //   auto m = Module{"nonstd.filesystem.path"};
  //
  enum MODULE {};
  class Module;
}
#endiv
#divert <hpp>
#import scold.easy.name.Filepath
#import scold.easy.tagged.String
#import std.string
class scold::easy::name::Module : protected tagged::String<MODULE> {
  using ancestor = tagged::String<MODULE>;
public:
  Module() = default;
  inline explicit Module(std::string);
  inline auto operator=(std::string) -> Module &;
  Module(Module const &) = default;
  auto operator=(Module const &) -> Module & = default;
  using ancestor::basic_string;
  using ancestor::empty;
  using ancestor::size;
  inline explicit operator Filepath() const;
  // converting ‘scold::easy::name::Module’ to a base class ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’} will never use a type conversion operator [-Wclass-conversion]
  // NEVER ---> inline explicit operator std::string() const;
};
#endiv
#divert <ipp>
#import std.move
namespace scold::easy::name {
  Module::Module(std::string value)
    : ancestor{std::move(value)}
  { }
  auto Module::operator=(std::string value) -> Module & {
    ancestor::operator=(std::move(value));
    return *this;
  }
  Module::operator Filepath() const {
    return Filepath{static_cast<std::string const &>(*this)};
  }
}
#endiv

