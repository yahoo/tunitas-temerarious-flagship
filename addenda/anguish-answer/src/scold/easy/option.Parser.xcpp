// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import scold.easy.option
namespace scold::easy::option {
  //
  // Option parsing
  //
  // Usage:
  //
  //   Program program{av.front()};
  //   Configuration cfg{program};
  //   Parser parser{cfg};
  //   auto parsed = parser.parse(av);
  //   if (!ok(parsed)) {
  //     cerr << "error: there were problems, namely " << error_code(parsed).message() << '\n';
  //     return 1;
  //   }
  //   auto arguments = value(std::move(parsed));
  //   for (auto const &arg : arguments) {
  //     ...use the argument...
  //   }
  //
  class Parser;
}
#endiv
#divert <hpp>
#import lite.cli.option.Argv
#import scold.easy.option // cascade lite::cli::option
#forward scold.easy.Configuration
#import scold.easy.option.parser.Result
#import std.string
class scold::easy::option::Parser {
public:
  // There is no specification here, it is all open-coded
  inline explicit Parser(Configuration &cfg) : cfg{cfg} { }
  auto parse([[inout]] Argv) -> parser::Result;
protected:
  Configuration &cfg;
private:
  // Remove any leading "./" ... lest they cause comparison problems later.
  inline auto trim_dot_slash(std::string) -> std::string;
};
#endiv
#divert <ipp>
#import scold.easy.Configuration
#import std.move
auto scold::easy::option::Parser::trim_dot_slash(std::string specimen) -> std::string {
  using namespace std::string_literals;
  static auto const dot_literal = "./"s;
  auto const dot_start = 0lu;
  auto const dot_length = dot_literal.size();
  if (dot_length < specimen.size() && dot_literal == specimen.substr(dot_start, dot_length)) {
    specimen.erase(dot_start, dot_length);
  }
  return std::move(specimen);
}
#endiv
#divert <cpp>
#import nonstd.sysexits.constants
#import scold.easy.cascade.Matryoshka
#import scold.easy.exception.Quitting
#import scold.easy.exception.Version
#import scold.easy.exception.Usage
#import scold.easy.Searchpath
#import scold.easy.outcome.Code
#import std.error_code
#import std.string_literals
#import want.aliases.any
#import want.aliases.starts_with
using namespace std::string_literals;
auto scold::easy::option::Parser::parse(Argv args) -> parser::Result {
  using namespace want::aliases;
  using namespace parser;
  auto failcode = outcome::Code::SUCCESS;
  std::optional<std::filesystem::path> sources_area, local_objects_area, local_modules_area;
  for (args=shift(args); !done(args); args=shift(args)) {
    auto const arg = front(args);
    if (false) {
    } else if (any("--insert-namespace", "--insert-namespaces") == arg) {
      cfg.insert_namespace_mode = cascade::Matryoshka::YES;
    } else if (any("--no-insert-namespace", "--no-insert-namespaces") == arg) {
      cfg.insert_namespace_mode = cascade::Matryoshka::NO;
    } else if (any("-d"s, "--debug"s) == arg) {
      cfg.debug_mode = true;
    } else if (any("--no-debug"s) == arg) {
      cfg.debug_mode = false;
    } else if (any("-q", "--quiet") == arg) {
      cfg.quiet_mode = true;
    } else if (any("--no-quiet") == arg) {
      cfg.quiet_mode = false;
    } else if (any("-w", "--warning", "--warnings") == arg) {
      cfg.warnings_mode = true;
    } else if (any("--no-warning", "--no-warnings") == arg) {
      cfg.warnings_mode = false;
    } else if (any("-v", "--verbose") == arg) {
      cfg.verbose_mode = true;
    } else if (any("--no-verbose") == arg) {
      cfg.verbose_mode = false;
    } else if (any("-y", "--dryrun", "--dry-run") == arg) {
      cfg.dry_run_mode = true;
    } else if (any("--no-dryrun", "--no-dry-run") == arg) {
      cfg.dry_run_mode = false;
    } else if (auto started = starts_with("-I"s, "--include=") == arg; started) {
      cfg.searchpath.push_back(Searchpath::Internal{std::move(started.value())});
    } else if (any("-I"s, "--include"s) == arg) {
      args = shift(args);
      if (done(args)) {
        (error(cfg) << "-I requires a pathname following it" << end(cfg));
        return Result{std::error_code{outcome::Code::OPTION_VALUE_IS_MISSING}};
      }
      cfg.searchpath.push_back(Searchpath::Internal{arg});
    } else if (any("-E"s, "--external"s) == arg) {
      args = shift(args);
      if (done(args)) {
        (error(cfg) << "-E requires a pathname following it" << end(cfg));
        return Result{std::error_code{outcome::Code::OPTION_VALUE_IS_MISSING}};
      }
      cfg.searchpath.push_back(Searchpath::External{arg});
    } else if (auto started = starts_with("-E", "--external=") == arg; started) {
      cfg.searchpath.push_back(Searchpath::External{std::move(started.value())});
    } else if (auto started = starts_with("--srcdir="s) == arg; started) {
      sources_area = trim_dot_slash(started.value());
    } else if (auto started = starts_with("--objdir="s) == arg; started) {
      local_objects_area = trim_dot_slash(started.value());
    } else if (auto started = starts_with("--modulesdir="s) == arg; started) {
      local_modules_area = trim_dot_slash(started.value());
    } else if (any("-V"s, "--version"s) == arg) {
      throw exception::Version{cfg.NAME};
    } else if (any("-h"s, "--help"s, "--usage"s) == arg) {
      throw exception::Usage{cfg.NAME, nonstd::sysexits::OK};
    } else if (arg.size() && '-' == arg.front()) {
      (error(cfg) << "unknown option " << arg << end(cfg));
      failcode = outcome::Code::OPTION_IS_UNKNOWN;
    } else {
      break;
    }
  }
  if (!sources_area) {
    (error(cfg) << "the sources area is unset; use --srcdir=DIRECTORY" << end(cfg));
    failcode = outcome::Code::OPTION_SET_IS_INCOMPLETE;
  } else {
    cfg.project.sources_area = *sources_area;
  }
  if (!local_objects_area) {
    (error(cfg) << "the objects area is unset; use --objdir=DIRECTORY " << end(cfg));
    failcode = outcome::Code::OPTION_SET_IS_INCOMPLETE;
  } else {
    cfg.project.local_objects_area = *local_objects_area;
  }
  if (!local_modules_area) {
    (error(cfg) << "the modules area is unset; use --modulesdir=DIRECTORY " << end(cfg));
    failcode = outcome::Code::OPTION_SET_IS_INCOMPLETE;
  } else {
    cfg.project.local_modules_area = *local_modules_area;
  }
  if (outcome::Code::SUCCESS != failcode) {
    return Result{std::error_code{failcode}};
  } else {
    return Result{Arguments{args.begin(), args.end()}};
  }
}
#endiv
