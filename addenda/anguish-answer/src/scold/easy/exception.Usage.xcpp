// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::exception {
  //
  // Usage number as an exception object.
  // Asking for the version is always a success outcome.
  //
  // Usage:
  //
  //   try {
  //     ...computing...
  //     throw Usage{NAME, OK};
  //     throw Usage{NAME, USAGE};
  //     throw Usage{NAME, FAIL};
  //     ...
  //   } catch (exception::aspect::Exiting const &e) {
  //     e.stream() << format(e) << '\n';
  //   }
  //
  class Usage;
}
#endiv
#divert <hpp>
#import nonstd.sysexits.Code
#import scold.easy.Program
#import scold.easy.exception.aspect.Exiting
#import scold.easy.exception.provides.Exiting
#import std.string
#import std.exception
class scold::easy::exception::Usage : private provides::Exiting, public aspect::Exiting, public std::exception {
  struct ancestors {
    using Exception = std::exception;
    using Aspect = aspect::Exiting;
    using Provides = provides::Exiting;
  };
public:
  inline Usage(Program const &, nonstd::sysexits::Code);
  auto stream() const noexcept -> std::ostream & override;
  auto code() const noexcept -> nonstd::sysexits::Code override;
  auto what() const noexcept -> char const * override;
private:
  static auto format(Program const &) -> std::string;
  inline static auto which_stream(nonstd::sysexits::Code code) -> std::ostream &;
};
#endiv
#divert <ipp>
#import std.cout
#import std.cerr
#import nonstd.sysexits.constants
namespace scold::easy::exception {
  Usage::Usage(Program const &name, nonstd::sysexits::Code code)
    : ancestors::Provides{which_stream(code), code, format(name)}
    , ancestors::Aspect{}
    , ancestors::Exception{}
  { }
  auto Usage::which_stream(nonstd::sysexits::Code code) -> std::ostream & {
    return nonstd::sysexits::OK == code ? std::cout : std::cerr;
  }
}
#endiv
#divert <cpp>
namespace scold::easy::exception {
  auto Usage::stream() const noexcept -> std::ostream & {
    return ancestors::Provides::stream();
  }
  auto Usage::code() const noexcept -> nonstd::sysexits::Code {
    return ancestors::Provides::code();
  }
  auto Usage::what() const noexcept -> char const * {
    return ancestors::Provides::what();
  }
}
#import std.string_literals
#import std.ostringstream
using namespace std::string_literals;
auto scold::easy::exception::Usage::format(Program const &name) -> std::string {
  std::string rename{name.empty() ? "noname"s : static_cast<std::string const &>(name)};
  std::ostringstream buf;
  buf << "usage: " << rename << " [...options...] [...files.xcpp...]\n"
      << "\n"
      << "Flag Options:\n"
      << "[ --verbose ]                 be verbose, this is not the default\n"
      << "[ --warnings ]                have warnings, this is the default\n"
      << "[ --insert-namespace ]        look for & insert the per-directory namespace module, this is the default\n" // matryoshka
      << "The flag options can be inverted with a 'no-' prefix; e.g '--no-warnings'\n"
      << "\n"
      << "Value Options:\n"
      << "[ -I<directory> ]             same as with any C++ compiler\n"
      << "[ --srcdir=<directory> ]      e.g. $(scold_srcdir)\n"
      << "[ --objdir=<directory> ]      e.g. $(scold_cxxdir), probably not $(scold_objdir)\n"
      << "\n"
      << "C++ Files:\n"
      << "files.xcpp                    C++2a source code in the S.C.O.L.D. stylings that are so popular these days\n"
    ;
  return buf.str();
}
#endiv
