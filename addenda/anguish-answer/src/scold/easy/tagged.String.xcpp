// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::tagged {
  //
  // A tagged string is "like a string" but is tagged and thus a different type.
  // It is different by subclassing, not different by having different char traits.
  //
  // The definition is complete enough for a 'using' declaration.
  // i.e. NOT descendants only.
  //      but it is not final; further descendants are possible.
  //
  // Usage:
  //
  //   using Module = tagged::String<MODULE>;
  //   using Line = tagged::String<LINE>;
  //
  template<typename UNIQUENESS> class String;
}
#endiv
#divert <hpp>
#import std.string
#import std.forward
template<typename UNIQUENESS> class scold::easy::tagged::String : public std::string {
  using ancestor = std::string;
public:
  String() = default;
  using ancestor::basic_string;
  // and now the ancestors not otherwise covered by the using
  String(ancestor &&a) : ancestor{std::forward<ancestor>(a)} { }
  String(ancestor const &a) : ancestor{a} { }
  // From here on down these are pesky and boilerplate;
  using ancestor::operator=;
  auto operator=(String const &) -> String & = default; 
  auto operator=(String &&) -> String & = default; 
  String(String &&) = default; // And because we did moving operator= we have to do the moving constructor
  String(String const &) = default; // And because we did moving constructor we have do the copy constructor
};
#endiv
