// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy {
  //
  // A "searchpath" ... a path to search
  //
  // Theory:
  //
  // This is a dubious decision procedure because it guesses whether a module is external or internal
  // For modules where the local project overrides or provides a development copy of an already-installed module
  // the notion of internal vs external is ill-defined.  The module looks like an external module
  // until such time as it is scold-compiled into place, then it looks like an internal module.
  //
  // e.g. if you are building module-something in the devel area /build/scold/module-something
  //      AND there is already an installed copy of module-something in the /opt/scold area.
  // 
  // "external" modules are include files:
  //      that already exist in the external module searchpath
  //         ...etc... -I$(top_srcdir)/modules ...etc...
  //      AND which do not exist in the internal of the project
  //           -I$(top_builddir)/modules -I$(top_builddir)/obj/modules
  //      Properties:
  //      - they MUST exist before the project is built
  //        (nothing in the build is going to create them)
  //      - some location must satisfy these right now
  //        (to state it again)
  //
  // "internal" modules are include files:
  //     that may or may not yet exist
  //     when they exist, they are in the one of three places
  //         1. internal searchpath
  //            -I$(top_builddir)/obj/modules as a module name package.component.Class
  //         2. the internal source area as hand-coded, manually-maintained file
  //             ...src/package/component/Class.xcpp
  //         3. the internal object area as machine generated file
  //            ...obj/src/package/component/Class.xcpp
  //      Properties:
  //      - they MIGHT NOT exist before the project is built
  //      - they MAY exist in the external searchpath
  //        (the local copy will take precedence)
  //
  // Examples:
  //
  //   project ::= { src, obj/src, obj/modules }
  //   internal searchpath ::= { ./obj/modules ./obj/include
  //                             submodules/module-AAAA/obj/modules,
  //                             submodules/module-BBB/obj/modules,
  //                             submodules/module-CC/obj/modules,
  //                             submodules/module-D/obj/modules }
  //   external searchpath := { ./modules ./include 
  //                             /build/nearby/module-ONE/modules,
  //                            /build/nearby/module-TWO/modules,
  //                            /build/nearby/module-THREE/modules,
  //                            ...etc...
  //                            /opt/scold/modules }
  //
  // Queries:
  //   can_exist?       qq(package.component.Class) <-- yes if there are sources
  //   does_exist       qq(package.component.Class) <-- yes only if actually there
  //   mustbe_external? qq(package.component.Class) <-- yes only if in the external searchpath 
  //   is_internal?     qq(package.component.Class) <-- yes, same.
  //
  // Usage:
  //
  //   Searchpath sp{project};
  //   sp.add(Searchpath::External{...});
  //   sp.add(Searchpath::Internal{...});
  //
  //   if (searchpath.mustbe_external(module)) {
  //     ...is an external module...
  //   } else {
  //     ...is a module of this project, not yet synthesized or installed...
  //   }
  //
  class Searchpath;
 }
#endiv
#divert <hpp>
#import scold.easy.name.Filepath
#import scold.easy.name.Module
#import scold.easy.Project
#import std.deque
#import std.pair
#forward scold.easy.searchpath.Iterator
class scold::easy::Searchpath {
public:
  // The project need not be "complete" yet, but the reference is captured
  inline explicit Searchpath(Project const &);
  // the sources exist or it does exist in any spot in the searchpath
  inline auto can_exist(name::Module const &) const -> bool;
  // does exist in any spot in the searchpath
  inline auto does_exist(name::Module const &) const -> bool;
  // does exist in the external spots in the positions; e.g. in siblings, in nearby, in std-scold, in prefix, etc.
  inline auto mustbe_external(name::Module const &) const -> bool;
  // does exist in the internal spots in the positions; i.e. in the submodules.
  inline auto is_internal(name::Module const &) const -> bool;
  enum class Sense { INTERNAL, EXTERNAL };
  template<Sense> struct Constructor;
  using Internal = Constructor<Sense::INTERNAL>;
  using External = Constructor<Sense::EXTERNAL>;
  inline auto push_back(Internal) -> void;
  inline auto push_back(External) -> void;
  inline auto push_front(Internal) -> void;
  inline auto push_front(External) -> void;
protected:
  Project const &project;
  using Position = std::pair<Sense, name::Filepath>;
  using Positions = std::deque<Position>;
  Positions positions;
  using Found = std::pair<Positions::const_iterator, Positions::const_iterator>;
  inline auto find(name::Module const &) const -> Found;
public:
  friend class searchpath::Iterator;
  using iterator = searchpath::Iterator;
  inline auto begin() const -> iterator;
  inline auto end() const -> iterator;
private:
  inline static auto dedot(name::Filepath &subject) -> bool;
};
#import scold.easy.Searchpath.Constructor
#endiv
#divert <ipp>
#import std.move
#import std.find_if
#import sys.posix.isreg
#import sys.posix.exists
#import want.ranges.reverse
#import scold.easy.filesystem.Module
#import scold.easy.searchpath.Iterator
namespace scold::easy {
  Searchpath::Searchpath(Project const &project)
    : project{project} { }
  auto Searchpath::find(name::Module const &candidate) const -> Found {
    auto const match = [&candidate](Position const &position) {
                         return sys::posix::isreg(position.second / candidate);
                       };
    auto const b = positions.begin();
    auto const e = positions.end();
    return Found{std::find_if(b, e, match), e};
  }
  auto Searchpath::can_exist(name::Module const &module) const -> bool {
    for (auto const &area : {project.sources_area, project.local_objects_area}) {
      auto candidate = module.operator name::Filepath();
      do {
        if (sys::posix::exists((area / candidate) += "xcpp")) {
          return true;
        }
      } while (dedot(candidate));
    }
    return false;
  }
  auto Searchpath::does_exist(name::Module const &candidate) const -> bool {
    auto found = find(candidate);
    return found.first != found.second;
  }
  auto Searchpath::mustbe_external(name::Module const &candidate) const -> bool {
    auto const found = find(candidate);
    // If it is not found then it must be external. SOMEONE has to satisfy this need.
    if (found.first == found.second) { return true; }
    else if (Sense::INTERNAL == found.first->first) { return false; }
    else { return true; }
  }
  auto Searchpath::is_internal(name::Module const &candidate) const -> bool {
    auto const found = find(candidate); // [[FIXTHIS]] only search the INTERNAL elements
    if (found.first == found.second) { return false; }
    else if (Sense::INTERNAL == found.first->first) { return true; }
    else { return false; }
  }
  auto Searchpath::push_back(Internal pos) -> void {
    positions.push_back(std::move(pos));
  }
  auto Searchpath::push_back(External pos) -> void {
    positions.push_back(std::move(pos));
  }
  auto Searchpath::push_front(Internal pos) -> void {
    positions.push_front(std::move(pos));
  }
  auto Searchpath::push_front(External pos) -> void {
    positions.push_front(std::move(pos));
  }
  auto Searchpath::begin() const -> iterator {
    return iterator{positions.begin()};
  }
  auto Searchpath::end() const -> iterator {
    return iterator{positions.end()};
  }
  auto Searchpath::dedot(name::Filepath &subject) -> bool {
    auto work = std::string{subject};
    for (auto &c : want::ranges::reverse(work)) {
      if ('.' == c) {
        c = '/';
        subject = work;
        return true;
      }
    }
    return false;
  }
} 
#endiv
