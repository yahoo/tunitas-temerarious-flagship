// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::multipath::pruning {
  //
  // A doppelganged iterator walker
  //
  // Usage:
  //   Walker i{subject.begin(), pattern.begin()};
  //   Walker const e{subject.end(), pattern.end()};
  //   for ( ; !done(i, e); ++i) {
  //     continue;
  //   }
  //
  class Walker;
}
#endiv
#divert <hpp>
namespace scold::easy::multipath::pruning {
  // Either iterator is exhausted
  inline auto done(Walker const &, Walker const &) -> bool;
  // Both are the same
  inline auto operator==(Walker const &, Walker const &) -> bool;
  inline auto operator!=(Walker const &, Walker const &) -> bool;
}
#import std.filesystem.path
#import std.pair
class scold::easy::multipath::pruning::Walker : public std::pair<std::filesystem::path::iterator, std::filesystem::path::const_iterator> {
  using ancestor = std::pair<std::filesystem::path::iterator, std::filesystem::path::const_iterator>;
public:
  struct iterators {
    using First = ancestor::first_type;
    using Second = ancestor::second_type;
  };
  Walker() = default;
  inline Walker(iterators::First, iterators::Second);
  inline auto operator++() -> Walker &;
  inline auto operator++(int) -> Walker;
};
#endiv
#divert <ipp>
namespace scold::easy::multipath {
  auto pruning::done(Walker const &a, Walker const &b) -> bool {
    return a.first == b.first || a.second == b.second;
  }
  auto pruning::operator==(Walker const &a, Walker const &b) -> bool {
    return a.first == b.first && a.second == b.second;
  }
  auto pruning::operator!=(Walker const &a, Walker const &b) -> bool {
    return !operator==(a, b);
  }
}
namespace scold::easy::multipath::pruning {
  Walker::Walker(iterators::First f, iterators::Second s)
    : ancestor{f, s}
  { }
  auto Walker::operator++() -> Walker & {
    ++first;
    ++second;
    return *this;
  }
  auto Walker::operator++(int) -> Walker {
    Walker old{*this};
    operator++();
    return old;
  }
}
#endiv
