// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::suffix {
  //
  // The suffixes, their ordering and their properties as distinct from the Step
  // which incorporates the processor's before-during-and after sense of suffix processing.
  //
  // Independent of all of this is whether the processor is *inside* or *outside* a #divert/#endiv pair
  //
  enum class Suffix
    { FPP,
      HPP,
      IPP,
      TPP,
      CPP }; // actually, a "mode" (a Step), not a suffix.  [[FIXTHIS]] is this still true: the comment
}
#endiv
#divert <hpp>
#import std.basic_ostream
#import std.string
#import scold.easy.required
#import nonstd.required.Character
#import nonstd.required.Character_Traits
#import scold.easy.List
namespace scold::easy::suffix {
  template<required::Character CHAR, required::Character_Traits TRAITS> inline auto operator<<(std::basic_ostream<CHAR, TRAITS> &, Suffix) -> std::basic_ostream<CHAR, TRAITS> &;
  inline auto to_string(Suffix) -> std::string;
  inline auto from_string(std::string const &s) -> Suffix;
  auto pretty_legal_names() -> List<std::string>;
}
namespace std {
  using scold::easy::suffix::to_string;
}
#import scold.easy.List
#import std.string
namespace scold::easy::suffix {
  inline auto operator<(Suffix, Suffix) -> bool;
  inline auto operator<=(Suffix, Suffix) -> bool;
  inline auto operator>(Suffix, Suffix) -> bool;
  inline auto operator>=(Suffix, Suffix) -> bool;
  inline auto succ(Suffix) -> Suffix;        // throws std::invalid_argument
  inline auto pred(Suffix) -> Suffix;        // same
  //
  // What is includable for this suffix?
  // i.e. cpp -> tpp
  //      other is the identity
  //
  inline auto includable(Suffix) -> Suffix;
  [[deprecated("but every Suffix is a mode, by definition")]] inline auto is_legal(Suffix) -> bool;
  inline auto is_legal(std::string const &) -> bool;
  //
  // The name concatenation operators are located in
  //   #import scold.easy.filesystem.Suffix
  //
}
#import scold.easy.suffix.Suffix.less
#endiv
#divert <ipp>
#import scold.easy.suffix.tables
namespace scold::easy {
  template<required::Character CHAR, required::Character_Traits TRAITS> auto suffix::operator<<(std::basic_ostream<CHAR, TRAITS> &o, Suffix s) -> std::basic_ostream<CHAR, TRAITS> & {
    return o << tables::SUFFIX.at(s);
  }
  auto suffix::to_string(Suffix s) -> std::string {
    // Throws on no such
    return tables::SUFFIX.at(s);
  }
  auto suffix::from_string(std::string const &s) -> Suffix {
    // Throws on no such
    return tables::UNSUFFIX.at(s);
  }
}
namespace scold::easy {
  auto suffix::operator<(Suffix a, Suffix b) -> bool {
    std::less<Suffix> lt;
    return lt(a, b);
  }
  auto suffix::operator<=(Suffix a, Suffix b) -> bool { return operator<(a, b) || a == b; }
  auto suffix::operator>(Suffix a, Suffix b) -> bool { return operator<(b, a); }
  auto suffix::operator>=(Suffix a, Suffix b) -> bool { return operator<=(b, a); }
}
#import std.bad_optional_access
#import std.invalid_argument
namespace scold::easy {
  auto suffix::pred(Suffix a) -> Suffix {
    try {
      //      /------throws on not-a-Suffix
      //      |
      //      v
      return (Suffix) *tables::NEIGHBORS.at(a).pred;
    } catch (std::bad_optional_access const &) {
      // Because using std::optional is an implementation detail here
      // we rethrow something meaningful that declares what is really wrong (the argument is invalid)
      throw std::invalid_argument{"pred"};
    }
  }
  auto suffix::succ(Suffix a) -> Suffix {
    try {
      //      /------throws on not-a-Suffix
      //      |
      //      v
      return (Suffix) *tables::NEIGHBORS.at(a).succ;
    } catch (std::bad_optional_access const &) {
      // ibidem.
      throw std::invalid_argument{"succ"};
    }
  }
  auto suffix::includable(Suffix candidate) -> Suffix {
    if (candidate < Suffix::FPP || Suffix::CPP < candidate) {
      throw std::invalid_argument{"includable"};
    }
    return Suffix::CPP == candidate ? Suffix::TPP : candidate;
  }
  auto suffix::is_legal(Suffix mode) -> bool {
    return tables::SUFFIX.contains(mode);
  }
  auto suffix::is_legal(std::string const &candidate) -> bool {
    return tables::UNSUFFIX.contains(candidate);
  }
}
#import want.ranges.detail.Direct.Iterator
namespace want::ranges::detail {
  template<> inline auto Direct<scold::easy::suffix::Suffix>::Iterator::incrementationalize(Value v) -> Value {
    return succ(v);
  }
}
#endiv
#divert <cpp>
#import scold.easy.List
using namespace scold::easy;
namespace scold::easy {
  auto suffix::pretty_legal_names() -> List<std::string> {
    // [[FIXTHIS]] why this not tables.SUFFIX[suffix] (the 2nd is the name)
    std::string (*to)(Step const &) = to_string;
    return map<std::string>(keys(tables::MODE), to);
  }
}
#endiv
