// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import lite.regex
namespace scold::easy::core {
  namespace regex = lite::regex;
}
#endiv
#divert <hpp>
#import lite.regex.Pattern
namespace scold::easy::core {
  extern regex::Pattern const FILE_XCPP;
  inline constexpr auto CPP_LINES = true;
  inline constexpr auto ALWAYS_EMIT_LINES = true;
}
#endiv
#divert <cpp>
// WATCHOUT - these should not be at global scope.  they throw upon invalid regex syntax
// WATCHOUT - used with regex::match(...), so it has to match the *whole* filename, not regex::search(...)
#warning WATCHOUT - these should not be at global scope.  they throw upon invalid regex syntax
scold::easy::core::regex::Pattern const scold::easy::core::FILE_XCPP{".*\\.xcpp$"};
# warning WRITETHIS
#if 0
auto scold::easy::process(name::Filepath const &file_xcpp) -> void {
# Match for headers of the form      "header"   as these *might* be treatable
# Ignore system headers of the form  <header>   as these are definitely system headers
#
# the SCOLD version of #include is #import
our $DIRECTIVE_PATTERN = qr!^\s*#\s*(import|forward|entail)\s+(\S+)(.*)!;
our $DIRECTIVE_PREFIX_PATTERN = qr!^\s*#\s*(import|forward|entail)(\s+.*)?!;

our $TAG_STARTEND = qr!^\s*(?:#\s*divert\s*)?<(\w+)(/)?>!;
our $TAG_END_PP = qr!^\s*(?:#\s*divert\s*)?<(/(\w+))>!;
our $TAG_END_DIV = qr!^\s*(?:#\s*endiv\b)!;

use constant CPP_LINES => 1;
use constant ALWAYS_EMIT_LINES => 1;
#endif
#endiv
