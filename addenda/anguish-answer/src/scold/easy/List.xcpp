// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy {
  //
  // A (generic) perlish List
  //
  // Properties: ordered, not unique.
  // maybe implemented as: a forward_list, a (bidirectional) list, a vector, a deque; NOT a set.
  //
  // Usage:
  //
  //   auto c = List<std::string>{};
  //   auto c = List<std::string>{"apple", "banana", "cherry"};
  //   auto c = List<std::string>{first, last};
  //   auto b = c.empty();
  //   auto s = c.size();
  //   for (auto const &item: c) {
  //     ...use the item...
  //   }
  //
  template<typename TYPE> class List;
}
#endiv
#divert <hpp>
#import std.optional
#import scold.easy.required.map.Key
#import scold.easy.required.map.Mapped
#import scold.easy.required.function.Result
#forward scold.easy.Map
namespace scold::easy {
  template<typename TYPE> auto defined(List<std::optional<TYPE>> &&) -> List<TYPE>; //      moves
  template<typename TYPE> auto defined(List<std::optional<TYPE>> const &) -> List<TYPE>; // copies
  template<typename RESULT, typename TYPE, required::function::Result<RESULT, TYPE const &> FUNCTION> auto map(List<TYPE> const &, FUNCTION) -> List<RESULT>;
}
#import std.deque
#import lite.regex.Pattern
#import scold.easy.back_inserter
#import scold.easy.required.iterator.Forward
#import scold.easy.required.iterator.Producing
template<typename TYPE> class scold::easy::List : protected std::deque<TYPE> {
  using ancestor = std::deque<TYPE>;
public:
  // old_school
  using ancestor::value_type;
  using ancestor::iterator;
  using ancestor::const_iterator;
  // New_School
  using Value = typename ancestor::value_type;
  using Initializer = Value; // same here (not same in Map)
  using Iterator = typename ancestor::iterator;
  using Const_Iterator = typename ancestor::const_iterator;
  List() = default;
  template<required::iterator::Forward ITERATOR> inline List(ITERATOR, ITERATOR) requires required::iterator::Producing<ITERATOR, Value>;
  inline explicit List(std::initializer_list<Initializer>);
  using ancestor::empty;
  using ancestor::size;
  using ancestor::begin;
  using ancestor::end;
  using ancestor::push_back;
  using ancestor::clear;
  friend auto easy::back_inserter<>(List &) -> std::back_insert_iterator<List>;
  inline auto contains(Value const &) const -> bool;
  using Pattern = lite::regex::Pattern;
  inline auto contains(Pattern const &) const -> bool;
};
#endiv
#divert <ipp>
#import std.find
#import std.find_if
namespace scold::easy {
  template<typename _> template<required::iterator::Forward ITERATOR> List<_>::List(ITERATOR first, ITERATOR last) requires required::iterator::Producing<ITERATOR, Value>
    : ancestor{first, last}
  { }
  template<typename _> List<_>::List(std::initializer_list<Initializer> il)
    : ancestor{il}
  { }
  template<typename _> auto List<_>::contains(Value const &exact) const -> bool {
    return end() != std::find(begin(), end(), exact);
  }
  template<typename _>  auto List<_>::contains(Pattern const &pattern) const -> bool {
    return end() != std::find_if(begin(), end(), [&pattern](Value const &item) {
                                                   return match(item, pattern);
                                                 });
  }
}
#import std.move
#import std.transform
#import scold.easy.Map
namespace scold {
  template<typename RESULT, typename TYPE, easy::required::function::Result<RESULT, TYPE const &> FUNCTION> auto easy::map(List<TYPE> const &l, FUNCTION f) -> List<RESULT> {
    List<RESULT> r;    
    std::transform(l.begin(), l.end(), back_inserter(r), f);
    return r;
  }
  template<typename TYPE> auto easy::defined(List<std::optional<TYPE>> &&original) -> List<TYPE> {
    List<TYPE> ret;
    for (auto &item : original) {
      if (item) { ret.push_back(std::move(*item)); }
    }
    return std::move(ret);
  }
  template<typename TYPE> auto easy::defined(List<std::optional<TYPE>> const &original) -> List<TYPE> {
    List<TYPE> ret;
    for (auto item : original) {
      if (item) { ret.push_back(*item); }
    }
    return ret;
  }
}
#endiv
