// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import scold.easy.required.map.Key
#import scold.easy.required.map.Mapped
namespace scold::easy {
  //
  // A generic (perlish) Map
  //
  // Very limited functionality: initialization, (expected-success) lookup.
  //
  // Usage:
  //
  //   auto c = Map<std::string, std::string>{};
  //   auto c = Map<std::string, std::string>{{"apple","banana"},{"cherry","dog"},{"eagle","frog"}}};
  //   auto c = Map<std::string, std::string>{first, last};
  //   auto b = c.empty();
  //   auto s = c.size();
  //   for (auto const &mapped : c) {
  //      ...use the pair...
  //   }
  //
  template<required::map::Key KEY, required::map::Mapped MAPPED> class Map;
}
#endiv
#divert <hpp>
#import scold.easy.List
namespace scold::easy {
  template<required::map::Key KEY, required::map::Mapped MAPPED> auto keys(Map<KEY, MAPPED> const &) -> List<KEY>;
  template<required::map::Key KEY, required::map::Mapped MAPPED> auto mapped(Map<KEY, MAPPED> const &) -> List<MAPPED>;
}
#import std.map
#import std.initializer_list
#import scold.easy.required.iterator.Forward
#import scold.easy.required.iterator.Producing
#import scold.easy.back_inserter
namespace scold {
  template<easy::required::map::Key KEY, easy::required::map::Mapped MAPPED> class easy::Map : protected std::map<KEY, MAPPED> {
    using ancestor = std::map<KEY, MAPPED>;
  public:
    // old_school
    using typename ancestor::key_type;
    using typename ancestor::mapped_type;
    using typename ancestor::value_type;
    using typename ancestor::iterator;
    using typename ancestor::const_iterator;
    // New School
    using Key = key_type;
    using Mapped = mapped_type;
    using Value = value_type;
    using Initializer = Value;
    using Iterator = iterator;
    using Const_Iterator = const_iterator;
    Map() = default;
    inline explicit Map(std::initializer_list<Initializer>);
    template<required::iterator::Forward ITERATOR> inline Map(ITERATOR start, ITERATOR finish) requires required::iterator::Producing<ITERATOR, Initializer>;
    using ancestor::begin;
    using ancestor::end;
    using ancestor::clear;
    using ancestor::operator[]; // this is the nonconst one that creates an empty element if the key is not found
    using ancestor::at; //         this is the consty one that throws if the key is not found
    inline auto push_back(Value) -> void;
    friend auto easy::back_inserter<>(Map &) -> std::back_insert_iterator<Map>;
    // Why isn't this *already* in the standard?
    inline auto contains(Key const &) const -> bool;
  };
}
#endiv
#divert <ipp>
#import std.move
namespace scold::easy {
  template<required::map::Key K, required::map::Mapped M> Map<K,M>::Map(std::initializer_list<Initializer> il)
    : ancestor{il}
  { }
  template<required::map::Key K, required::map::Mapped M> template<required::iterator::Forward ITERATOR> Map<K,M>::Map(ITERATOR start, ITERATOR finish) requires required::iterator::Producing<ITERATOR, Initializer>
    : ancestor{start, finish}
  { }
  template<required::map::Key K, required::map::Mapped M> auto Map<K,M>::contains(Key const &pattern) const -> bool {
    return ancestor::end() != ancestor::find(pattern);
  }
  template<required::map::Key K, required::map::Mapped M> auto Map<K,M>::push_back(Value value) -> void {
    ancestor::insert(std::move(value));
  }
}
#import std.move
#import std.transform
#import scold.easy.back_inserter
namespace scold {
  template<easy::required::map::Key KEY, easy::required::map::Mapped MAPPED> auto easy::keys(Map<KEY, MAPPED> const &m) -> List<KEY> {
    List<KEY> r;    
    for (auto const &p : m) {
      r.push_back(p.first);
    }
    return r;
  }
  template<easy::required::map::Key KEY, easy::required::map::Mapped MAPPED> auto easy::mapped(Map<KEY, MAPPED> const &m) -> List<MAPPED> {
    List<MAPPED> r;    
    for (auto const &p : m) {
      r.push_back(p.second);
    }
    return r;
  }
}
#endiv
