// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
#import std.string_literals
namespace scold::easy::core::packaging {
  namespace [[implementation]] process_function {
    namespace [[implementation]] implementation {
      namespace [[interface]] interface { }
      using namespace std::string_literals;
    }
  }
}
#endiv
#divert <hpp>
#import scold.easy.Configuration
#import scold.easy.file.Inbound
#import scold.easy.file.Outbound
#import scold.easy.multipath.Filepath
#import scold.easy.name.Filepath
#import std.string
#import format.braket
#import format.commalist
#import format.parenthesis
namespace scold::easy::core {
  namespace packaging::process_function {
    namespace implementation {
      namespace interface {
        //
        // The S.C.O.L.D. disaggregation algorithm itself.
        //
        // Throws Failing{} if it cannot perform the processing.
        //
        // Usage:
        //
        //   auto cfg = Configuration{...somehow...};
        //   for (auto const &filepath : ...somehow...) {
        //     process(cfg, filepath);
        //   }
        //
        auto process(Configuration const &, name::Filepath const &file_xcpp) -> void;
      }
      using ::format::braket;
      using ::format::commalist;
      using ::format::parenthesis;
      auto main_loop(Configuration const &, name::Filepath const &file_xcpp, file::Inbound &, multipath::Filepath const &, file::Outbound &) -> void;
      inline auto replace_coloncolon_with_dot([[inout]] std::string &module) -> void;
    }
  }
  using packaging::process_function::implementation::interface::process;
}
#endiv
#divert <ipp>
namespace scold::easy::core::packaging::process_function {
  auto implementation::replace_coloncolon_with_dot(std::string &module) -> void {
    auto const np = std::string::npos;
    auto const colon_colon = std::string{"::"};
    auto const get = [&module, colon_colon]() {
                       return module.find(colon_colon);
                     };
    for (auto cc=get(); np != cc; cc=get()) {
      module.replace(cc, colon_colon.size(), ".");
    }
  }
}
#endiv
#divert <cpp>
#import lite.regex.match
#import scold.easy.cascade.Context
#import scold.easy.core.Match
#import scold.easy.core.State
#import scold.easy.defaults
#import scold.easy.diagnostic
#import scold.easy.exception.Failing
#import scold.easy.file.Inbound
#import scold.easy.file.Outbound
#import scold.easy.generate
#import scold.easy.line.get
#import scold.easy.line.Number
#import scold.easy.line.Object
#import scold.easy.multipath.burst
#import scold.easy.suffix.Limits
#import scold.easy.suffix.Step // pretty_legal_names(...)
#import scold.easy.suffix.Suffix // from_string
#import std.empty
#import std.runtime_error
#import want.ranges.minmax
namespace scold::easy::core::packaging::process_function {
  auto implementation::main_loop(Configuration const &cfg, name::Filepath const &file_xcpp, file::Inbound &in, multipath::Filepath const &outnames, file::Outbound &out) -> void {
    // omitted: prepass through the file to look for common errors
    auto this_step_start = line::Number{1};
    auto lineno = line::Number{0};
    auto step = suffix::Step::BEGIN;
    auto state = State::OUTSIDE;
    auto max_step_yet_seen = step;
    auto lastnext_cpp_location_directive = std::string{};
    cascade::Context ctx;
    { auto wow = cfg.insert_namespace_mode.value_or(defaults::AUTOMATIC_INSERT_NAMESPACE);
      ctx.announce(outnames.module, wow); }
    for (line::Object lobj{file_xcpp}; line::get(in, lobj); ) {
      debug(cfg) << lobj.location() << ':' << lobj << end(cfg);
      if (Match<not_preprocessor_but_ending_in_C_style_comment_start> dang; dang(lobj)) {
        Match<is_preprocessor_or_ending_the_C_style_comment> gle; // dang...gle (get it?)
        // eat to the line containing the end of the comment
        for (line::Object more{file_xcpp}; line::get(in, more) && more != gle; ) {
          lobj += more;
        }
      }
      auto const [this_cpp_location_directive, next_cpp_location_directive] = [&lobj, &outnames]() -> std::tuple<std::string, std::string> {
        auto bounds = lobj.lines();
        return {generate::line(outnames.original, bounds.first), generate::line(outnames.original, 1+bounds.second)};
      }();
      auto standard_step_vetting = [&cfg, &file_xcpp, lineno, &state, max_step_yet_seen](std::string const &new_step_syntax) -> suffix::Step {
                                     if (std::empty(new_step_syntax)) { throw std::runtime_error{"empty step"}; }
                                     if (State::INSIDE == state) {
                                       (diagnostic::line(file_xcpp, lineno) << braket(new_step_syntax) << " occurs within another #divert" << end(cfg));
                                     }
                                     if (!suffix::is_legal(new_step_syntax)) {
                                       (diagnostic::line(file_xcpp, lineno) << braket(new_step_syntax) << " is invalid, it must be one of " <<  parenthesis(commalist(suffix::pretty_legal_names())) << end(cfg));
                                     }
                                     suffix::Step new_step = suffix::from_string(new_step_syntax);
                                     if (new_step <= max_step_yet_seen) {
                                       diagnostic::line(file_xcpp, lineno) << braket(new_step) << " may not appear after " << braket(max_step_yet_seen) << end(cfg);
                                     }
                                     return new_step;
                                   };
      if (false) {
      } else if (Match<tag_end_pp> tep; tep << lobj) {
        //
        //   #divert </fpp> <-------------- the and-end
        //
        auto [endstep_tag_syntax, endstep_name_syntax] = tep.result();
        auto endstep = standard_step_vetting(endstep_tag_syntax);
        if (State::INSIDE != state) {
          (diagnostic::line(file_xcpp, lineno) << braket(endstep_tag_syntax) << " does NOT occur within a #divert" << end(cfg));
        }
        if (endstep != step) {
          (diagnostic::line(file_xcpp, lineno) << "ending " << braket(endstep) << " does not match the starting " << braket(step) << " which started at " << this_step_start << end(cfg));
        }
        ctx.emit_accrued_entails(step, out[step]);
        state = State::OUTSIDE;;
#if 0
        my ($endstep_tag, $endstep_name) = ($1, $2);
        die unless defined $endstep_tag && defined $endstep_name;
        error::line($file_xcpp, $lineno, qq(ending <${endstep_tag}> does not match starting <$step>, which started at $step_start_line))
          if $endstep_name ne $step;
        error::line($file_xcpp, $lineno, qq(</end> may not appear, use <end/> instead))
          if q(end) eq $endstep_name;
        // and we're done
        my $fd = $variant_fds{$step};
        cascade::emit_accrued_entails($step, $fd);
        $step = q(all);
#endif
      } else if (Match<tag_end_div> ted; ted << lobj) {
        //
        //   #endiv
        //
        if (State::OUTSIDE == state) {
          (diagnostic::line(file_xcpp, lineno) << "an #endiv appears without an enclosing #divert (ignoring it)" << end(cfg));
        } else {
          state = State::OUTSIDE;
        }
        ctx.emit_accrued_entails(step, out[step]);
#if 0
        // expected end tag
        error::line($file_xcpp, $lineno, qq(#endiv may not appear without a #divert))
          if q(all) eq $step;
        // and we're done with $step
        my $fd = $variant_fds{$step};
        cascade::emit_accrued_entails($step, $fd);
        $step = q(ll);
#endif
      } else if (Match<tag_start_and_end> tsae; tsae << lobj) {
        //
        // Examples:
        //
        //   #divert <fpp/> <-------------- the begin-and-end
        //
        auto [new_step_syntax, autoend_syntax] = tsae.result();
        auto new_step = standard_step_vetting(new_step_syntax);
        bool autoend = !autoend_syntax.empty();
#if 0
        error::line($file_xcpp, $lineno, qq(<end> may not appear, only <end/>))
          if q(end) eq $new_step && ! $autoend;
#endif
        for (auto step=max(suffix::Step::FPP, max_step_yet_seen); step != new_step; step=succ(step)) {
          ctx.emit_accrued_imports(step, out[step]);
          if (CPP_LINES && (ALWAYS_EMIT_LINES || lastnext_cpp_location_directive != this_cpp_location_directive)) {
            out[step] << this_cpp_location_directive;
          }
          ctx.emit_accrued_entails(step, out[step]);
        }
        step = new_step;
        this_step_start = lineno;
        if (suffix::Step::END != step) {
          ctx.emit_accrued_imports(step, out[step]);
          if (CPP_LINES && (ALWAYS_EMIT_LINES || lastnext_cpp_location_directive != this_cpp_location_directive)) {
            out[step] << this_cpp_location_directive;
          }
        }
        max_step_yet_seen = step;
        if (autoend) {
          ctx.emit_accrued_entails(step, out[step]);
          state = State::OUTSIDE;
        }
#if 0
        for (my $m=suffixes::succ($max_step_yet_seen); $m ne $new_step; $m=suffixes::succ($m)) {
          print STDERR qq(debug: for catchup step $m before $new_step\n) if $main::debug_step > 3;
          my $fd = $variant_fds{$m};
          cascade::emit_accrued_imports($m, $fd);
          // back on track
          if (CPP_LINES && (ALWAYS_EMIT_LINES || $lastnext_cpp_location_directive ne $this_cpp_location_directive)) {
            $fd->print($this_cpp_location_directive) or die;
          }
          // and we're done with $step
          cascade::emit_accrued_entails($step, $fd);
        }
        $step = $new_step;
        $step_start_line = $lineno;
        if (q(end) eq $step) {
          $endlines ||= 1;
        } else {
          my $fd = $variant_fds{$step};
          cascade::emit_accrued_imports($step, $fd);
          if (CPP_LINES && (ALWAYS_EMIT_LINES || $lastnext_cpp_location_directive ne $this_cpp_location_directive)) {
            $fd->print($this_cpp_location_directive) or die;
          }
        }
        $max_step_yet_seen = $step;
        if ($autoend) {
          // # and we're done with $step
          my $fd = $variant_fds{$step};
          cascade::emit_accrued_entails($step, $fd);
          $step = q(all);
        }
#endif
      } else if (Match<expected_begin_tag> ebt; ebt << lobj) {
        //
        //   #divert <fpp> <-------------- which is expected 
        //   #divert <hpp>
        //   #divert <ipp>
        //   #divert <tpp>
        //   #divert <cpp>
        //
        auto [start_tag_syntax] = ebt.result();
        auto start = standard_step_vetting(start_tag_syntax);
        if (State::INSIDE == state) {
          (diagnostic::line(file_xcpp, lineno) << " already inside #divert (continuing anyway)" << end(cfg));
        } else {
          state = State::INSIDE;
        }
        step = start;
        this_step_start = lineno;
        if (suffix::Step::END != step) {
          ctx.emit_accrued_imports(step, out[step]);
          if (CPP_LINES && (ALWAYS_EMIT_LINES || lastnext_cpp_location_directive != this_cpp_location_directive)) {
            out[step] << this_cpp_location_directive;
          }
        }
        max_step_yet_seen = step;
      } else if (Match<empty_divert_fragment> edf; edf(lobj)) {
        //
        // #divert
        // 
        // empty divert fragment $line =~ m|^\s*#\s*divert\b.*|)
        //
        (diagnostic::line(file_xcpp, lineno) << "invalid #divert syntax (is ignored) " << lobj << end(cfg));
#if 0
        chomp $line;
        error::line($file_xcpp, $lineno, qq(invalid #divert syntax '$line'));
#endif
        //
        // From here on down we expect that State::INSIDE holds
        //
      } else if (State::OUTSIDE == state) {
        (diagnostic::line(file_xcpp, lineno) << "orphaned line outside of #divert...#endiv (is ignored) " << lobj << end(cfg));
      } else if (Match<DIRECTIVE_PATTERN> dp; dp << lobj) {
        //
        // #forward <...>
        // #entail <...>
        // #entail <...>
        //
        auto [keyword, module_syntax, rest] = dp.result();
        // Allow the C++ separator character (:) or token (::) in lieu of the module path separator character (.)
        // but we're not being so sloppy as to allow a filesystem separator '/' as a "module path separator character"
        replace_coloncolon_with_dot(module_syntax);
        if (Match<MODULE_PATTERN> mp; !mp(module_syntax)) {
          (diagnostic::line(file_xcpp, lineno) << "invalid module name in " << keyword << ", continuing anyway" << end(cfg));
        }
        // is_external_module(module)
        name::Module module{module_syntax};
        if (cfg.searchpath.mustbe_external(module)) {
          if ("forward"s == keyword) {
            (diagnostic::line(file_xcpp, lineno) << "warning: #forward behaves the same as #import for external module " << braket(module) << end(cfg));
          }
          // external modules are files that already exist in the external module searchpath -I$(top_srcdir)/modules or -Edirectory
          out[step] << "#include " << braket(module) << " /* DEBUGGING (external [library] module) module=" << module << ", phase=" << step << " at " << "[[FIXTHIS]] estimate" << " */ " << rest << '\n';
        } else {
          // internal modules may or may not yet exist; are in the internal searchpath -I$(top_builddir)/obj/modules
          if ("entail"s == keyword) {
            ctx.accrete_consequent_entail(step, module);
          } else if ("import"s == keyword) {
            ctx.accrete_consequent_import(step, module);
          } else {
            // 'forward'
            // do not accrete consequences
          }
          auto phase = "forward"s == keyword ? suffix::Step::FPP : ( suffix::Step::CPP == step ? suffix::Step::TPP : step );
          auto header = phase / module; // qq($phase/$module);
          out[step] << "#include " << braket(phase / module) << " /* DEBUGGING (project) " << keyword << " module=" << module << ", phase=" << step << " */ " << rest << '\n';
        }
#if 0
        // the step processing
        error::line($file_xcpp, $lineno, qq(internal error: invalid step '$step', this should never happen))
          unless suffixes::is_legal($step);
        if (q(all) eq $step) {
          if (CPP_LINES && (ALWAYS_EMIT_LINES || $lastnext_cpp_location_directive ne $this_cpp_location_directive)) {
            cascade::push_general_text($this_cpp_location_directive);
          }
          cascade::push_general_text($line);
        } else if ($step =~ m/.pp$/) {
          if ($line =~ m/$DIRECTIVE_PATTERN/) {
            my ($keyword, $module, $rest) = ($1, $2, $3);
            $rest ||= q();
            // Allow the C++ separator character in lieu of the "module path separator character"
            // but we're not being so sloppy as to allow a filesystem separator '/' as a "module path separator character"
            $module =~ s/::/./g;
            error::line($file_xcpp, $lineno, qq(invalid module name in #$keyword at '$line'))
              unless $module =~ m/^([a-zA-Z_][a-zA-Z_0-9]*)(\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
            if (my $estimate = is_external_module($module)) {
              print STDERR qq($file_xcpp:$lineno: warning: #forward behaves the same as #import for external module <$module>\n)
                if q(forward) eq $keyword;
              // external modules are files that already exist in the external module searchpath -I$(top_srcdir)/modules
              $line = qq(#include <$module> /* (external [library] module) module=$module, phase=$step at $estimate */ $rest\n);
            } else {
              // internal modules may or may not yet exist; are in the internal searchpath -I$(top_builddir)/obj/modules
              if (q(entail) eq $keyword) {
                cascade::accrete_consequent_entails($step, $module);
              } else if (q(import) eq $keyword) {
                cascade::accrete_consequent_imports($step, $module);
              } else {
                # 'forward'
                  // do not accrete consequences
                  }
              my $phase = q(forward) eq $keyword ? q(fpp) : ( q(cpp) eq $step ? q(tpp) : $step );
              my $header = qq($phase/$module);
              $line = qq(#include "$header" /* (project) $keyword module=$module, phase=$step */ $rest\n);
            }
          } else if ($line =~ m/$DIRECTIVE_PREFIX_PATTERN/) {
            my ($keyword, $rest) = ($1, $2);
            $rest ||= q();
            error::line($file_xcpp, $lineno, qq(invalid #$keyword syntax '$line'));
          }
          my $fd = $variant_fds{$step};
          if (CPP_LINES && (ALWAYS_EMIT_LINES || $lastnext_cpp_location_directive ne $this_cpp_location_directive)) {
            unless ($last_was_continuation) {
              // If the line ends in a backslash then it's a cpp continuation line.
              // don't push extra junk inside the continuation.  Wait.
              $fd->print($this_cpp_location_directive) or die;
            }
          }
          $fd->print($line) or die;
        } else {
          die {
            message => qq(no such step '$step'),
              step => $step
              };
        }
#endif
      } else {
        //
        // We are INSIDE a #divrt...#endiv
        // This is a regular line, ot a preprocessor line at all
        //
        out[step] << lobj << '\n';
      }
      // recall: $line has a \n at the end of it, so we are looking for  a \\\n
      // $last_was_continuation = $line =~ m!\\\s*$!;
      // $lastnext_cpp_location_directive = $next_cpp_location_directive;
    }
    // error::line($file_xcpp, $lineno, qq(file ended in step '$step', because '#endiv' was not missing))
    // unless q(all) eq $step; 
  }
  namespace implementation {
    auto interface::process(Configuration const &cfg, name::Filepath const &file_xcpp) -> void try {
      auto expensive_FIXTHIS_expensive = (std::string) file_xcpp;
      if (!regex::match(expensive_FIXTHIS_expensive, FILE_XCPP)) {
        (notice(cfg) << "SCOLD source files must end in '.xcpp'" << end(cfg));
        (error(cfg) << "the file " << file_xcpp << " is not a SCOLD source file" << end(cfg));
        throw exception::Failing{cfg.NAME};
      }
      (debug(cfg) << "opening (for read) " << file_xcpp << end(cfg));
      file::Inbound inbound;
      file::Outbound outbound;
      auto outnames = multipath::burst(cfg, file_xcpp);
      {
        auto opened = inbound.open(file_xcpp);
        if (!ok(opened)) {
          (error(cfg) << "could not read " << file_xcpp << " because " << error_code(opened).message() << end(cfg));
          throw exception::Failing{cfg.NAME};
        }
      } {
        (debug(cfg) << "opening (for write) based upon " << file_xcpp << end(cfg));
        (debug(cfg) << "opening (for write) file " << outnames[suffix::Suffix::FPP] << end(cfg));
        (debug(cfg) << "opening (for write) file " << outnames[suffix::Suffix::HPP] << end(cfg));
        (debug(cfg) << "opening (for write) file " << outnames[suffix::Suffix::IPP] << end(cfg));
        (debug(cfg) << "opening (for write) file " << outnames[suffix::Suffix::TPP] << end(cfg));
        (debug(cfg) << "opening (for write) file " << outnames[suffix::Suffix::CPP] << end(cfg));
        auto opened = outbound.open(outnames);
        if (ok(opened)) {
          (debug(cfg) << "opening " << file_xcpp << end(cfg));
        } else {
          (error(cfg) << "could not write the modules of " << file_xcpp << " because " << error_code(opened).message() << end(cfg));
          using Limits = suffix::Limits<suffix::Suffix>;
          for (auto fix : want::ranges::minmax(Limits::min(), Limits::max())) {
            if (ok(opened[fix])) {
              (notice(cfg) << "success opening " << outnames[fix] << " for write" << end(cfg));
            } else {
              (error(cfg) << "could not write " << outnames[fix] << " because " << error_code(opened[fix]).message() << end(cfg));
            }
          }
          throw exception::Failing{cfg.NAME};
        }
      }
      main_loop(cfg, file_xcpp, inbound, outnames, outbound);
    } catch (exception::Failing const &) {
      throw;
    } catch (std::exception const &e) {
      (error(cfg) << "unexpected exception saying " << e.what() << end(cfg));
      throw exception::Failing{cfg.NAME};
    }
  }
}
#endiv
