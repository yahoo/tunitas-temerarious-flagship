// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace scold::easy::exception {
  //
  // Version number as an exception object.
  // Asking for the version is always a success outcome.
  //
  // Usage:
  //
  //   try {
  //     ...computing...
  //     throw Version{NAME}
  //     ...
  //   } catch (exception::aspect::Exiting const &e) {
  //     e.stream() << format(e) << '\n';
  //   }
  //
  class Version;
}
#endiv
#divert <hpp>
#import nonstd.sysexits.Code
#import scold.easy.Program
#import scold.easy.exception.aspect.Exiting
#import scold.easy.exception.provides.Exiting
#import std.string
#import std.exception
class scold::easy::exception::Version : private provides::Exiting, public aspect::Exiting, public std::exception {
  struct ancestors {
    using Exception = std::exception;
    using Aspect = aspect::Exiting;
    using Provides = provides::Exiting;
  };
public:
  inline explicit Version(Program const &);
  auto stream() const noexcept -> std::ostream & override;
  auto code() const noexcept -> nonstd::sysexits::Code override;
  auto what() const noexcept -> char const * override;
private:
  static auto format(Program const &) -> std::string;
};
#endiv
#divert <ipp>
#import std.cout
#import nonstd.sysexits.constants
namespace scold::easy::exception {
  Version::Version(Program const &name)
    : ancestors::Provides{std::cout, nonstd::sysexits::OK, format(name)}
    , ancestors::Aspect{}
    , ancestors::Exception{}
  { }
}
#endiv
#divert <cpp>
namespace scold::easy::exception {
  auto Version::stream() const noexcept -> std::ostream & {
    return ancestors::Provides::stream();
  }
  auto Version::code() const noexcept -> nonstd::sysexits::Code {
    return ancestors::Provides::code();
  }
  auto Version::what() const noexcept -> char const * {
    return ancestors::Provides::what();
  }
}
// Because we're trying to reduce dependencies here, we are not using autotools::autoconf::Config<CONFIG>::package_version()
// [[FIXTHIS]] get a variant of autoheader that produces a config.h that is C++20 friendly.  #defines are bad.
#include "config.h"
#import std.ostringstream
auto scold::easy::exception::Version::format(Program const &name) -> std::string {
  std::ostringstream buf;
  if (name.empty()) {
    buf << "noname";
  } else {
    buf << name;
  }
  buf << ": version v" << PACKAGE_VERSION;
  return buf.str();
}
#endiv
