// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want::aliases::detail {
  //
  // The string prefix and value extraction operation
  //
  // Usage:
  //
  //    ./a.out -E/usr/include --external=/usr/include
  //
  //   if (auto started = starts_with("-E", "--external=") == word; started) {
  //      .. begins with -E or --external=
  //      auto suffix = started.value();
  //      ...use the suffix...
  //   }
  //
  class Starts_With;
}
#endiv
#divert <hpp>
#import std.string
#import want.aliases.detail.Remainder
namespace want::aliases::detail {
  //
  // tests "starts_with" and recovers the remainder.
  //
  inline auto operator==(std::string const &candidate, Starts_With const &corpus) -> Remainder;
  inline auto operator!=(std::string const &candidate, Starts_With const &corpus) -> bool;
  inline auto operator==(Starts_With const &corpus, std::string const &candidate) -> Remainder;
  inline auto operator!=(Starts_With const &corpus, std::string const &candidate) -> bool;
}
#import std.string
#import want.aliases.detail.Set
class want::aliases::detail::Starts_With : public Set {
  using ancestor = Set;
public:
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) inline explicit Starts_With(STRINGS ...);
private:
  friend auto detail::operator==(std::string const &, Starts_With const &) -> Remainder;
  inline auto perform(std::string const &candidate) const -> Remainder;
};
#endiv
#divert <ipp>
namespace want::aliases {
  auto detail::operator==(std::string const &candidate, Starts_With const &corpus) -> Remainder {
    return corpus.perform(candidate);
  }
  auto detail::operator!=(std::string const &candidate, Starts_With const &corpus) -> bool {
    return !(bool) operator==(candidate, corpus);
  }
  auto detail::operator==(Starts_With const &corpus, std::string const &candidate) -> Remainder {
    return candidate == corpus;
  }
  auto detail::operator!=(Starts_With const &corpus, std::string const &candidate) -> bool {
    return candidate != corpus;
  }
}
#import std.move
namespace want::aliases::detail {
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) Starts_With::Starts_With(STRINGS ...values)
    : ancestor{std::move(values)...}
  { }
  auto Starts_With::perform(std::string const &candidate) const -> Remainder {
    for (auto const &prefix : *this) {
      if (prefix.size() <= candidate.size() && prefix == candidate.substr(0, prefix.size())) {
        return Remainder{candidate.substr(prefix.size())};
      }
    }
    return Remainder{false};
  }
}
#endiv
