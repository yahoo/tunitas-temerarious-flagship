// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want::aliases::detail {
  //
  // The set, with equality meaning "membership" meaning "contains"
  //
  // Usage:
  //
  //   auto const set = want::aliases::any("a", "b", "c", "d");
  //   if (word == set) {
  //     ...one of them...
  //   } else {
  //     ...not one of them...
  //   }
  //
  class Any;
}
#endiv
#divert <hpp>
#import std.string
namespace want::aliases::detail {
  //
  // Any membership; is the candidate in the corpus?
  //
  inline auto operator==(std::string const &candidate, Any const &corpus) -> bool;
  inline auto operator!=(std::string const &candidate, Any const &corpus) -> bool;
  inline auto operator==(Any const &corpus, std::string const &candidate) -> bool;
  inline auto operator!=(Any const &corpus, std::string const &candidate) -> bool;
}
#import want.aliases.detail.Set
class want::aliases::detail::Any : public Set {
  using ancestor = Set;
public:
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) inline explicit Any(STRINGS ...);
};
#endiv
#divert <ipp>
namespace want::aliases {
  auto detail::operator==(std::string const &candidate, Any const &corpus) -> bool {
    return corpus.end() != corpus.find(candidate);
  }
  auto detail::operator!=(std::string const &candidate, Any const &corpus) -> bool {
    return !operator==(candidate, corpus);
  }
  auto detail::operator==(Any const &corpus, std::string const &candidate) -> bool {
    return candidate == corpus;
  }
  auto detail::operator!=(Any const &corpus, std::string const &candidate) -> bool {
    return candidate != corpus;
  }
}
#import std.move
namespace want::aliases::detail {
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) Any::Any(STRINGS ...values)
    : ancestor{std::move(values)...}
  { }
}
#endiv
