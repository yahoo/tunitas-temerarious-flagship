// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <fpp>
namespace want::aliases::detail {
  //
  // The common ancestor of all the set operations.
  // Descendants only.
  //
  //   Any         -> set membership
  //   Starts_With -> prefix matching
  //
  // Just the set, by construction.
  // The definition of equality (inequality) resides with the descendant.
  //
  // Usage:
  //
  //   auto const corpus = want::aliases::any("a", "b", "c", "d");
  //   if (word == corpus) {
  //     ...one of them...
  //   } else {
  //     ...not one of them...
  //   }
  //
  class Set;
}
#endiv
#divert <hpp>
#import std.set
#import std.string
#import want.aliases.required.Stringable
class want::aliases::detail::Set : public std::set<std::string> {
  using ancestor = std::set<std::string>;
protected:
  ~Set() = default;
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) inline explicit Set(STRINGS ...);
private:
  inline auto import() -> void;
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) inline auto import(std::string first, STRINGS ...rest) -> void;
};
#endiv
#divert <ipp>
#import std.move
namespace want::aliases::detail {
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) Set::Set(STRINGS ...values)
    : ancestor{} {
    import(std::move(values)...);
  }
  auto Set::import() -> void { }
  template<typename... STRINGS> requires (true && ... && required::Stringable<STRINGS>) auto Set::import(std::string first, STRINGS ...rest) -> void {
    ancestor::insert(std::move(first));
    import(std::move(rest)...);
  }
}
#endiv
