// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-temerarious-flagship/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/build/temerarious-flagship/tree/LICENSE
#divert <fpp>
#import autotools.autoconf.Config.tunitas.flagship.temerarious.CONFIG
#import langu.age
#import tunitas.application.exits.constants
#import tunitas.application.exits.Code
#import tunitas.application.options // namespace options::c
#import tunitas.application.options.Arguments
#import tunitas.application.options.Program
#import tunitas.flagship.temerarious
namespace app::roff {
  inline namespace package_main {
           namespace package_body_main::body { }
           inline namespace interface { using namespace package_body_main::body; } }
  namespace package_main::package_body_main::body {
    namespace c = tunitas::application::options::c;
    namespace version = tunitas::flagship::temerarious::version;
    inline namespace constants { using namespace tunitas::application::exits::constants; } 
    using namespace langu::age;
    //
    using Config = autotools::autoconf::Config<tunitas::flagship::temerarious::CONFIG>;
    using tunitas::application::options::Program;
    using tunitas::application::options::Arguments;
    using Exit = tunitas::application::exits::Code;
  }
}
#endiv
#divert <hpp>
#import tunitas.application.exits.Code
#import tunitas.application.options.c.Argv
namespace app::roff::package_main::interface {
  inline auto main(int, char *[]) -> Exit;
  inline auto main(c::Argv) -> Exit;
  auto main(Program, Arguments) -> Exit;
}
#endiv
#divert <ipp>
#import std.clog
// not until v2 #import substd.exception.Exception
#import nonstd.exception.Exception
namespace app::roff::package_main {
  inline auto interface::main(int cc, char *vv[]) -> Exit { return main(c::Argv(cc, vv)); }
  auto interface::main(c::Argv av) -> Exit try {
    auto program = Program{av.front()};
    auto arguments = Arguments{1+av.begin(), av.end()};
    return main(move(program), move(arguments));
#if 0
  } catch (substd::exception::Exception const &e) {
#else
  } catch (nonstd::exception::Exception const &e) {
#endif
    std::clog << Config::package() << ": error, there was an unexpected problem saying " << e.what() << '\n';
    return SOFTWARE;
  }
}
#endiv
#divert <cpp>
#import app.roff.exception.File
#import app.roff.run
#import app.roff.usage.Message
#import langu.age.q
#import nonstd.exception.Unimplemented
#import nonstd.same_as
#import std.clog
#import tunitas.flagship.temerarious.version.Generator
namespace app::roff::package_main {
  auto interface::main(Program program, Arguments arguments) -> Exit try {
    while (!arguments.empty()) {
      static_assert(nonstd::same_as<tunitas::string::Storage, Arguments::value_type>);
      auto const &item = arguments.front();
      if (item.empty()) {
        std::clog << program << ": error, the <subprogram> cannot be empty\n";
        return USAGE;
      } else if ("--usage"s == item || "--help"s == item || "-h"s == item) {
        std::cout << usage::Message{program} << '\n';
        return OK;
      } else if ("--version"s == item || "-V"s == item) {
        std::cout << version::Generator{} << '\n';
        return OK;
      } else if ("--"s == item) {
        // The options formally end at an explicit "--"
        arguments.pop_front();
        break;
      } else if ('-' == item.front()) {
        std::clog << program << ": error, invalid option (use --usage to explore)\n";
        return USAGE;
      } else {
        // The options have ended
        break;
      }
    }
    if (auto count=arguments.size(); 0 == count) {
      return run(std::cin, std::cout);
    } else if (2 == count) {
      return run(arguments.front(), arguments.back());
    } else {
      auto &erroneity{std::clog};
      erroneity << program << ": error, there must be either zero or exactly two (2) flie paths\n"
                << program << ": notice, instead there were " << count << " " << (1 == count ? "word" : "words") << "after the options\n"
                << program << ": notice, use " << q("--usage") << " to see the available options\n";
      return USAGE;
    }
  } catch (exception::File const &e) {
    std::clog << program << ": error, " << e.what() << '\n';
    return FAIL;
  }
}
#endiv
