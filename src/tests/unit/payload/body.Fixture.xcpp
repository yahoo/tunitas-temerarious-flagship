// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-temerarious-flagship/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/build/temerarious-flagship/tree/LICENSE
#divert <fpp>
#import tunitas.flagship.temerarious.payload
#import tunitas.flagship.temerarious.exception
#import tunitas.string
namespace tests::unit::payload::body {
  namespace [[eponymous]] fixture {
    class Fixture;
    namespace library = ::tunitas::flagship::temerarious::payload::package_payload::package_body_payload::body;
    namespace exception = ::tunitas::flagship::temerarious::exception;
    namespace string = ::tunitas::string;
  }
  using fixture::Fixture;
}
#endiv
#divert <hpp>
#import tunitas.string.View
#import tunitas.string.Storage
#import std.vector
#import tests.unit.payload.Here
struct tests::unit::payload::body::fixture::Fixture : public cppunit::test::Fixture, private Here {
  auto test_identifier0() -> void;
  auto test_identifierN() -> void;
  auto test_identifier_each() -> void;
  auto test_identifier_some_good() -> void;
  auto test_identifier_some_fail() -> void;
  auto test_text_each() -> void;
  auto test_text_some_good() -> void;
  auto test_text_some_fail() -> void;
  auto test_filepath_each() -> void;
  auto test_filepath_some_good() -> void;
  auto test_filepath_some_fail() -> void;
  auto test_find_first_blank() -> void;
  auto test_has_blanks() -> void;
  auto test_ensure_not_empty_yet_is_empty() -> void;
  auto test_ensure_not_empty_yet_is_full() -> void;
  static auto suite() -> cppunit::Test *;
protected:
  inline static constexpr auto NO = string::View::npos;
  using Series = std::vector<string::Storage>;
  static auto generate_identifier_goodness() -> Series;
  static auto generate_identifier_failures() -> Series;
  static auto generate_filepath_goodness() -> Series;
  static auto generate_filepath_failures() -> Series;
  static auto generate_text_goodness() -> Series;
  static auto generate_text_failures() -> Series;
};
#endiv
#divert <cpp>
#import tests.unit.payload.body.Fixture.generate
namespace tests::unit::payload::body::fixture {
  auto Fixture::test_identifier0() -> void {
    for (auto i{0u}, e{256u}; e != i; ++i) {
      auto c = char(i);
      library::isidentifier0(c); // <-------------------- test this (show it withstands being called at all)
    }
  }
  auto Fixture::test_identifierN() -> void {
    for (auto i{0u}, e{256u}; e != i; ++i) {
      auto c = char(i);
      library::isidentifierN(c); // <-------------------- test this (show it withstands being called at all)
    }
  }
  auto Fixture::test_identifier_each() -> void {
    for (auto i{0u}, e{256u}; e != i; ++i) {
      for (auto ii{0u}, ee{256u}; ee != ii; ++ii) {
        auto c = char(i);
        auto cc = char(ii);
        auto s = string::Storage{c, cc}; // WATCHOUT ... get the initializer, not the constructor
        CPPUNIT_ASSERT(2 == s.size());
        library::isidentifier(s); // <-------------------- test this (show it withstands being called at all)
      }
    }
  }
  auto Fixture::test_identifier_some_good() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_identifier_goodness()]{
      for (auto const item : p2012) {
        auto good = library::isidentifier(item); // <-------------------- test this
        CPPUNIT_ASSERT(good);
      }
    }();
  }
  auto Fixture::test_identifier_some_fail() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_identifier_failures()]{
      for (auto const item : p2012) {
        auto good = library::isidentifier(item); // <-------------------- test this
        CPPUNIT_ASSERT(!good);
      }
    }();
  }
  auto Fixture::test_filepath_each() -> void {
    for (auto i{0u}, e{256u}; e != i; ++i) {
      auto c = char(i);
      auto s = string::Storage(1u, c); // WATCHOUT ... get the constructor, not the initializer
      CPPUNIT_ASSERT(1 == s.size());
      library::isfilepath(s); // <-------------------- test this (show it withstands being called at all)
    }
  }
  auto Fixture::test_filepath_some_good() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_filepath_goodness()]{
      for (auto const item : p2012) {
        auto good = library::isfilepath(item); // <-------------------- test this
        CPPUNIT_ASSERT(good);
      }
    }();
  }
  auto Fixture::test_filepath_some_fail() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_filepath_failures()]{
      for (auto const item : p2012) {
        auto good = library::isfilepath(item); // <-------------------- test this
        CPPUNIT_ASSERT(!good);
      }
    }();
  }
  auto Fixture::test_text_each() -> void {
    for (auto i{0u}, e{256u}; e != i; ++i) {
      auto c = char(i);
      auto s = string::Storage{1, c};
      library::istext(s); // <-------------------- test this (show it withstands being called at all)
    }
  }
  auto Fixture::test_text_some_good() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_text_goodness()]{
      for (auto const item : p2012) {
        auto good = library::istext(item); // <-------------------- test this
        CPPUNIT_ASSERT(good);
      }
    }();
  }
  auto Fixture::test_text_some_fail() -> void {
    // https://github.com/cplusplus/papers/issues/939
    // https://wg21.link/p2012r0
    [p2012=generate_text_failures()]{
      for (auto const item : p2012) {
        auto good = library::istext(item); // <-------------------- test this
        CPPUNIT_ASSERT(!good);
      }
    }();
  }
  auto Fixture::test_find_first_blank() -> void {
    CPPUNIT_ASSERT(2 == library::find_first_blank("ab "sv));
    CPPUNIT_ASSERT(NO == library::find_first_blank("abc"sv));
  }
  auto Fixture::test_has_blanks() -> void {
    CPPUNIT_ASSERT(true == library::has_blanks("ab "sv));
    CPPUNIT_ASSERT(false == library::has_blanks("abc"sv));
  }
  auto Fixture::test_ensure_not_empty_yet_is_empty() -> void try {
    library::ensure_not_empty(here(), ""sv);
    CPPUNIT_ASSERT(true);
  } catch (exception::Aspect const &) {
    CPPUNIT_ASSERT(true);
  }
  auto Fixture::test_ensure_not_empty_yet_is_full() -> void {
    library::ensure_not_empty(here(), "full"sv);
  }
  auto Fixture::suite() -> cppunit::Test * {
    using namespace rigging::suite;
    auto series = Stream{"body"};
    series << []{
                auto id = Stream{"identifier"};
                id << call("0", &Fixture::test_identifier0)
                   << call("N", &Fixture::test_identifierN)
                   << []{
                        auto some = Stream{"some"};
                        some << call("good", &Fixture::test_identifier_some_good)
                             << call("fai", &Fixture::test_identifier_some_fail)
                             << END;
                        return move(some);
                      }()
                   << END;
                return move(id);
              }()
           << []{
                auto text = Stream{"text"};
                text << call("each", &Fixture::test_text_each)
                     << []{
                          auto some = Stream{"some"};
                          some << call("good", &Fixture::test_text_some_good)
                               << call("fail", &Fixture::test_text_some_fail)
                               << END;
                          return move(some);
                        }()
                     << END;
                return move(text);
              }()
           << []{
                auto path = Stream{"filepath"};
                path << call("each", &Fixture::test_filepath_each)
                     << []{
                          auto some = Stream{"some"};
                          some << call("good", &Fixture::test_filepath_some_good)
                               << call("fail", &Fixture::test_filepath_some_fail)
                               << END;
                          return move(some);
                        }()
                     << END;
                return move(path);
              }()
           << call("find_first_blank", &Fixture::test_find_first_blank)
           << []{
                auto sure = Stream{"ensure_not_empty"};
                sure << []{
                          auto yet = Stream{"yet-is"};
                          yet << call("empty", &Fixture::test_ensure_not_empty_yet_is_empty)
                              << call("full", &Fixture::test_ensure_not_empty_yet_is_full)
                              << END;
                          return move(yet);
                        }()
                     << END;
                return move(sure);
              }()
           << END;
    return finalize(series);
  }
}
#endiv
