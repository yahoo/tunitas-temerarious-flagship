// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-temerarious-flagship/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/build/temerarious-flagship/tree/LICENSE
#divert <fpp>
namespace tunitas::flagship::temerarious::processor {
  inline namespace package_run {
           namespace package_body_run { }
           inline namespace interface { using namespace package_body_run; }
  }
}
#import tunitas.flagship.temerarious.parser.assess
#import langu.age
#import nonstd
namespace tunitas::flagship::temerarious::processor {
  namespace package_run::package_body_run {
    using namespace langu::age; // pretty quoting in error messages
    using namespace parser; // assess(...) Assessed, Assessment (you get the idea)
    using namespace nonstd; // for visit, Visitor
  }
}
#endiv
#divert <hpp>
#import tunitas.Success
#import tunitas.flagship.temerarious.stream.Input
#import tunitas.flagship.temerarious.stream.Output
namespace tunitas::flagship::temerarious::processor::package_run::interface {
  //
  // Run the processor.
  //
  // Specification:
  //
  //   Run it either on cin or on an actual file.
  //
  // Design:
  //
  //   In the heraneutics which is the style of these things.
  //
  // Usage:
  //
  //   
  //   auto erroneity = source::Output{std::clog};
  //   auto outbound = source::Output{std::cout};
  //   auto inbound = source::Input{std::cin}; .............................. or get an ifstream on an actual file
  //   auto ess = processor::run(move(inbound), outbound, erroneity);
  //
  // And when do you use which?
  // https://en.cppreference.com/w/cpp/language/value_category (prvalue, rvalue, lvalue, etc.)
  //
  //                            /----------------------------------- prvalue, the Input is accepted by the State.
  //                            |
  //                            |                  /---------------- lvalue, the Output is referenced to an existing one.
  //                            |                  |
  //                            v                  v
  inline auto run(stream::Input &&, stream::Output &) -> Success;
  auto run(stream::Input &&, stream::Output &out, stream::Output &err) -> Success;
}
#endiv
#divert <ipp>
#import std.clog
namespace tunitas::flagship::temerarious::processor::package_run {
  auto interface::run(stream::Input &&inbound, stream::Output &outbound) -> Success {
    auto erroneous = stream::Output{std::clog};
    return run(forward<stream::Input>(inbound), outbound, erroneous);
  }
}
#endiv
#divert <cpp>
#import tunitas.string.Storage
#import tunitas.flagship.temerarious.error.Code
static_assert(sizeof (tunitas::flagship::temerarious::error::code::Companion));
static_assert(sizeof (std::is_error_code_enum<tunitas::flagship::temerarious::error::code::Companion>));
static_assert(std::is_error_code_enum<tunitas::flagship::temerarious::error::code::Companion>::value);
// [[TODO]] v2-series #import substd.exception.Filesystem, nonstd::exception::Filesystem<string::View>
#import tunitas.flagship.temerarious.exception // cascade namespace exception
#import tunitas.flagship.temerarious.directive.exception.Aspect
#import tunitas.flagship.temerarious.input.exception.Aspect
#import tunitas.flagship.temerarious.input.exception.Present
#import tunitas.flagship.temerarious.parser.assess
#import tunitas.flagship.temerarious.processor.exception.Aspect
#import tunitas.flagship.temerarious.processor.State
#import tunitas.flagship.temerarious.source.Line
#import nonstd.exception.Unreachable
#import langu.age.braket
#import langu.age.q
namespace tunitas::flagship::temerarious::processor::package_run {
  auto interface::run(stream::Input &&inbound_moved_into_state, stream::Output &outbound, stream::Output &erroneity) -> Success {
    auto state = State{forward<stream::Input>(inbound_moved_into_state), outbound};
    try {
      auto erroneous = Success{SUCCESS};
      do {
        auto buffer = string::Storage{};
        for (source::Line line{1u}; getline(state, buffer); ++line) {
          if (auto [directive, process, rest]=assess(buffer); Assessment::IGNORE == directive) {
            // Yup, ignore the line
          } else if (Assessment::ERROR == directive) {
            erroneity << line << "error, invalid roff directive <<" << buffer.substr(0, 2) << ">> must be ignored\n";
            erroneous = {error::Code::DIRECTIVE};
          } else if (Assessment::PASSTHROUGH == directive) {
            state.passthrough(buffer);
          } else if (Assessment::DIRECTIVE == directive) {
            // These are recovereable errors ... by policy, we will continue grinding after an error ... until we can't
            try {
              auto &in = state.inbounds.top().inbound; // ick ... we had this
              process(state, outbound, {line, in.input_name()}, rest);
            } catch (input::exception::Present const &e) {
              erroneity << line << "error, could not open " << q(e.whence()) << " because " << e.code().message() << '\n';
              erroneity << line << "error, failed roff directive <<" << buffer.substr(0, 2) << ">>\n";
              erroneous = {error::Code::FILE};
            } catch (input::exception::Aspect const &e) {
              erroneity << line << "error, could not find " << q(e.whence()) << '\n';
              erroneity << line << "error, failed roff directive <<" << buffer.substr(0, 2) << ">>\n";
              erroneous = {error::Code::FILE};
            } catch (directive::exception::Aspect const &e) {
              erroneity << line << "found-->|" << buffer << '\n';
              erroneity << line << "error, " << e.what() << '\n';
              erroneous = {error::Code::DIRECTIVE};
            }
          } else {
            throw exception::Unreachable{};
          }
        }
        [&erroneous, &t=state.inbounds.top(), &erroneity]{
          if (1 != t.diversions.size()) {
            erroneity << t.inbound.whence() << "error, there are unterminated block definitions at the end of the file\n"
                      << t.inbound.whence() << "notice, closing them and continuing anyway\n";
            erroneous = {error::Code::DIVERSION_UNCLOSED};
          }
          if (1 != t.conditions.size()) {
            erroneity << t.inbound.whence() << "error, there are unclosed conditional blocks at the end of the file\n"
                      << t.inbound.whence() << "notice, closing them and continuing anyway\n";
            erroneous = {error::Code::CONDITION_UNCLOSED};
          }
        }();
        state.inbounds.pop();
      } while (state.inbounds.size());
      return SUCCESS;
    } catch (processor::exception::Aspect const &e) {
      // These are unexpected; it means that some more specific error treatment (above) did not obtain.
      // These are typically a programmer error; they signal incorrect operation of the processor machinery itself.
      auto header = [&state, &erroneity]() -> auto & {
                      if (state.inbounds.size()) { erroneity << state.inbounds.top().inbound.whence(); }
                      return erroneity;
                    };
      header() << "error, the roff processor finished in an inconsistent state\n";
      header() << "error, (uh) there was some problem, " << e.what() << '\n';
      return {error::Code::PROCESSOR_INVALID};
    }
  }
}
#endiv
